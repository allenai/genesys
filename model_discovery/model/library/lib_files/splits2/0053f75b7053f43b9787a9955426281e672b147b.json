{
    "0053f75b7053f43b9787a9955426281e672b147b-0": "\\forestset\n\nnice empty nodes/.style= for tree= s sep=0.3em, l sep=0.3em, inner ysep=0.5em, inner xsep=0.45em, l=0, calign=midpoint, fit=tight, where n children=0 tier=word, minimum height=2.0em, , where n children=2 l-=1em, , parent anchor=south, child anchor=north, delay=if content= inner sep=0pt, edge path=[\\forestoptionedge] (!u.parent anchor) \u2013 (.south)\\forestoptionedge label; , ,\n\nUnsupervised Latent Tree Induction with Deep Inside-Outside Recursive Autoencoders\n\nAndrew Drozdov1,\u2217 &Pat Verga1,\u2217 &Mohit Yadav1, &Mohit Iyyer1 &Andrew McCallum1 \\AND 1College of Information and Computer Sciences University of Massachusetts Amherst \\AND {adrozdov, pat, ymohit, miyyer, mccallum}@cs.umass.edu Equal contribution, randomly ordered.",
    "0053f75b7053f43b9787a9955426281e672b147b-1": "Abstract\n\nWe introduce deep inside-outside recursive autoencoders (DIORA), a fully-unsupervised method for discovering syntax that simultaneously learns representations for constituents within the induced tree. Our approach predicts each word in an input sentence conditioned on the rest of the sentence and uses inside-outside dynamic programming to consider all possible binary trees over the sentence. At test time the CKY algorithm extracts the highest scoring parse. DIORA achieves a new state-of-the-art F1 in unsupervised binary constituency parsing (unlabeled) in two benchmark datasets, WSJ and MultiNLI. 1 Introduction\n\nSyntactic parse trees are useful for downstream tasks such as relation extraction (Gamallo et al., 2012), semantic role labeling (Sutton and McCallum, 2005; He et al., 2018), machine translation (Aharoni and Goldberg, 2017; Eriguchi et al., 2017; Zaremoodi and Haffari, 2018), and text classification (Li and Roth, 2006; Tai et al., 2015). Traditionally, supervised parsers trained on datasets such as the Penn Treebank (Marcus et al., 1993) are used to obtain syntactic trees. However, the treebanks used to train these supervised parsers are typically small and restricted to the newswire domain. Unfortunately, models trained on newswire treebanks tend to perform considerably worse when applied to new types of data, and creating new domain specific treebanks with syntactic annotations is expensive and time-consuming. Motivated by the desire to address the limitations of supervised parsing and by the success of large-scale unsupervised modeling such as ELMo and BERT Peters et al. (2018a); Devlin et al. (2019), we propose a new deep learning method of unsupervised parser training that can extract both shallow parses (i.e., noun phrases or entities) and full syntactic trees from any domain or language automatically without requiring any labeled training data. In addition to producing parses, our model simultaneously builds representations for internal constituents that reflect syntactic and semantic regularities which can be leveraged by downstream tasks. Our model builds on existing work developing latent tree chart parsers (Socher et al., 2011b; Le and Zuidema, 2015; Yogatama et al., 2017; Maillard et al., 2017; Choi et al., 2018). These methods produce representations for all internal nodes in the tree (cells in the chart), each generated as a soft weighting over all possible sub-trees (\u00a72). Unfortunately, they still require sentence-level annotations during training, as they are all trained to optimize a downstream task, typically natural language inference. To address these limitations, we present deep inside-outside recursive autoencoders (DIORA) which enable unsupervised discovery and representation of constituents without requiring any supervised training data. DIORA incorporates the inside-outside algorithm (Baker, 1979; Lari and Young, 1990) into a latent tree chart parser.",
    "0053f75b7053f43b9787a9955426281e672b147b-2": "The bottom-up inside step calculates a representation for all possible constituents within a binary tree over the input sentence. This step is equivalent to the forward-pass of previous latent tree chart parsers (Maillard et al., 2017). These inside representations only encode the current subtree, ignoring all outside context. Thus, we perform an additional top-down outside calculation for each node in the tree, providing external context into the sub-tree representations in each chart cell. The model is then trained with the objective that the outside representations of the leaf cells should reconstruct the corresponding leaf input word, analogous to masked language model (Devlin et al., 2019) pre-training, except by using dynamic programming we predict every word from a completely unmasked context. The single most likely tree can be recovered using the CKY algorithm and compatibility scores between constituents. Previous work either predict trees that are not well aligned with known treebanks (Yogatama et al., 2017; Choi et al., 2018), or has no mechanism for explicitly modeling phrases, requiring a complex procedure to extract syntactic structures (Shen et al., 2018). To probe different properties of our model, we run experiments on unsupervised parsing, segment recall, and phrase representations. DIORA achieves multiple new state-of-the-art results for unsupervised constituency parsing (absolute improvements of 13.7%, 11.5%, and 7.8% on WSJ, WSJ-40, and MultiNLI), has a greater recall on more constituent types than a strong baseline, and produces meaningful phrase representations. 2 DIORA: Deep Inside-Outside Recursive Autoencoders\n\nOur goal is to design a model and unsupervised training procedure that learns structure from raw text. The design of DIORA is based on our hypothesis is that the most effective compression of a sentence will be derived from following the true syntactic structure of the underlying input. Our approach builds on previous latent tree chart parsers which are augmented with the inside-outside algorithm (Baker, 1979; Lari and Young, 1990) and trained to reproduce each input word from its outside context. Based on our hypothesis, loosely inspired by the linguistic \u201csubstitution principle\u201d (Frege, 1960), the model will best reconstruct the input by discovering and exploiting syntactic regularities of the text. The inside pass of our method recursively compresses the input sequence, at each step inputting the vector representations of the two children into a composition function (\u00a72.1.1) that outputs an inside vector representation of the parent. This process continues up to the root of the tree, eventually yielding a single vector representing the entire sentence (Figure 2a). This is loosely analogous to the compression step of an autoencoder and equivalent to existing latent tree chart parsers forward pass (Maillard et al., 2017). Following this, we initiate the outside pass of our algorithm with a generic (root) representation that is learned as a separate parameter. As the outside step of the inside-outside algorithm (Figure 2b), we unfold until finally producing representations of the leaf nodes. These leaves are then optimized to reconstruct the input sentence as done in an autoencoder-based deep neural network. 2.1 Filling the Chart with Inside-Outside\n\nEach inside representation is the root of a particularly sub-tree, and that representation is generated by considering only the descendant constituents within that sub-tree, ignoring any outside context. After the inside representations are calculated, we perform a top-down outside pass to compute outside representations. The outside representations are encoded by looking at only the context of a given sub-tree. Once the chart is filled, each constituent (cell in the chart) is associated with an inside vector , an outside vector , inside compatibility score and outside compatibility score . The input to our model is a sentence made up of tokens, . Each token has a corresponding pre-trained embedded vector . 2.1.1 Inside Pass\n\nFor each pair of neighboring constituents and 111The symbols , , and are identifiers of spans from the input . The symbol identifies a token from the set of negative examples ., we compute a compatibility score and a composition vector. The score and vector that represent a particular span are computed using a soft weighting over all possible pairs of constituents, that together fully cover the span (we refer to this set of constituent pairs as ). Vectors for spans of length 1 are initialized as a non-linear transformation 222This function shares its bias term with , although is not tied to any other weights. of the embedded input , and the scores associated with these spans are set to :\n\n[ x o u ] matrix \ud835\udc65 \ud835\udc5c \ud835\udc62 \\displaystyle\\begin{bmatrix}x\\\\\no\\\\\nu\\end{bmatrix} = [ \u03c3 \u03c3 tanh ] \u200b ( U \u03c8 \u200b v k + b ) absent matrix \ud835\udf0e \ud835\udf0e subscript \ud835\udc48 \ud835\udf13 subscript \ud835\udc63 \ud835\udc58 \ud835\udc4f \\displaystyle=\\begin{bmatrix}\\sigma\\\\\n\\sigma\\\\\n\\tanh\\end{bmatrix}(U_{\\psi}v_{k}+b) a \u00af \u200b ( k ) \u00af \ud835\udc4e \ud835\udc58 \\displaystyle\\bar{a}(k) = o + tanh \u2061 ( x \u2299 u ) absent \ud835\udc5c direct-product \ud835\udc65 \ud835\udc62 \\displaystyle=o+\\tanh(x\\odot u) e \u00af \u200b ( k ) \u00af \ud835\udc52 \ud835\udc58 \\displaystyle\\bar{e}(k) = 0 absent 0 \\displaystyle=0\n\nHigher levels of the chart are computed as a weighted summation of constituent pairs:\n\na \u00af \u200b ( k ) \u00af \ud835\udc4e \ud835\udc58 \\displaystyle\\bar{a}(k) = \u2211 i , j \u2208 { k } e \u200b ( i , j ) \u200b a \u200b ( i , j ) absent subscript \ud835\udc56 \ud835\udc57 \ud835\udc58 \ud835\udc52 \ud835\udc56 \ud835\udc57 \ud835\udc4e \ud835\udc56 \ud835\udc57 \\displaystyle=\\sum\\limits_{i,j\\in\\{k\\}}e(i,j)~{}a(i,j) e \u00af \u200b ( k ) \u00af \ud835\udc52 \ud835\udc58 \\displaystyle\\bar{e}(k) = \u2211 i , j \u2208 { k } e \u200b ( i , j ) \u200b e ^ \u200b ( i , j ) absent subscript \ud835\udc56 \ud835\udc57 \ud835\udc58 \ud835\udc52 \ud835\udc56 \ud835\udc57 ^ \ud835\udc52 \ud835\udc56 \ud835\udc57 \\displaystyle=\\sum\\limits_{i,j\\in\\{k\\}}e(i,j)~{}\\hat{e}(i,j)\n\nThe compatibility function is meant to produce a score for how likely a pair of neighboring cells are to be merged. We implement this as a bilinear function of the vectors from neighboring spans, using a learned parameter matrix .",
    "0053f75b7053f43b9787a9955426281e672b147b-3": "We additionally add the individual scores from each two merging cells. Intuitively, these individual scores correspond to how likely each of the cells would exist in the final binary tree independently. The formula for the compatibility function (and its normalized form ) is defined as follows:\n\ne \u200b ( i , j ) \ud835\udc52 \ud835\udc56 \ud835\udc57 \\displaystyle e(i,j) = exp \u2061 ( e ^ \u200b ( i , j ) ) \u2211 i ^ , j ^ \u2208 { k } exp \u2061 ( e ^ \u200b ( i ^ , j ^ ) ) absent ^ \ud835\udc52 \ud835\udc56 \ud835\udc57 subscript ^ \ud835\udc56 ^ \ud835\udc57 \ud835\udc58 ^ \ud835\udc52 ^ \ud835\udc56 ^ \ud835\udc57 \\displaystyle=\\frac{\\exp(\\hat{e}(i,j))}{\\sum\\limits_{\\hat{i},\\hat{j}\\in\\{k\\}}\\exp(\\hat{e}(\\hat{i},\\hat{j}))} e ^ \u200b ( i , j ) ^ \ud835\udc52 \ud835\udc56 \ud835\udc57 \\displaystyle\\hat{e}(i,j) = \u03d5 \u200b ( a \u00af \u200b ( i ) , a \u00af \u200b ( j ) ; S \u03b1 ) + e \u00af \u200b ( i ) + e \u00af \u200b ( j ) absent italic-\u03d5 \u00af \ud835\udc4e \ud835\udc56 \u00af \ud835\udc4e \ud835\udc57 subscript \ud835\udc46 \ud835\udefc \u00af \ud835\udc52 \ud835\udc56 \u00af \ud835\udc52 \ud835\udc57 \\displaystyle=\\phi(\\bar{a}(i),\\bar{a}(j);S_{\\alpha})+\\bar{e}(i)+\\bar{e}(j)\n\nWhere the bilinear projection is defined as:\n\n\u03d5 \u200b ( u , v ; W ) italic-\u03d5 \ud835\udc62 \ud835\udc63 \ud835\udc4a \\displaystyle\\phi(u,v;W) = u \u22a4 \u200b W \u200b v absent superscript \ud835\udc62 top \ud835\udc4a \ud835\udc63 \\displaystyle=u^{\\top}Wv\n\nFor the composition function we used either a (Tai et al., 2015) or a 2-layer (see Appendix A.1 for more precise definitons on both methods). In order for the remainder of equations to remain agnostic to the choice of composition function, we refer to the function as , which produces a hidden state vector and, in the case of , a cell state vector , resulting in:\n\na \u200b ( i , j ) = Compose \u03b1 \u200b ( a \u00af \u200b ( i ) , a \u00af \u200b ( j ) ) \ud835\udc4e \ud835\udc56 \ud835\udc57 subscript Compose \ud835\udefc \u00af \ud835\udc4e \ud835\udc56 \u00af \ud835\udc4e \ud835\udc57 \\displaystyle a(i,j)=\\mathrm{Compose}_{\\alpha}(\\bar{a}(i),\\bar{a}(j))\n\n2.1.2 Outside Pass\n\nThe outside computation is similar to the inside pass (depicted in Figure 2b). The root node of the outside chart is learned as a bias. Descendant cells are predicted using a disambiguation over the possible outside contexts. Each component of the context consists of a sibling cell from the inside chart and a parent cell from the outside chart. The function is analogous to the function . It is normalized over constituent pairs for the span , and is used to disambiguate among the many outside contexts. The function generates a phrase representation for the missing sibling cell. Equations for the outside computation follow:\n\nb \u00af \u200b ( k ) \u00af \ud835\udc4f \ud835\udc58 \\displaystyle\\bar{b}(k) = \u2211 i , j \u2208 { k } f \u200b ( i , j ) \u200b b \u200b ( i , j ) absent subscript \ud835\udc56 \ud835\udc57 \ud835\udc58 \ud835\udc53 \ud835\udc56 \ud835\udc57 \ud835\udc4f \ud835\udc56 \ud835\udc57 \\displaystyle=\\sum\\limits_{i,j\\in\\{k\\}}f(i,j)~{}b(i,j) f \u00af \u200b ( k ) \u00af \ud835\udc53 \ud835\udc58 \\displaystyle\\bar{f}(k) = \u2211 i , j \u2208 { k } f \u200b ( i , j ) \u200b f ^ \u200b ( i , j ) absent subscript \ud835\udc56 \ud835\udc57 \ud835\udc58 \ud835\udc53 \ud835\udc56 \ud835\udc57 ^ \ud835\udc53 \ud835\udc56 \ud835\udc57 \\displaystyle=\\sum\\limits_{i,j\\in\\{k\\}}f(i,j)~{}\\hat{f}(i,j) b \u200b ( i , j ) \ud835\udc4f \ud835\udc56 \ud835\udc57 \\displaystyle b(i,j) = Compose \u03b2 \u200b ( a \u00af \u200b ( i ) , b \u00af \u200b ( j ) ) absent subscript Compose \ud835\udefd \u00af \ud835\udc4e \ud835\udc56 \u00af \ud835\udc4f \ud835\udc57 \\displaystyle=\\mathrm{Compose}_{\\beta}(\\bar{a}(i),\\bar{b}(j)) f ^ \u200b ( i , j ) ^ \ud835\udc53 \ud835\udc56 \ud835\udc57 \\displaystyle\\hat{f}(i,j) = \u03d5 \u200b ( a \u00af \u200b ( i ) , b \u00af \u200b ( j ) ; S \u03b2 ) + e \u00af \u200b ( i ) + f \u00af \u200b ( j ) absent italic-\u03d5 \u00af \ud835\udc4e \ud835\udc56 \u00af \ud835\udc4f \ud835\udc57 subscript \ud835\udc46 \ud835\udefd \u00af \ud835\udc52 \ud835\udc56 \u00af \ud835\udc53 \ud835\udc57 \\displaystyle=\\phi(\\bar{a}(i),\\bar{b}(j);S_{\\beta})+\\bar{e}(i)+\\bar{f}(j)\n\nIn the majority of our experiments, the used in shares parameters with used in the inside pass, as do the compatibility functions and (see \u00a73.4 for results on the effects of parameter sharing). 2.2 Training Objective\n\nTo train our model we use an autoencoder-like language modeling objective.",
    "0053f75b7053f43b9787a9955426281e672b147b-4": "In a standard autoencoder, the entire input is compressed into a single lower dimensional representation. This representation, , is then decompressed and trained to reconstruct . In our model, we never condition the reconstruction of on a single because the root\u2019s outside representation is initialized with a bias rather than the root\u2019s own inside vector. Instead, we reconstruct conditioned on the many sub-tree roots, each of which is only a compression of a subset of the input. To approximate this reconstruction we use a max-margin loss considering a set of negative examples that are sampled according to their frequency from the vocabulary (further details in Appendix A.2).",
    "0053f75b7053f43b9787a9955426281e672b147b-5": "The terminal outside vector is trained to predict its original input . The per-instance loss function is described in Equation 1:\n\nL \ud835\udc99 = \u2211 i = 0 T \u2212 1 \u2211 i \u2217 = 0 N \u2212 1 max ( 0 , 1 \\displaystyle L_{\\bm{x}}=\\sum\\limits_{i=0}^{T-1}\\sum\\limits_{i^{*}=0}^{N-1}\\max(0,1 \u2212 b \u00af \u200b ( i ) \u22c5 a \u00af \u200b ( i ) \u22c5 \u00af \ud835\udc4f \ud835\udc56 \u00af \ud835\udc4e \ud835\udc56 \\displaystyle-\\bar{b}(i)\\cdot\\bar{a}(i) + b \u00af ( i ) \u22c5 a \u00af ( i \u2217 ) ) \\displaystyle+\\bar{b}(i)\\cdot\\bar{a}(i^{*})) (1)\n\nThe max-margin loss does not provide a gradient if the predicted vector is closer to its ground truth than the negative example by a margin greater than . For that reason, we also experimented with an objective based on cross-entropy, described in Equation 2:\n\nZ \u2217 superscript \ud835\udc4d \\displaystyle Z^{*} = \u2211 i \u2217 = 0 N \u2212 1 exp \u2061 ( b \u00af \u200b ( i ) \u22c5 a \u00af \u200b ( i \u2217 ) ) absent superscript subscript superscript \ud835\udc56 0 \ud835\udc41 1 \u22c5 \u00af \ud835\udc4f \ud835\udc56 \u00af \ud835\udc4e superscript \ud835\udc56 \\displaystyle=\\sum\\limits_{i^{*}=0}^{N-1}\\exp(\\bar{b}(i)\\cdot\\bar{a}(i^{*})) L \ud835\udc99 subscript \ud835\udc3f \ud835\udc99 \\displaystyle L_{\\bm{x}} = \u2212 \u2211 i = 0 T \u2212 1 log \u2061 exp \u2061 ( b \u00af \u200b ( i ) \u22c5 a \u00af \u200b ( i ) ) exp \u2061 ( b \u00af \u200b ( i ) \u22c5 a \u00af \u200b ( i ) ) + Z \u2217 absent superscript subscript \ud835\udc56 0 \ud835\udc47 1 \u22c5 \u00af \ud835\udc4f \ud835\udc56 \u00af \ud835\udc4e \ud835\udc56 \u22c5 \u00af \ud835\udc4f \ud835\udc56 \u00af \ud835\udc4e \ud835\udc56 superscript \ud835\udc4d \\displaystyle=-\\sum\\limits_{i=0}^{T-1}\\log\\frac{\\exp(\\bar{b}(i)\\cdot\\bar{a}(i))}{\\exp(\\bar{b}(i)\\cdot\\bar{a}(i))+Z^{*}} (2)\n\n2.3 DIORA CKY Parsing\n\nTo obtain a parse with DIORA, we populate an inside and outside chart using the input sentence. We can extract the maximum scoring parse based on our single grammar rule using the CKY procedure (Kasami, 1966; Younger, 1967). The steps for this procedure are described in Algorithm 1 and its runtime complexity in Appendix A.3. 3 Experiments\n\nTo evaluate the effectiveness of DIORA, we run experiments on unsupervised parsing, unsupervised segment recall, and phrase similarity. The model has been implemented in PyTorch (Team, 2018) and the code is published online.333https://github.com/iesl/diora For training details, see Appendix A.2. 3.1 Unsupervised Parsing\n\nWe first evaluate how well our model predicts a full unlabeled constituency parse. We look at two data sets used in prior work (Htut et al., 2018), The Wall Street Journal (WSJ) section of Penn Treebank (Marcus et al., 1993), and the automatic parses from MultiNLI (Williams et al., 2018b). WSJ has gold human-annotated parses and MultiNLI contains automatic parses derived from a supervised parser (Manning et al., 2014). In addition to PRPN Shen et al. (2018),444We consider the PRPN models using LM stopping criteria, which outperformed UP. we compare our model to deterministically constructed left branching, right branching, balanced, and random trees. We also compare to ON-LSTM Shen et al. (2019), an extension of the PRPN model, RL-SPINN (Yogatama et al., 2017), an unsupervised shift-reduce parser, and ST-Gumbel (Choi et al., 2018), an unsupervised chart parser. The latter two of these models are trained to predict the downstream task of natural language inference (NLI). 3.1.1 Binarized WSJ and MultiNLI results\n\nFor the full WSJ test set and MultiNLI datasets we follow the experimental setup of previous work (Williams et al., 2018a). We binarize target trees using Stanford CoreNLP (Manning et al., 2014) and do not remove punctuation (experiments in \u00a73.1.2 do remove punctuation). Latent tree models have been shown to perform particularly poorly on attachments at the beginning and end of the sequence (Williams et al., 2018a). To address this, we incorporate a post-processing heuristic (denoted as in result tables)555We did not have access to predictions or an implementation of the concurrent ON-LSTM model and therefore could not apply the heuristic.. This heuristic simply attaches trailing punctuation to the root of the tree, regardless of its predicted attachment. In Table 1, we see that DIORA+PP achieves the highest average and maximum F1 from five random restarts. This model achieves a mean F1 7 points higher than ON-LSTM and an increase of over 6.5 max F1 points. We also see that DIORA exhibits much less variance between random seeds than ON-LSTM. Additionally, we find that PRPN-UP and DIORA benefit much more from the heuristic than PRPN-LM. This is consistent with qualitative analysis showing that DIORA and PRPN-UP incorrectly attach trailing punctuation much more often than PRPN-LM. On the MultiNLI dataset, PRPN-LM is the top performing model without using the heuristic while DIORA matches PRPN-UP (Table 2. Using the heuristic, DIORA greatly surpasses both variants of PRPN.",
    "0053f75b7053f43b9787a9955426281e672b147b-6": "However, it is worth noting that this is not a gold standard evaluation and instead evaluates a model\u2019s ability to replicate the output of a trained parser (Manning et al., 2014). A second caveat is that SNLI Bowman et al. (2015) and MultiNLI contain several non-newswire domains. Syntactic parsers often suffer significant performance drops when predicting outside of the newswire domain that the models were trained on. 3.1.2 WSJ-10 and WSJ-40 results\n\nWe also compare our models to two subsets of the WSJ dataset that were used in previous unsupervised parsing evaluations. WSJ-10 and WSJ-40 contain sentences up to length 10 and 40 respectively after punctuation removal. We do not binarize either of these two splits in order to compare to previous work (see Appendix A.4 for more details on WSJ split differences). Not binarizing the target trees sets an upper-bound on the performance of our models, denoted as UB in Table 3. We compare against previous notable models for this task: CCM (Klein and Manning, 2002) uses the EM algorithm to learn probable nested bracketings over a sentence using gold or induced part-of-speech tags, and PRLG (Ponvert et al., 2011) performs constituent parsing through consecutive rounds of sentence chunking. In Table 3, we see that DIORA outperforms the previous state of the art for WSJ-40, PRLG, in max F1. The WSJ-10 split has been difficult for latent tree parsers such as DIORA, PRPN, and ON-LSTM, none of which (including our model) are able to improve upon previous non-neural methods. However, when we compare trends between WSJ-10 and WSJ-40, we see that DIORA does a better job at extending to longer sequences.",
    "0053f75b7053f43b9787a9955426281e672b147b-7": "3.2 Unsupervised Phrase Segmentation\n\nIn many scenarios, one is only concerned with extracting particular constituent phrases rather than a full parse. Common use cases would be identifying entities, noun phrases, or verb phrases for downstream analysis. To get an idea of how well our model can perform on phrase segmentation, we consider the maximum recall of spans in our predicted parse tree. We leave methods for cutting the tree to future work and instead consider the maximum recall of our model which serves as an upper bound on its performance. Recall here is the percentage of labeled constituents that appear in our predicted tree relative to the total number of constituents in the gold tree. These scores are separated by type and presented in Table 4. In Table 4 we see the breakdown of constituent recall across the 10 most common types. DIORA achieves the highest recall across the most types and is the only model to perform effectively on verb-phrases. Interestingly, DIORA performs worse than PRPN-LM at prepositional phrases. 3.3 Phrase Similarity\n\nOne of the goals of DIORA is to learn meaningful representations for spans of text. Most language modeling methods focus only on explicitly modeling token representations and rely on ad-hoc post-processing to generate representations for longer spans, typically relying on simple arithmetic functions of the individual tokens. To evaluate our model\u2019s learned phrase representations, we look at the similarity between spans of the same type within labeled phrase datasets. We look at two datasets. CoNLL 2000 (Tjong Kim Sang and Buchholz, 2000) is a shallow parsing dataset containing spans of noun phrases, verb phrases, etc. CoNLL 2012 (Pradhan et al., 2012) is a named entity dataset containing 19 different entity types.",
    "0053f75b7053f43b9787a9955426281e672b147b-8": "For each of the labeled spans with length greater than one, we first generate its phrase representation. We then calculate its cosine similarity to all other labeled spans. We then calculate if the label for that query span matches the labels for each of the most similar other spans in the dataset. In Table 5 we report precision@ for both datasets and various values of . The first baseline we compare against produces phrase representations from averaging context-insensitive (CI) ELMo vectors of individual tokens with the span. The second uses sentence-insensitive (SI) ELMo vectors, running the full ELMo over only the relevant tokens and ignoring the rest of the sentence. We also look at ELMo\u2019s output when given the entire sentence. When analyzing our baselines that run the full ELMo, we follow the procedure described in (Peters et al., 2018b) and represent phrases as a function of its first and last hidden state. We extract these states from the final ELMo layer (3rd BiLSTM) as these consistently gave the best performance among other options. For DIORA, we use the concatenation of the inside and outside representations (). For CoNLL 2000, we find that our model outperforms all baselines for all values of . This demonstrates DIORA\u2019s ability to capture and represent syntactic information within phrases. For CoNLL 2012, we find that DIORA outperforms both ELMoCI and ELMoSI while ELMo performs best overall. ELMoCI is surprisingly effective on this dataset even though it performed more poorly on CoNLL 2000. These results indicate that DIORA is capturing syntax quite well, but still has room to improve on more fine-grained semantic representations. 3.4 Impact of Modeling Choices\n\nTo test the impact of our modeling choices, we compared the performance of two different losses and four different composition functions on the full WSJ validation set. The losses were covered in Equations 1 (Margin) and 2 (Softmax). The two primary methods of composition we considered were TreeLSTM Tai et al. (2015) and MLP (a 2-hidden layer neural network). In addition, we experimented with a simple kernel of the MLP input and with a setting where both the inside and outside parameters are shared. The results are shown in Table 6. We see that MLP composition consistently performs better than with TreeLSTM, that MLP benefits from the Softmax loss, and that the best performance comes from sharing parameters. All other experimental results use this highly performant setting unless otherwise specified. 3.5 Qualitative Results\n\nLooking at our model\u2019s output, we see that some trees are an exact replication of the binarized ground truth (Fig. 3), or very close (Fig. 7). For future work we intend to explore common patterns in DIORA\u2019s learned structure, although some patterns are already recognizable, such as the affinity to group particles and verbs (Fig.",
    "0053f75b7053f43b9787a9955426281e672b147b-9": "6). 4 Related Work\n\nLatent Tree Learning A brief survey of neural latent tree learning models was covered in Williams et al. (2018a). The first positive result for neural latent tree parsing was shown in Htut et al. (2018), which used a language modeling objective. The model in Liu et al. (2018) uses an inside chart and an outside procedure to calculate marginal probabilities in order to align spans between sentences in entailment. Neural Inside-Outside Parsers The Inside-Outside Recursive Neural Network (IORNN) (Le and Zuidema, 2014) is closest to ours. It is a graph-based dependency parser that uses beam search and can reliably find accurate parses when retaining a -best list. In contrast, our model produces the most likely parse given the learned compatibility of the constituents. The Neural CRF Parser (Durrett and Klein, 2015), similar to DIORA, performs exact inference on the structure of a sentence, although requires a set of grammar rules and labeled parse trees during training. DIORA, like Liu et al. (2018), has a single grammar rule that applies to any pair of constituents and does not use structural supervision. Learning from Raw Text Unsupervised learning of syntactic structure has been an active research area (Brill et al., 1990), including for unsupervised segmentation (Ando and Lee, 2000; Goldwater et al., 2009; Ponvert et al., 2011) and unsupervised dependency parsing Spitkovsky et al. (2013). Some models exploit the availability of parallel corpora in multiple languages (Das and Petrov, 2011; Cohen et al., 2011). Others have shown that dependency parsing can be used for unsupervised constituency parsing (Spitkovsky et al., 2013; Klein and Manning, 2004), or that it\u2019s effective to prune a random subset of possible trees (Bod, 2006). These approaches aren\u2019t necessarily orthogonal to DIORA. For instance, our model may benefit when combined with an unsupervised dependency parser. 5 Conclusion\n\nIn this work we presented DIORA, an unsupervised method for inducing syntactic trees and representations of constituent spans. We showed inside-outside representations constructed with a latent tree chart parser and trained with an autoencoder language modeling objective learns syntactic structure of language effectively. In experiments on unsupervised parsing, chunking, and phrase representations we show our model is comparable to or outperforms previous methods, achieving the state-of-the-art performance on unsupervised unlabeled constituency parsing for the full WSJ (with punctuation), WSJ-40, and NLI datasets. We also show our model obtains higher segment recall than a comparable model and outperforms strong baselines on phrase representations on a chunking dataset. While the current model seems to focus primarily on syntax, future work can improve the model\u2019s ability to capture fine-grained semantics. Potential avenues include training larger models over much larger corpora, extra unsupervised or weakly-supervised phrase classification objectives, and other modeling enhancements. We are also eager to apply DIORA to other domains and languages which do not have rich linguistically annotated training sets. Acknowledgements\n\nWe are grateful to Carolyn Anderson, Adina Williams, Phu Mon Htut, and our colleagues at UMass for help and advice, and to the UMass NLP reading group and the anonymous reviewers for feedback on drafts of this work. This work was supported in part by the Center for Intelligent Information Retrieval, in part by the National Science Foundation (NSF) grant numbers DMR-1534431, IIS-1514053 and CNS-0958392. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect those of the sponsor. References\n\nAharoni and Goldberg (2017) Roee Aharoni and Yoav Goldberg. 2017. Towards string-to-tree neural machine translation. In Association for Computational Linguistics (ACL). Ando and Lee (2000) Rie Kubota Ando and Lillian Lee. 2000. Mostly-unsupervised statistical segmentation of japanese: Applications to kanji. In North American Association for Computational Linguistics (NAACL). Baker (1979) James K Baker. 1979. Trainable grammars for speech recognition. The Journal of the Acoustical Society of America, 65(S1):S132\u2013S132. Bod (2006) Rens Bod. 2006. An all-subtrees approach to unsupervised parsing. In Association for Computational Linguistics (ACL). Bowman et al. (2015) Samuel R. Bowman, Gabor Angeli, Christopher Potts, and Christopher D.",
    "0053f75b7053f43b9787a9955426281e672b147b-10": "Manning. 2015. A large annotated corpus for learning natural language inference. In Empirical Methods in Natural Language Processing (EMNLP). Brill et al. (1990) Eric Brill, David Magerman, Mitchell Marcus, and Beatrice Santorini. 1990. Deducing linguistic structure from the statistics of large corpora. In Information Technology, 1990.\u2019Next Decade in Information Technology\u2019, Proceedings of the 5th Jerusalem Conference on (Cat.",
    "0053f75b7053f43b9787a9955426281e672b147b-11": "No. 90TH0326-9), pages 380\u2013389. IEEE. Choi et al. (2018) Jihun Choi, Kang Min Yoo, and Sang-goo Lee. 2018. Learning to compose task-specific tree structures. In Advancement of Artificial Intelligence Conference on Artificial Intelligence (AAAI).",
    "0053f75b7053f43b9787a9955426281e672b147b-12": "Cohen et al. (2011) Shay B. Cohen, Dipanjan Das, and Noah A. Smith. 2011. Unsupervised structure prediction with non-parallel multilingual guidance. In Empirical Methods in Natural Language Processing (EMNLP). Das and Petrov (2011) Dipanjan Das and Slav Petrov. 2011. Unsupervised part-of-speech tagging with bilingual graph-based projections. In Association for Computational Linguistics (ACL). Devlin et al. (2019) Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. BERT: Pre-training of deep bidirectional transformers for language understanding. North American Association for Computational Linguistics (NAACL). Durrett and Klein (2015) Greg Durrett and Dan Klein. 2015. Neural crf parsing. In Association for Computational Linguistics (ACL). Eriguchi et al. (2017) Akiko Eriguchi, Yoshimasa Tsuruoka, and Kyunghyun Cho. 2017. Learning to parse and translate improves neural machine translation. In Association for Computational Linguistics (ACL). Frege (1960) Friedrich Ludwig Gottlob Frege. 1960. On sense and reference. In Zeitschrift f\u00fcr Philosophie und philosophische Kritik 100 (1892) 25-50; translated in Translations from the Philosophical Writings of Gottlob Frege (ed.",
    "0053f75b7053f43b9787a9955426281e672b147b-13": "by P. Geach and M. Black). Oxford. Gamallo et al. (2012) Pablo Gamallo, Marcos Garcia, and Santiago Fern\u00e1ndez-Lanza. 2012. Dependency-based open information extraction. In Joint workshop on unsupervised and semi-supervised learning in NLP. Association for Computational Linguistics (ACL). Goldwater et al. (2009) Sharon Goldwater, Thomas L Griffiths, and Mark Johnson. 2009. A bayesian framework for word segmentation: Exploring the effects of context. Cognition, 112:21\u201354. He et al. (2018) Luheng He, Kenton Lee, Omer Levy, and Luke Zettlemoyer. 2018. Jointly predicting predicates and arguments in neural semantic role labeling. In Association for Computational Linguistics (ACL). Htut et al. (2018) Phu Mon Htut, Kyunghyun Cho, and Samuel R Bowman. 2018. Grammar induction with neural language models: An unusual replication. In Empirical Methods in Natural Language Processing (EMNLP): Short Paper. Kasami (1966) Tadao Kasami. 1966. An efficient recognition and syntax-analysis algorithm for context-free languages.",
    "0053f75b7053f43b9787a9955426281e672b147b-14": "Coordinated Science Laboratory Report no. R-257. Kingma and Ba (2014) Diederik P. Kingma and Jimmy Ba. 2014. Adam: A method for stochastic optimization. CoRR, abs/1412.6980. Klein and Manning (2002) Dan Klein and Christopher D. Manning. 2002. A generative constituent-context model for improved grammar induction. In Association for Computational Linguistics (ACL). Klein and Manning (2004) Dan Klein and Christopher D. Manning. 2004. Corpus-based induction of syntactic structure: Models of dependency and constituency. In Association for Computational Linguistics (ACL). Lari and Young (1990) Karim Lari and Steve J Young. 1990. The estimation of stochastic context-free grammars using the inside-outside algorithm. Computer speech & language, 4(1):35\u201356.",
    "0053f75b7053f43b9787a9955426281e672b147b-15": "Le and Zuidema (2014) Phong Le and Willem Zuidema. 2014. The inside-outside recursive neural network model for dependency parsing.",
    "0053f75b7053f43b9787a9955426281e672b147b-16": "In Empirical Methods in Natural Language Processing (EMNLP). Le and Zuidema (2015) Phong Le and Willem Zuidema. 2015. The forest convolutional network: Compositional distributional semantics with a neural chart and without binarization. In Empirical Methods in Natural Language Processing (EMNLP), pages 1155\u20131164. Li and Roth (2006) Xin Li and Dan Roth. 2006. Learning question classifiers: the role of semantic information. Natural Language Engineering, 12(3):229\u2013249. Liu et al. (2018) Yang Liu, Matt Gardner, and Mirella Lapata. 2018. Structured alignment networks for matching sentences. In Empirical Methods in Natural Language Processing (EMNLP). Maillard et al. (2017) Jean Maillard, Stephen Clark, and Dani Yogatama. 2017. Jointly learning sentence embeddings and syntax with unsupervised tree-lstms. arXiv preprint arXiv:1705.09189. Manning et al. (2014) Christopher Manning, Mihai Surdeanu, John Bauer, Jenny Finkel, Steven Bethard, and David McClosky. 2014. The stanford corenlp natural language processing toolkit. In Association for Computational Linguistics (ACL): System Demonstrations. Marcus et al. (1993) Mitchell Marcus, Beatrice Santorini, and Mary Ann Marcinkiewicz. 1993. Building a large annotated corpus of english: The penn treebank. Computational linguistics, 19(2):313\u2013330. Peters et al. (2018a) Matthew E. Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and Luke Zettlemoyer. 2018a. Deep contextualized word representations. In North American Association for Computational Linguistics (NAACL). Peters et al. (2018b) Matthew E Peters, Mark Neumann, Luke Zettlemoyer, and Wen-tau Yih. 2018b. Dissecting contextual word embeddings: Architecture and representation. In Empirical Methods in Natural Language Processing (EMNLP). Ponvert et al. (2011) Elias Ponvert, Jason Baldridge, and Katrin Erk. 2011. Simple unsupervised grammar induction from raw text with cascaded finite state models.",
    "0053f75b7053f43b9787a9955426281e672b147b-17": "In Association for Computational Linguistics (ACL). Pradhan et al. (2012) Sameer Pradhan, Alessandro Moschitti, Nianwen Xue, Olga Uryupina, and Yuchen Zhang. 2012. Conll-2012 shared task: Modeling multilingual unrestricted coreference in ontonotes. In Joint Conference on EMNLP and CoNLL-Shared Task. Shen et al. (2018) Yikang Shen, Zhouhan Lin, Chin-Wei Huang, and Aaron Courville. 2018. Neural language modeling by jointly learning syntax and lexicon. In International Conference on Learning Representations (ICLR). Shen et al. (2019) Yikang Shen, Shawn Tan, Alessandro Sordoni, and Aaron Courville. 2019. Ordered neurons: Integrating tree structures into recurrent neural networks. In International Conference on Learning Representations (ICLR). Socher et al. (2011a) Richard Socher, Eric H Huang, Jeffrey Pennin, Christopher D Manning, and Andrew Y Ng. 2011a. Dynamic pooling and unfolding recursive autoencoders for paraphrase detection.",
    "0053f75b7053f43b9787a9955426281e672b147b-18": "In Advances in Neural Information Processing Systems (NeurIPS). Socher et al. (2011b) Richard Socher, Jeffrey Pennington, Eric H Huang, Andrew Y Ng, and Christopher D Manning. 2011b. Semi-supervised recursive autoencoders for predicting sentiment distributions. In Empirical Methods in Natural Language Processing (EMNLP). Spitkovsky et al. (2013) Valentin I Spitkovsky, Hiyan Alshawi, and Daniel Jurafsky. 2013. Breaking out of local optima with count transforms and model recombination: A study in grammar induction. In Empirical Methods in Natural Language Processing (EMNLP). Sutton and McCallum (2005) Charles Sutton and Andrew McCallum. 2005. Joint parsing and semantic role labeling. In Conference on Computational Natural Language Learning (CoNLL). Tai et al. (2015) Kai Sheng Tai, Richard Socher, and Christopher D. Manning. 2015. Improved semantic representations from tree-structured long short-term memory networks. In Association for Computational Linguistics (ACL). Team (2018) Pytorch Core Team. 2018. Pytorch: Tensors and dynamic neural networks in python with strong gpu acceleration. http://pytorch.org/. Accessed: 2018-09-26. Tjong Kim Sang and Buchholz (2000) Erik F Tjong Kim Sang and Sabine Buchholz. 2000. Introduction to the conll-2000 shared task: Chunking. In Proceedings of CoNLL-2000 and LLL-2000, pages 127\u2013132. Williams et al. (2018a) Adina Williams, Andrew Drozdov, and Samuel R Bowman. 2018a. Do latent tree learning models identify meaningful structure in sentences? Transactions of the Association of Computational Linguistics (TACL), 6:253\u2013267. Williams et al. (2018b) Adina Williams, Nikita Nangia, and Samuel Bowman. 2018b. A broad-coverage challenge corpus for sentence understanding through inference. In North American Association for Computational Linguistics (NAACL). Yogatama et al. (2017) Dani Yogatama, Phil Blunsom, Chris Dyer, Edward Grefenstette, and Wang Ling. 2017. Learning to compose words into sentences with reinforcement learning. In International Conference on Learning Representations (ICLR). Younger (1967) Daniel H Younger. 1967. Recognition and parsing of context-free languages in time n3. Information and control, 10(2):189\u2013208. Zaremoodi and Haffari (2018) Poorya Zaremoodi and Gholamreza Haffari. 2018. Incorporating syntactic uncertainty in neural machine translation with a forest-to-sequence model. In International Conference on Computational Linguistics. Appendix A Appendices\n\nA.1 Composition and Input Transform\n\nTreeLSTM. The (Tai et al., 2015) function produces a hidden state vector and cell state vector given two input vectors and . [ x f i f j o u ] matrix \ud835\udc65 subscript \ud835\udc53 \ud835\udc56 subscript \ud835\udc53 \ud835\udc57 \ud835\udc5c \ud835\udc62 \\displaystyle\\begin{bmatrix}x\\\\\nf_{i}\\\\\nf_{j}\\\\\no\\\\\nu\\end{bmatrix} = [ \u03c3 \u03c3 \u03c3 \u03c3 tanh ] \u200b ( U \u200b [ h i h j ] + b + [ 0 \u03c9 \u03c9 0 0 ] ) absent matrix \ud835\udf0e \ud835\udf0e \ud835\udf0e \ud835\udf0e \ud835\udc48 matrix subscript \u210e \ud835\udc56 subscript \u210e \ud835\udc57 \ud835\udc4f matrix 0 \ud835\udf14 \ud835\udf14 0 0 \\displaystyle=\\begin{bmatrix}\\sigma\\\\\n\\sigma\\\\\n\\sigma\\\\\n\\sigma\\\\\n\\tanh\\end{bmatrix}\\Bigg{(}U\\begin{bmatrix}h_{i}\\\\\nh_{j}\\end{bmatrix}+b+\\begin{bmatrix}0\\\\\n\\omega\\\\\n\\omega\\\\\n0\\\\\n0\\end{bmatrix}\\Bigg{)} c \ud835\udc50 \\displaystyle c = c i \u2299 f i + c j \u2299 f j + x \u2299 u absent direct-product subscript \ud835\udc50 \ud835\udc56 subscript \ud835\udc53 \ud835\udc56 direct-product subscript \ud835\udc50 \ud835\udc57 subscript \ud835\udc53 \ud835\udc57 direct-product \ud835\udc65 \ud835\udc62 \\displaystyle=c_{i}\\odot f_{i}+c_{j}\\odot f_{j}+x\\odot u h \u210e \\displaystyle h = o + tanh \u2061 ( c ) absent \ud835\udc5c \ud835\udc50 \\displaystyle=o+\\tanh(c)\n\nThe constant is set to for the inside, for the outside. and are learned. MLP. MLP (Multi-Layer Perceptron) is a deep non-linear composition with the following form:\n\nh \u210e \\displaystyle h = W 1 \u200b ( W 0 \u200b \u27e8 h i , h j \u27e9 + b ) + b 1 absent subscript \ud835\udc4a 1 subscript \ud835\udc4a 0 subscript \u210e \ud835\udc56 subscript \u210e \ud835\udc57 \ud835\udc4f subscript \ud835\udc4f 1 \\displaystyle=W_{1}~{}(W_{0}~{}\\langle h_{i},h_{j}\\rangle+b)+b_{1}\n\nThe operator is a concatenation .",
    "0053f75b7053f43b9787a9955426281e672b147b-19": "For the MLPKernel is more involved to support further interaction between the two input vectors .",
    "0053f75b7053f43b9787a9955426281e672b147b-20": "The variables are learned and is unused. A.2 Training Details\n\nTraining Data. Sentences of length from the SNLI and MultiNLI training sets. Optimization. We train our model using stochastic gradient descent with the Adam optimization algorithm (Kingma and Ba, 2014). Cells were normalized to have magnitude of 1, following Socher et al.",
    "0053f75b7053f43b9787a9955426281e672b147b-21": "(2011a). For instance, . Gradients are clipped to a maximum L2-norm of 5. Hyperparameters. Chosen using grid search over cell-dimension and learning rate . Early Stopping. Using unlabeled parsing F1 against the binarized WSJ validation set. Vocabulary. The model is trained in an open-vocabulary setting using pre-trained context-insensitive character embeddings from ELMo (Peters et al., 2018a). Batching. Batches were constructed such that they contained sentences of uniform length. Using batch size 128 for 400D and 64 for 800D.",
    "0053f75b7053f43b9787a9955426281e672b147b-22": "Sampling. negatives are sampled for each batch. All experiments use . Training Steps. 1M parameter updates, taking 3 days using 4x Nvidia 1080ti. A.3 Runtime Complexity\n\nThe runtime complexities for DIORA\u2019s methods are shown in Table 7. The parallel column represents the complexity when the values for all constituent pairs are computed simultaneously, assuming that these computations are independent and do not depend on values that have yet to be computed. Linear complexity is theoretically feasible depending on batch size, input length, and number of computational cores. In practice, one might experience super-linear performance. Although both the inside pass and outside pass have an upper bound of operations, the outside pass will have more operations than the inside pass for sentences of length . As a point of reference, our implementation computes the loss over the entire WSJ corpus in 5 minutes 30 seconds at a rate of 3,500 words per second using a single GPU. A.4 Reproducing Parsing Results\n\nIn Table 8, we\u2019ve organized a reference for creating various splits of the WSJ for the purpose of evaluating unsupervised parsing. Some splits use only the test set (section 23), others use all of the training, validation, and test data. Optionally, punctuation is stripped and sentences greater than a specified length are ignored. Predictions can be compared to the full parse trees in the annotated data, or to a binarized version. The PARSEVAL specification calculated bracketing F1 considering all spans, although some previous work diverts from PARSEVAL and ignores spans that are trivially correct (ones over the entire sentence). A.5 Parse Trees\n\nExamples of parse trees derived from the compatibility scores are shown in Figures 6, 7, and 8.",
    "0053f75b7053f43b9787a9955426281e672b147b-23": "Some punctuation has been removed for easier readability. \u25c4 Feeling lucky? Conversion report Report an issue View original on arXiv\u25ba\n\nCopyright Privacy Policy\n\nGenerated on Thu Mar 7 11:46:30 2024 by LaTeXML"
}