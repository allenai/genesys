{
    "yarn-0": "YaRN: Efficient Context Window Extension of Large Language Models\n\nBowen Peng1 &Jeffrey Quesnelle1 &Honglu Fan23 &Enrico Shippole Reddit: /u/bloc97 GitHub: bloc97Reddit: /u/emozilla X: @theemozilla GitHub: jquesnelleX: @EnricoShippole GitHub: conceptofmind\n\n( 1Nous Research and 2EleutherAI and 3University of Geneva )\n\nAbstract\n\nRotary Position Embeddings (RoPE) have been shown to effectively encode positional information in transformer-based language models.",
    "yarn-1": "However, these models fail to generalize past the sequence length they were trained on. We present YaRN (Yet another RoPE extensioN method), a compute-efficient method to extend the context window of such models, requiring 10x less tokens and 2.5x less training steps than previous methods. Using YaRN, we show that LLaMA models can effectively utilize and extrapolate to context lengths much longer than their original pre-training would allow, while also surpassing previous the state-of-the-art at context window extension. In addition, we demonstrate that YaRN exhibits the capability to extrapolate beyond the limited context of a fine-tuning dataset. The models fine-tuned using YaRN has been made available and reproduced online up to 128k context length at https://github.com/jquesnelle/yarn. 1 Introduction\n\nTransformer-based Large Language Models[40] (LLMs) have become the near-ubiquitous choice for many natural language processing (NLP) tasks where long-range abilities such as in-context learning (ICL) has been crucial. In performing the NLP tasks, the maximal length of the sequences (the context window) determined by its training processes has been one of the major limits of a pretrained LLM. Being able to dynamically extend the context window via a small amount of fine-tuning (or without fine-tuning) has become more and more desirable. To this end, the position encodings of transformers are the center of the discussions. The original Transformer architecture used an absolute sinusoidal position encoding, which was later improved to a learnable absolute position encoding [15]. Since then, relative positional encoding schemes [32] have further increased the performance of Transformers. Currently, the most popular relative positional encodings are T5 Relative Bias [30], RoPE [34], XPos [35], and ALiBi [27]. One reoccurring limitation with positional encodings is the inability to generalize past the context window seen during training. While some methods such as ALiBi are able to do limited generalization, none are able to generalize to sequences significantly longer than their pre-trained length [22]. Some works have been done to overcome such limitation. [9] and concurrently [21] proposed to extend the context length by slightly modifying RoPE via Position Interpolation (PI) and fine-tuning on a small amount of data. As an alternative, [6] proposed the \"NTK-aware\" interpolation by taking the loss of high frequency into account. Since then, two improvements of the \"NTK-aware\" interpolation have been proposed, with different emphasis:\n\n\u2022\n\nthe \"Dynamic NTK\" interpolation method [14] for pre-trained models without fine-tuning. \u2022\n\nthe \"NTK-by-parts\" interpolation method [7] which performs the best when fine-tuned on a small amount of longer-context data. The \"NTK-aware\" interpolation and the \"Dynamic NTK\" interpolation have already seen their presence in the open-source models such as Code Llama [31] (using \"NTK-aware\" interpolation) and Qwen 7B [2] (using \"Dynamic NTK\"). In this paper, in addition to making a complete account of the previous unpublished works on the \"NTK-aware\", the \"Dynamic NTK\" and the \"NTK-by-part\" interpolations, we present YaRN (Yet another RoPE extensioN method), an improved method to efficiently extend the context window of models trained with Rotary Position Embeddings (RoPE) including the LLaMA [38], the GPT-NeoX [5], and the PaLM [10] families of models. YaRN reaches state-of-the-art performances in context window extensions after fine-tuning on less than 0.1% of the original pre-training data. In the meantime, by combining with the inference-time technique called Dynamic Scaling, the Dynamic-YaRN allows for more than 2x context window extension without any fine-tuning. 2 Background and Related Work\n\n2.1 Rotary Position Embeddings\n\nThe basis of our work is the Rotary Position Embedding (RoPE) introduced in [34].",
    "yarn-2": "We work on a hidden layer where the set of hidden neurons are denoted by . Given a sequence of vectors , following the notation of [34], the attention layer first converts the vectors into the query vectors and the key vectors:\n\n\ud835\udc2a m = f q \u200b ( \ud835\udc31 m , m ) \u2208 \u211d | D | , \ud835\udc24 n = f k \u200b ( \ud835\udc31 n , n ) \u2208 \u211d | D | . formulae-sequence subscript \ud835\udc2a \ud835\udc5a subscript \ud835\udc53 \ud835\udc5e subscript \ud835\udc31 \ud835\udc5a \ud835\udc5a superscript \u211d \ud835\udc37 subscript \ud835\udc24 \ud835\udc5b subscript \ud835\udc53 \ud835\udc58 subscript \ud835\udc31 \ud835\udc5b \ud835\udc5b superscript \u211d \ud835\udc37 \\displaystyle\\mathbf{q}_{m}=f_{q}(\\mathbf{x}_{m},m)\\in\\mathbb{R}^{|D|},~{}\\mathbf{k}_{n}=f_{k}(\\mathbf{x}_{n},n)\\in\\mathbb{R}^{|D|}. (1)\n\nNext, the attention weights are calculated as\n\nsoftmax \u200b ( \ud835\udc2a m T \u200b \ud835\udc24 n | D | ) , softmax superscript subscript \ud835\udc2a \ud835\udc5a \ud835\udc47 subscript \ud835\udc24 \ud835\udc5b \ud835\udc37 \\text{softmax}(\\dfrac{\\mathbf{q}_{m}^{T}\\mathbf{k}_{n}}{\\sqrt{|D|}}), (2)\n\nwhere are considered as column vectors so that is simply the Euclidean inner product. In RoPE, we first assume that is even and identify the embedding space and the hidden states as complex vector spaces:\n\n\u211d | D | \u2245 \u2102 | D | / 2 superscript \u211d \ud835\udc37 superscript \u2102 \ud835\udc37 2 \\mathbb{R}^{|D|}\\cong\\mathbb{C}^{|D|/2}\n\nwhere the inner product becomes the real part of the standard Hermitian inner product .",
    "yarn-3": "More specifically, the isomorphisms interleave the real part and the complex part\n\n( ( \ud835\udc31 m ) 1 , \u22ef , ( \ud835\udc31 m ) | D | ) \u21a6 ( ( \ud835\udc31 m ) 1 + i \u200b ( \ud835\udc31 m ) 2 , \u22ef , ( ( \ud835\udc31 m ) | D | \u2212 1 + i \u200b ( \ud835\udc31 m ) | D | ) ) , maps-to subscript subscript \ud835\udc31 \ud835\udc5a 1 \u22ef subscript subscript \ud835\udc31 \ud835\udc5a \ud835\udc37 subscript subscript \ud835\udc31 \ud835\udc5a 1 \ud835\udc56 subscript subscript \ud835\udc31 \ud835\udc5a 2 \u22ef subscript subscript \ud835\udc31 \ud835\udc5a \ud835\udc37 1 \ud835\udc56 subscript subscript \ud835\udc31 \ud835\udc5a \ud835\udc37 \\displaystyle\\big{(}(\\mathbf{x}_{m})_{1},\\cdots,(\\mathbf{x}_{m})_{|D|}\\big{)}\\mapsto\\big{(}(\\mathbf{x}_{m})_{1}+i(\\mathbf{x}_{m})_{2},\\cdots,((\\mathbf{x}_{m})_{|D|-1}+i(\\mathbf{x}_{m})_{|D|})\\big{)}, (3) ( ( q m ) 1 , \u22ef , ( q m ) | D | ) \u21a6 ( ( q m ) 1 + i \u200b ( q m ) 2 , \u22ef , ( ( q m ) | D | \u2212 1 + i \u200b ( q m ) | D | ) ) . maps-to subscript subscript q \ud835\udc5a 1 \u22ef subscript subscript q \ud835\udc5a \ud835\udc37 subscript subscript q \ud835\udc5a 1 \ud835\udc56 subscript subscript q \ud835\udc5a 2 \u22ef subscript subscript q \ud835\udc5a \ud835\udc37 1 \ud835\udc56 subscript subscript q \ud835\udc5a \ud835\udc37 \\displaystyle\\big{(}(\\textbf{q}_{m})_{1},\\cdots,(\\textbf{q}_{m})_{|D|}\\big{)}\\mapsto\\big{(}(\\textbf{q}_{m})_{1}+i(\\textbf{q}_{m})_{2},\\cdots,((\\textbf{q}_{m})_{|D|-1}+i(\\textbf{q}_{m})_{|D|})\\big{)}. (4)\n\nTo convert embeddings into query and key vectors, we are first given -linear operators\n\n\ud835\udc16 q , \ud835\udc16 k : \u211d | D | \u2192 \u211d | D | . : subscript \ud835\udc16 \ud835\udc5e subscript \ud835\udc16 \ud835\udc58 \u2192 superscript \u211d \ud835\udc37 superscript \u211d \ud835\udc37 \\mathbf{W}_{q},\\mathbf{W}_{k}:\\mathbb{R}^{|D|}\\rightarrow\\mathbb{R}^{|D|}. In complex coordinates, the functions are given by\n\nf q \u200b ( \ud835\udc31 m , m ) = e i \u200b m \u200b \u03b8 \u200b \ud835\udc16 q \u200b \ud835\udc31 m , f k \u200b ( \ud835\udc31 n , n ) = e i \u200b n \u200b \u03b8 \u200b \ud835\udc16 k \u200b \ud835\udc31 n , formulae-sequence subscript \ud835\udc53 \ud835\udc5e subscript \ud835\udc31 \ud835\udc5a \ud835\udc5a superscript \ud835\udc52 \ud835\udc56 \ud835\udc5a \ud835\udf03 subscript \ud835\udc16 \ud835\udc5e subscript \ud835\udc31 \ud835\udc5a subscript \ud835\udc53 \ud835\udc58 subscript \ud835\udc31 \ud835\udc5b \ud835\udc5b superscript \ud835\udc52 \ud835\udc56 \ud835\udc5b \ud835\udf03 subscript \ud835\udc16 \ud835\udc58 subscript \ud835\udc31 \ud835\udc5b \\displaystyle f_{q}(\\mathbf{x}_{m},m)=e^{im\\mathbb{\\theta}}\\mathbf{W}_{q}\\mathbf{x}_{m},~{}f_{k}(\\mathbf{x}_{n},n)=e^{in\\mathbb{\\theta}}\\mathbf{W}_{k}\\mathbf{x}_{n}, (5)\n\nwhere is the diagonal matrix with and . This way, RoPE associates each (complex-valued) hidden neuron with a separate frequency . The benefit of doing so is that the dot product between the query vector and the key vector only depends on the relative distance as follows\n\n\u27e8 f q \u200b ( \ud835\udc31 m , m ) , f k \u200b ( \ud835\udc31 n , n ) \u27e9 \u211d subscript subscript \ud835\udc53 \ud835\udc5e subscript \ud835\udc31 \ud835\udc5a \ud835\udc5a subscript \ud835\udc53 \ud835\udc58 subscript \ud835\udc31 \ud835\udc5b \ud835\udc5b \u211d \\displaystyle\\langle f_{q}(\\mathbf{x}_{m},m),f_{k}(\\mathbf{x}_{n},n)\\rangle_{\\mathbb{R}} (6) = \\displaystyle= Re \u200b ( \u27e8 f q \u200b ( \ud835\udc31 m , m ) , f k \u200b ( \ud835\udc31 n , n ) \u27e9 \u2102 ) Re subscript subscript \ud835\udc53 \ud835\udc5e subscript \ud835\udc31 \ud835\udc5a \ud835\udc5a subscript \ud835\udc53 \ud835\udc58 subscript \ud835\udc31 \ud835\udc5b \ud835\udc5b \u2102 \\displaystyle\\text{Re}(\\langle f_{q}(\\mathbf{x}_{m},m),f_{k}(\\mathbf{x}_{n},n)\\rangle_{\\mathbb{C}}) (7) = \\displaystyle= Re \u200b ( \ud835\udc31 m \u2217 \u200b \ud835\udc16 q \u2217 \u200b \ud835\udc16 k \u200b \ud835\udc31 n \u200b e i \u200b \u03b8 \u200b ( m \u2212 n ) ) Re superscript subscript \ud835\udc31 \ud835\udc5a superscript subscript \ud835\udc16 \ud835\udc5e subscript \ud835\udc16 \ud835\udc58 subscript \ud835\udc31 \ud835\udc5b superscript \ud835\udc52 \ud835\udc56 \ud835\udf03 \ud835\udc5a \ud835\udc5b \\displaystyle\\text{Re}(\\mathbf{x}_{m}^{*}\\mathbf{W}_{q}^{*}\\mathbf{W}_{k}\\mathbf{x}_{n}e^{i\\theta(m-n)}) (8) = \\displaystyle= g \u200b ( \ud835\udc31 m , \ud835\udc31 n , m \u2212 n ) . \ud835\udc54 subscript \ud835\udc31 \ud835\udc5a subscript \ud835\udc31 \ud835\udc5b \ud835\udc5a \ud835\udc5b \\displaystyle g(\\mathbf{x}_{m},\\mathbf{x}_{n},m-n). (9)\n\nIn real coordinates, the RoPE can be written using the following function\n\nf \ud835\udc16 \u200b ( \ud835\udc31 m , m , \u03b8 d ) = ( cos \u200b m \u200b \u03b8 1 \u2212 sin \u200b m \u200b \u03b8 1 0 0 \u22ef 0 0 sin \u200b m \u200b \u03b8 1 cos \u200b m \u200b \u03b8 1 0 0 \u22ef 0 0 0 0 cos \u200b m \u200b \u03b8 2 \u2212 sin \u200b m \u200b \u03b8 2 \u22ef 0 0 0 0 sin \u200b m \u200b \u03b8 2 cos \u200b m \u200b \u03b8 2 \u22ef 0 0 0 0 0 0 \u22ef cos \u200b m \u200b \u03b8 l \u2212 sin \u200b m \u200b \u03b8 l 0 0 0 0 \u22ef sin \u200b m \u200b \u03b8 l cos \u200b m \u200b \u03b8 l ) \u200b \ud835\udc16\ud835\udc31 m , subscript \ud835\udc53 \ud835\udc16 subscript \ud835\udc31 \ud835\udc5a \ud835\udc5a subscript \ud835\udf03 \ud835\udc51 matrix cos \ud835\udc5a subscript \ud835\udf03 1 sin \ud835\udc5a subscript \ud835\udf03 1 0 0 \u22ef 0 0 sin \ud835\udc5a subscript \ud835\udf03 1 cos \ud835\udc5a subscript \ud835\udf03 1 0 0 \u22ef 0 0 0 0 cos \ud835\udc5a subscript \ud835\udf03 2 sin \ud835\udc5a subscript \ud835\udf03 2 \u22ef 0 0 0 0 sin \ud835\udc5a subscript \ud835\udf03 2 cos \ud835\udc5a subscript \ud835\udf03 2 \u22ef 0 0 0 0 0 0 \u22ef cos \ud835\udc5a subscript \ud835\udf03 \ud835\udc59 sin \ud835\udc5a subscript \ud835\udf03 \ud835\udc59 0 0 0 0 \u22ef sin \ud835\udc5a subscript \ud835\udf03 \ud835\udc59 cos \ud835\udc5a subscript \ud835\udf03 \ud835\udc59 subscript \ud835\udc16\ud835\udc31 \ud835\udc5a f_{\\mathbf{W}}(\\mathbf{x}_{m},m,\\theta_{d})=\\begin{pmatrix}\\text{cos}m\\theta_{1}&-\\text{sin}m\\theta_{1}&0&0&\\cdots&0&0\\\\\n\\text{sin}m\\theta_{1}&\\text{cos}m\\theta_{1}&0&0&\\cdots&0&0\\\\\n0&0&\\text{cos}m\\theta_{2}&-\\text{sin}m\\theta_{2}&\\cdots&0&0\\\\\n0&0&\\text{sin}m\\theta_{2}&\\text{cos}m\\theta_{2}&\\cdots&0&0\\\\\n0&0&0&0&\\cdots&\\text{cos}m\\theta_{l}&-\\text{sin}m\\theta_{l}\\\\\n0&0&0&0&\\cdots&\\text{sin}m\\theta_{l}&\\text{cos}m\\theta_{l}\\\\\n\\end{pmatrix}\\mathbf{W}\\mathbf{x}_{m},\n\nso that\n\nf q = f \ud835\udc16 q , f k = f \ud835\udc16 k . formulae-sequence subscript \ud835\udc53 \ud835\udc5e subscript \ud835\udc53 subscript \ud835\udc16 \ud835\udc5e subscript \ud835\udc53 \ud835\udc58 subscript \ud835\udc53 subscript \ud835\udc16 \ud835\udc58 f_{q}=f_{\\mathbf{W}_{q}},~{}f_{k}=f_{\\mathbf{W}_{k}}. 2.2 Position Interpolation\n\nAs language models are usually pre-trained with a fixed context length, it is natural to ask how to extend the context length by fine-tuning on relatively less amount of data. For language models using RoPE as the position embedding, Chen et al. [9], and concurrently kaiokendev [21] proposed the Position Interpolation (PI) to extend the context length beyond the pre-trained limit. While a direct extrapolation does not perform well on sequences with larger than the pre-trained limit, they discovered that interpolating the position indicies within the pre-trained limit works well with the help of a small amount of fine-tuning. Specifically, given a pre-trained language model with RoPE, they modify the RoPE by\n\nf \ud835\udc16 \u2032 \u200b ( \ud835\udc31 m , m , \u03b8 d ) = f \ud835\udc16 \u200b ( \ud835\udc31 m , m \u200b L L \u2032 , \u03b8 d ) , subscript superscript \ud835\udc53 \u2032 \ud835\udc16 subscript \ud835\udc31 \ud835\udc5a \ud835\udc5a subscript \ud835\udf03 \ud835\udc51 subscript \ud835\udc53 \ud835\udc16 subscript \ud835\udc31 \ud835\udc5a \ud835\udc5a \ud835\udc3f superscript \ud835\udc3f \u2032 subscript \ud835\udf03 \ud835\udc51 \\displaystyle f^{\\prime}_{\\mathbf{W}}\\left(\\mathbf{x}_{m},m,\\theta_{d}\\right)=f_{\\mathbf{W}}\\left(\\mathbf{x}_{m},\\dfrac{mL}{L^{\\prime}},\\theta_{d}\\right), (10)\n\nwhere is a new context window beyond the pre-trained limit. With the original pre-trained model plus the modified RoPE formula, they fine-tuned the language model further on several orders of magnitude fewer tokens (a few billion in Chen et al. [9]) and successfully acheived context window extension. 2.3 Additional Notation\n\nThe ratio between the extended context length and the original context length has been of special importance, and we introduce the notation defined by\n\ns = L \u2032 L , \ud835\udc60 superscript \ud835\udc3f \u2032 \ud835\udc3f s=\\frac{L^{\\prime}}{L}, (11)\n\nand we call the scale factor. We also rewrite and simplify Eq. 10 into the following general form:\n\nf \ud835\udc16 \u2032 \u200b ( \ud835\udc31 m , m , \u03b8 d ) = f \ud835\udc16 \u200b ( \ud835\udc31 m , g \u200b ( m ) , h \u200b ( \u03b8 d ) ) , subscript superscript \ud835\udc53 \u2032 \ud835\udc16 subscript \ud835\udc31 \ud835\udc5a \ud835\udc5a subscript \ud835\udf03 \ud835\udc51 subscript \ud835\udc53 \ud835\udc16 subscript \ud835\udc31 \ud835\udc5a \ud835\udc54 \ud835\udc5a \u210e subscript \ud835\udf03 \ud835\udc51 \\displaystyle f^{\\prime}_{\\mathbf{W}}(\\mathbf{x}_{m},m,\\theta_{d})=f_{\\mathbf{W}}(\\mathbf{x}_{m},g(m),h(\\theta_{d})), (12)\n\nwhere are method-dependent functions. For PI, we have In the subsequent sections, when we introduce a new interpolation method, we sometimes only specify the functions and . Additionally, we define as the wavelength of the RoPE embedding at -th hidden dimension:\n\n\u03bb d = 2 \u200b \u03c0 \u03b8 d = 2 \u200b \u03c0 \u200b b 2 \u200b d | D | . subscript \ud835\udf06 \ud835\udc51 2 \ud835\udf0b subscript \ud835\udf03 \ud835\udc51 2 \ud835\udf0b superscript \ud835\udc4f 2 \ud835\udc51 \ud835\udc37 \\displaystyle\\lambda_{d}=\\dfrac{2\\pi}{\\theta_{d}}=2\\pi b^{\\frac{2d}{|D|}}. (13)\n\nThe wavelength describes the length of tokens needed in order for the RoPE embedding at dimension to perform a full rotation (). Given that some interpolation methods (eg. PI) do not care about the wavelength of the dimensions, we will refer to those methods as \"blind\" interpolation methods, while others do (eg. YaRN), which we will classify as \"targeted\" interpolation methods. 2.4 Related work\n\nReRoPE [33] also aims to extend the context size of existing models pre-trained with RoPE, and claims \"infinite\" context length without needing any fine-tuning. This claim is backed by a monotonically decreasing loss with increasing context length up to 16k on the Llama 2 13B model. It achieves context extension by modifying the attention mechanism and thus is not purely an embedding interpolation method. Since it is currently not compatible with Flash Attention 2 [13] and requires two attention passes during inference, we do not consider it for comparison. Concurrently with our work, LM-Infinite [16] proposes similar ideas to YaRN, but focuses on \"on-the-fly\" length generalization for non-fine-tuned models. Since they also modify the attention mechanism of the models, it is not an embedding interpolation method and is not immediately compatible with Flash Attention 2. 3 Methodology\n\nWhereas PI stretches all RoPE dimensions equally, we find that the theoretical interpolation bound described by PI [9] is insufficient at predicting the complex dynamics between RoPE and the LLM\u2019s internal embeddings. In the following subsections, we describe the main issues with PI we have individually identified and solved, so as to give the readers the context, origin and justifications of each method which we use in concert to obtain the full YaRN method. 3.1 Loss of High Frequency information - \"NTK-aware\" interpolation\n\nIf we look at RoPE only from an information encoding perspective, it was shown in [36], using Neural Tangent Kernel (NTK) theory, that deep neural networks have trouble learning high frequency information if the input dimension is low and the corresponding embeddings lack high frequency components. Here we can see the similarities: a token\u2019s positional information is one-dimensional, and RoPE expands it to an n-dimensional complex vector embedding. RoPE closely resembles Fourier Features [36] in many aspects, as it is possible to define RoPE as a special 1D case of a Fourier Feature. Stretching the RoPE embeddings indiscriminately results in the loss of important high frequency details which the network needs in order to resolve tokens that are both very similar and very close together (the rotation describing the smallest distance needs to not be too small for the network to be able to detect it). We hypothesise that the slight increase of perplexity for short context sizes after fine-tuning on larger context sizes seen in PI [9] might be related to this problem. Under ideal circumstances, there is no reason that fine-tuning on larger context sizes should degrade the performance of smaller context sizes. In order to resolve the problem of losing high frequency information when interpolating the RoPE embeddings, the \"NTK-aware\" interpolation was developed in [6]. Instead of scaling every dimension of RoPE equally by a factor , we spread out the interpolation pressure across multiple dimensions by scaling high frequencies less and low frequencies more. One can obtain such a transformation in many ways, but the simplest would be to perform a base change on the value of . More precisely, following the notations set out in Section 2.3, we define the \"NTK-aware\" interpolation scheme as follows (see the Appendix A.1 for the details of the deduction). Definition 1\n\nThe \"NTK-aware\" interpolation is a modification of RoPE by using Eq.",
    "yarn-4": "12 with the following functions. g \u200b ( m ) \ud835\udc54 \ud835\udc5a \\displaystyle g(m) = m absent \ud835\udc5a \\displaystyle=m (14) h \u200b ( \u03b8 d ) \u210e subscript \ud835\udf03 \ud835\udc51 \\displaystyle h(\\theta_{d}) = b \u2032 \u2212 2 \u200b d / | D | , absent superscript superscript \ud835\udc4f \u2032 2 \ud835\udc51 \ud835\udc37 \\displaystyle={b^{\\prime}}^{-2d/|D|}, (15)\n\nwhere\n\nb \u2032 = b \u22c5 s | D | | D | \u2212 2 . superscript \ud835\udc4f \u2032 \u22c5 \ud835\udc4f superscript \ud835\udc60 \ud835\udc37 \ud835\udc37 2 {b^{\\prime}}=b\\cdot s^{\\frac{|D|}{|D|-2}}. (16)\n\nGiven the results from [6], this method performs much better at extending the context size of non-fine-tuned models compared to PI [9]. However, one major disadvantage of this method is that given it is not just an interpolation scheme, some dimensions are slightly extrapolated to \"out-of-bound\" values, thus fine-tuning with \"NTK-aware\" interpolation [6] yields inferior results to PI [9]. Furthermore, due to the \"out-of-bound\" values, the theoretical scale factor does not accurately describe the true context extension scale. In practice, the scale value has to be set higher than the expected scale for a given context length extension. We note that shortly before the release of this article, Code Llama [31] was released and uses \"NTK-aware\" scaling by manually scaling the base to 1M. 3.2 Loss of Relative Local Distances - \"NTK-by-parts\" interpolation\n\nIn the case of blind interpolation methods like PI and \"NTK-aware\" interpolation, we treat all the RoPE hidden dimensions equally (as in they have the same effect on the network).",
    "yarn-5": "However, there are strong clues that point us towards the need for targeted interpolation methods. In this section, we think heavily in terms of the wavelengths defined in Eq. 13 in the formula of RoPE. For simplicity, we omit the subscript in and the reader is encouraged to think about as the wavelength of an arbitrary periodic function. One interesting observation of RoPE embeddings is that given a context size , there are some dimensions where the wavelength is longer than the maximum context length seen during pretraining (), this suggests that some dimensions\u2019 embeddings might not be distributed evenly in the rotational domain. In such cases, we presume having all unique position pairs implies that the absolute positional information remains intact. On the contrary, when the wavelength is short, only relative positional information is accessible to the network. Moreover, when we stretch all the RoPE dimensions either by a scale or using a base change , all tokens become closer to each other, as the dot product of two vectors rotated by a lesser amount is bigger. This scaling severely impairs a LLM\u2019s ability to understand small and local relationships between its internal embeddings. We hypothesize that such compression leads to the model being confused on the positional order of close-by tokens, and consequently harming the model\u2019s abilities. In order to remedy this issue, given the two previous observations that we have found, we choose not to interpolate the higher frequency dimensions at all while always interpolating the lower frequency dimensions. In particular,\n\n\u2022\n\nif the wavelength is much smaller than the context size , we do not interpolate;\n\n\u2022\n\nif the wavelength is equal to or bigger than the context size , we want to only interpolate and avoid any extrapolation (unlike the previous \"NTK-aware\" method);\n\n\u2022\n\ndimensions in-between can have a bit of both, similar to the \"NTK-aware\" interpolation. As a result, it is more convenient to introduce the ratio between the original context size and the wavelength . In the -th hidden state, the ratio depends on in the following way:\n\nr \u200b ( d ) = L \u03bb d = L 2 \u200b \u03c0 \u200b b \u2032 \u2063 2 \u200b d | D | . \ud835\udc5f \ud835\udc51 \ud835\udc3f subscript \ud835\udf06 \ud835\udc51 \ud835\udc3f 2 \ud835\udf0b superscript \ud835\udc4f \u2032 2 \ud835\udc51 \ud835\udc37 r(d)=\\dfrac{L}{\\lambda_{d}}=\\dfrac{L}{2\\pi b^{\\prime\\frac{2d}{|D|}}}. (17)\n\nIn order to define the boundary of the different interpolation strategies as above, we introduce two extra parameters . All hidden dimensions where are those where we linearly interpolate by a scale (exactly like PI, avoiding any extrapolation), and the where are those where we do not interpolate at all. Define the ramp function to be\n\n\u03b3 \u200b ( r ) = { 0 , if \u200b r < \u03b1 1 , if \u200b r > \u03b2 r \u2212 \u03b1 \u03b2 \u2212 \u03b1 , otherwise . \ud835\udefe \ud835\udc5f cases 0 if \ud835\udc5f \ud835\udefc 1 if \ud835\udc5f \ud835\udefd \ud835\udc5f \ud835\udefc \ud835\udefd \ud835\udefc otherwise \\displaystyle\\gamma(r)=\\begin{cases}0,&\\text{if }r<\\alpha\\\\\n1,&\\text{if }r>\\beta\\\\\n\\dfrac{r-\\alpha}{\\beta-\\alpha},&\\text{otherwise}.\\end{cases} (18)\n\nWith the help of the ramp function, the \"NTK-by-parts\" method can be described as follows. Definition 2\n\nThe \"NTK-by-parts\" interpolation is a modification of RoPE by using Eq.",
    "yarn-6": "12 with the following functions111The interpolation by linear ramp on may have alternatives, such as a harmonic mean over and converted from a linear interpolation on wavelengths. The choice of here was for the simplicity of implementation, but both would work.. g \u200b ( m ) \ud835\udc54 \ud835\udc5a \\displaystyle g(m) = m absent \ud835\udc5a \\displaystyle=m (19) h \u200b ( \u03b8 d ) \u210e subscript \ud835\udf03 \ud835\udc51 \\displaystyle h(\\theta_{d}) = ( 1 \u2212 \u03b3 \u200b ( r \u200b ( d ) ) ) \u200b \u03b8 d s + \u03b3 \u200b ( r \u200b ( d ) ) \u200b \u03b8 d . absent 1 \ud835\udefe \ud835\udc5f \ud835\udc51 subscript \ud835\udf03 \ud835\udc51 \ud835\udc60 \ud835\udefe \ud835\udc5f \ud835\udc51 subscript \ud835\udf03 \ud835\udc51 \\displaystyle=\\Big{(}1-\\gamma\\big{(}r(d)\\big{)}\\Big{)}\\frac{\\theta_{d}}{s}+\\gamma\\big{(}r(d)\\big{)}\\theta_{d}. (20)\n\nThe values of and should be tuned on a case-by-case basis. For example, we have found experimentally that for the Llama family of models, good values for and are and . Using the techniques described in this section, a variant of the resulting method was released under the name \"NTK-by-parts\" interpolation [7]. This improved method performs better than the previous PI [9] and \"NTK-aware\" 3.1 interpolation methods, both with non-fine-tuned models and with fine-tuned models, as shown in [7]. 3.3 Dynamic Scaling - \"Dynamic NTK\" interpolation\n\nIn a lot of use cases, multiple forward-passes are performed with varying sequence lengths from to the maximal context size. A typical example is the autoregressive generation where the sequence lengths increment by after each step. There are two ways of applying an interpolation method that uses a scale factor (including PI, \"NTK-aware\" and \"NTK-by-parts\"):\n\n1. Throughout the whole inference cycle, the embedding layer is fixed including the scale factor where is the fixed number of extended context size. 2. In each forward-pass, the position embedding updates the scale factor where is the sequence length of the current sequence. The problem of (1) is that the model may experience a performance discount at a length less than and an abrupt degradation when the sequence length is longer than . But by doing Dynamic Scaling as (2), it allows the model to gracefully degrade instead of immediately breaking when hitting the trained context limit . We call this inference-time method the Dynamic Scaling method. When it is combined with \"NTK-awared\" interpolation, we call it \"Dynamic NTK\" interpolation. It first appeared in public as a reddit post in [14]. One notable fact is that the \"Dynamic NTK\" interpolation works exceptionally well on models pretrained on without any finetuning (). This is supported by the experiment in Appendix B.3. Often in the repeated forward-passes, the kv-caching [8] is applied so that we can reuse the previous key-value vectors and improve the overall efficiency. We point out that in some implementations when the RoPE embeddings are cached, some care has to be taken in order to modify it for Dynamic Scaling with kv-caching. The correct implementation should cache the kv-embeddings before applying RoPE, as the RoPE embedding of every token changes when changes. 3.4 YaRN\n\nIn addition to the previous interpolation techniques, we also observe that introducing a temperature on the logits before the attention softmax has a uniform impact on perplexity regardless of the data sample and the token position over the extended context window (See Appendix A.2).",
    "yarn-7": "More precisely, instead of Eq. 2, we modify the computation of attention weights into\n\nsoftmax \u200b ( \ud835\udc2a m T \u200b \ud835\udc24 n t \u200b | D | ) . softmax superscript subscript \ud835\udc2a \ud835\udc5a \ud835\udc47 subscript \ud835\udc24 \ud835\udc5b \ud835\udc61 \ud835\udc37 \\text{softmax}\\left(\\dfrac{\\mathbf{q}_{m}^{T}\\mathbf{k}_{n}}{t\\sqrt{|D|}}\\right). (21)\n\nThe reparametrization of RoPE as a set of 2D matrices has a clear benefit on the implementation of this attention scaling: we can instead use a \"length scaling\" trick which scales both and by a constant factor by simply scaling the complex RoPE embeddings by the same amount. With this, YaRN can effectively alter the attention mechanism without modifying its code. Furthermore, it has zero overhead during both inference and training, as RoPE embeddings are generated in advance and are reused for all forward passes. Combining it with the \"NTK-by-parts\" interpolation, we have the YaRN method. Definition 3\n\nBy the \"YaRN method\", we refer to a combination of the attention scaling in Eq. 21 and the \"NTK-by-parts\" interpolation introduced in Section 3.2. For LLaMA and Llama 2 models, we recommend the following values:\n\n1 t = 0.1 \u200b ln \u2061 ( s ) + 1 . 1 \ud835\udc61 0.1 \ud835\udc60 1 \\displaystyle\\sqrt{\\frac{1}{t}}=0.1\\ln({s})+1. (22)\n\nThe equation above is found by fitting at the lowest perplexity against the scale extension by various factors using the \"NTK-by-parts\" method (Section 3.2) on LLaMA 7b, 13b, 33b and 65b models without fine-tuning. We note that the same values of also apply fairly well to Llama 2 models (7b, 13b and 70b). It suggests that the property of increased entropy and the temperature constant may have certain degree of \"universality\" and may be generalizable across some models and training data. The YaRN method combines all our findings and surpasses all previous methods in both fine-tuned and non-fine-tuned scenarios. Thanks to its low footprint, YaRN allows for direct compatibility with libraries that modify the attention mechanism such as Flash Attention 2 [13]. 4 Experiments\n\nWe show that YaRN successfully achieves context window extension of language models using RoPE as its position embedding.",
    "yarn-8": "Moreover, this result is achieved with only 400 training steps, representing approximately 0.1% of the model\u2019s original pre-training corpus, a 10x reduction from Rozi\u00e8re et al. [31] and 2.5x reduction in training steps from Chen et al. [9], making it highly compute-efficient for training with no additional inference costs. We calculate the perplexity of long documents and score on established benchmarks to evaluate the resulting models, finding that they surpass all other context window extension methods. We broadly followed the training and evaluation procedures as outlined in [9]. 4.1 Training\n\nFor training, we extended the Llama 2 [39] 7B and 13B parameter models. No changes were made to the LLaMA model architecture other than the calculation of the embedding frequencies as described in 3.4 with and . We used a learning rate of with no weight decay and a linear warmup of 20 steps along with AdamW [24] and . For we fine-tuned for 400 steps with global batch size using PyTorch [26] Fully Sharded Data Parallelism [42] and Flash Attention 2 [13] on the PG19 dataset [29] chunked into 64k segments bookended with the BOS and EOS token. For we followed the same procedure, but started from the finished checkpoint and trained for an additional 200 steps. 4.2 Extrapolation and Transfer Learning\n\nIn Code Llama [31], a dataset with 16k context was used with a scale factor set to , which corresponds to a context size of 355k. They show that the network extrapolates up to 100k context without ever seeing those context sizes during training. Similar to 3.1 and Rozi\u00e8re et al. [31], YaRN also supports training with a higher scale factor than the length of the dataset. Due to compute constraints, we test only by further fine-tuning the model for 200 steps using the same dataset with 64k context. We show in 4.3.1 that the model successfully extrapolates up to 128k context using only 64k context during training. Unlike previous \"blind\" interpolation methods, YaRN is much more efficient at transfer learning when increasing the scale . This demonstrates successful transfer learning from to without the network needing to relearn the interpolated embeddings, as the model is equivalent to the model across the entire context size, despite only being trained on for 200 steps. 4.3 Evaluation\n\nThe evaluations focus on three aspects:\n\n1. the perplexity scores of fine-tuned models with extended context window,\n\n2. the passkey retrieval task on fine-tuned models,\n\n3. the common LLM benchmark results of fine-tuned models,\n\n4.3.1 Long Sequence Language Modeling\n\nTo evaluate the long sequence language modeling performances, we use the GovReport [18] and Proof-pile [4] datasets both of which contain many long sequence samples.",
    "yarn-9": "For all evaluations, the test splits of both datasets were used exclusively. All perplexity evaluations were calculated using the sliding window method from Press et al. [27] with . Firstly, we evaluated how the model performed as the context window increased. We selected 10 random samples from Proof-pile with at least 128k tokens each and evaluated the perplexity of each of these samples when truncated at 2k steps from a sequence length of 2k tokens through 128k tokens. Table 1 shows a side-by-side comparison of Llama-2 model extended from to context length via PI (LLongMA-2 7b222LLongMA-2 7b [28] is fine-tuned from Llama-2 7b, trained at 8k context length with PI using the RedPajama dataset [12]. ), \"NTK-aware\" and YaRN. Note that PI and \"NTK-aware\" models were trained using the methodology in Chen et al. [9], while YaRN used the same methodology but 2.5x less training steps and data, as described in 4. We further evaluated YaRN at the scale factor and compared them against a few open-source models fine-tuned from Llama-2 and extended to more than 32k context window such as Together.ai [37] and \"NTK-aware\" Code Llama [31]. The results are summarized in Table 2 (with a more detailed plot in Figure 1). We observe that the model exhibits strong performance across the entire targeted context size, with YaRN interpolation being the first method to successfully extend the effective context size of Llama 2 to 128k. Of particular note are the YaRN () models, which show continued declining perplexity through 128k, despite the fine-tuning data being limited to 64k tokens in length, demonstrating that the model is able to generalize to unseen context lengths. Furthermore, in Appendix B.1, we show the results of the average perplexity on 50 untruncated GovReport documents with at least 16k tokens per sample evaluated on the setting of 32k maximal context window without Dynamic Scaling in Table 4. Similar to the Proof-pile results, the GovReport results show that fine-tuning with YaRN achieves good performance on long sequences. 4.3.2 Passkey Retrieval\n\nThe passkey retrieval task as defined in [25] measures a model\u2019s ability to retrieve a simple passkey (i.e., a five-digit number) from amongst a large amount of otherwise meaningless text. For our evaluation of the models, we performed 10 iterations of the passkey retrieval task with the passkey placed at a random location uniformly distributed across the evaluation context window on different context window sizes ranging from 8k to 128k. Both 7b and 13b models fine-tuned using YaRN at 128k context size passes the passkey retrieval task with very high accuracy () within the entire context window size. We show detailed results in Appendix B.2. 4.3.3 Standardized Benchmarks\n\nThe Hugging Face Open LLM Leaderboard [19] compares a multitude of LLMs across a standardized set of four public benchmarks. Specifically, we use 25-shot ARC-Challenge [11], 10-shot HellaSwag [41], 5-shot MMLU [17], and 0-shot TruthfulQA [23]. To test the degradation of model performance under context extension, we evaluated our models using this suite and compared it to established scores for the Llama 2 baselines as well as publicly available PI and \"NTK-aware\" models. The results are summarized in Table 3. We observe that there is minimal performance degradation between the YaRN models and their respective Llama 2 baselines. We also observe that there was on average a 0.49% drop in scores between the YaRN and models. From this we conclude that the the iterative extension from 64k to 128k results in negligible performance loss. 5 Conclusion\n\nIn conclusion, we have shown that YaRN improves upon all existing RoPE interpolation methods and can act as a drop-in replacement to PI, with no downsides and minimal implementation effort. The fine-tuned models preserve their original abilities on multiple benchmarks while being able to attend to a very large context size. Furthermore, YaRN allows efficient extrapolation with fine-tuning on shorter datasets and can take advantage of transfer learning for faster convergence, both of which are crucial under compute-constrained scenarios. Finally, we have shown the effectiveness of extrapolation with YaRN where it is able to \"train short, and test long\". 6 Reproducibility\n\nTo aid in reproducibility, we provide, as supplementary material, the entirety of of the code used to train the YaRN models in Table 2, as well as the evaluation code that produced Figure 1 and Tables 1, 2, 3, 4, and 5. The code also contains implementations of various extension methods referenced throughout the paper. For training YaRN, we used the publicly available PG19 dataset [29] tokenized to 64k tokens. References\n\n[1] Mistrallite. URL https://huggingface.co/amazon/MistralLite. [2] Introducing Qwen-7B: Open foundation and human-aligned models (of the state-of-the-arts). URL https://github.com/QwenLM/Qwen-7B/blob/main/tech_memo.md. [3] Long-data collections. URL https://huggingface.co/datasets/togethercomputer/Long-Data-Collections. Azerbayev et al. [2022] Z. Azerbayev, E. Ayers, , and B. Piotrowski. Proof-pile, 2022. URL https://github.com/zhangir-azerbayev/proof-pile.",
    "yarn-10": "Black et al. [2022] S. Black, S. Biderman, E. Hallahan, Q. Anthony, L. Gao, L. Golding, H. He, C. Leahy, K. McDonell, J. Phang, M. Pieler, U. S. Prashanth, S. Purohit, L. Reynolds, J. Tow, B.",
    "yarn-11": "Wang, and S. Weinbach. GPT-NeoX-20B: An open-source autoregressive language model, 2022. arXiv: 2204.06745. bloc97 [2023a] bloc97. NTK-Aware Scaled RoPE allows LLaMA models to have extended (8k+) context size without any fine-tuning and minimal perplexity degradation., 2023a. URL https://www.reddit.com/r/LocalLLaMA/comments/14lz7j5/ntkaware_scaled_rope_allows_llama_models_to_have/. bloc97 [2023b] bloc97. Add NTK-Aware interpolation \"by parts\" correction, 2023b. URL https://github.com/jquesnelle/scaled-rope/pull/1.",
    "yarn-12": "Chen [2022] C. Chen. Transformer Inference Arithmetic, 2022. URL https://kipp.ly/blog/transformer-inference-arithmetic/.",
    "yarn-13": "Chen et al. [2023] S. Chen, S. Wong, L. Chen, and Y. Tian. Extending context window of large language models via positional interpolation, 2023.",
    "yarn-14": "arXiv: 2306.15595. Chowdhery et al. [2022] A. Chowdhery, S. Narang, J. Devlin, M. Bosma, G. Mishra, A. Roberts, P. Barham, H. W. Chung, C. Sutton, S. Gehrmann, P. Schuh, K. Shi, S. Tsvyashchenko, J. Maynez, A. Rao, P. Barnes, Y. Tay, N. Shazeer, V. Prabhakaran, E. Reif, N. Du, B. Hutchinson, R. Pope, J. Bradbury, J. Austin, M. Isard, G. Gur-Ari, P. Yin, T. Duke, A. Levskaya, S. Ghemawat, S. Dev, H. Michalewski, X. Garcia, V. Misra, K. Robinson, L. Fedus, D. Zhou, D. Ippolito, D. Luan, H. Lim, B. Zoph, A. Spiridonov, R. Sepassi, D. Dohan, S. Agrawal, M. Omernick, A. M. Dai, T. S. Pillai, M. Pellat, A. Lewkowycz, E. Moreira, R. Child, O. Polozov, K. Lee, Z. Zhou, X. Wang, B. Saeta, M. Diaz, O. Firat, M. Catasta, J. Wei, K. Meier-Hellstern, D. Eck, J. Dean, S. Petrov, and N. Fiedel. PaLM: Scaling language modeling with pathways, 2022.",
    "yarn-15": "arXiv: 2204.02311. Clark et al. [2018] P. Clark, I. Cowhey, O. Etzioni, T. Khot, A. Sabharwal, C. Schoenick, and O. Tafjord. Think you have solved question answering? try ARC, the AI2 Reasoning Challenge, 2018. arXiv: 1803.05457. Computer [2023] T. Computer. Redpajama: An open source recipe to reproduce llama training dataset, 2023. URL https://github.com/togethercomputer/RedPajama-Data.",
    "yarn-16": "Dao [2023] T. Dao. Flashattention-2: Faster attention with better parallelism and work partitioning, 2023.",
    "yarn-17": "arXiv: 2307.08691. emozilla [2023] emozilla. Dynamically Scaled RoPE further increases performance of long context LLaMA with zero fine-tuning, 2023. URL https://www.reddit.com/r/LocalLLaMA/comments/14mrgpr/dynamically_scaled_rope_further_increases/.",
    "yarn-18": "Gehring et al. [2017] J. Gehring, M. Auli, D. Grangier, D. Yarats, and Y.",
    "yarn-19": "N. Dauphin. Convolutional sequence to sequence learning, 2017. arXiv: 1705.03122. Han et al. [2023] C. Han, Q. Wang, W. Xiong, Y. Chen, H. Ji, and S. Wang. LM-Infinite: Simple on-the-fly length generalization for large language models, 2023.",
    "yarn-20": "arXiv: 2308.16137. Hendrycks et al. [2021] D. Hendrycks, C. Burns, S. Basart, A. Zou, M. Mazeika, D. Song, and J. Steinhardt. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021. Huang et al. [2021] L. Huang, S. Cao, N. Parulian, H.",
    "yarn-21": "Ji, and L. Wang. Efficient attentions for long document summarization. In Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 1419\u20131436. Association for Computational Linguistics, June 2021. Hugging Face [2023] Hugging Face. Open LLM Leaderboard, 2023. URL https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard. Jiang et al. [2023] A. Q. Jiang, A. Sablayrolles, A. Mensch, C. Bamford, D. S. Chaplot, D. de las Casas, F. Bressand, G. Lengyel, G. Lample, L. Saulnier, L. R. Lavaud, M.-A. Lachaux, P. Stock, T. L. Scao, T. Lavril, T. Wang, T. Lacroix, and W.",
    "yarn-22": "E. Sayed. Mistral 7b, 2023. kaiokendev [2023] kaiokendev. Things I\u2019m learning while training superhot., 2023. URL https://kaiokendev.github.io/til#extending-context-to-8k.",
    "yarn-23": "Kazemnejad et al. [2023] A. Kazemnejad, I. Padhi, K. N. Ramamurthy, P. Das, and S. Reddy. The impact of positional encoding on length generalization in transformers, 2023.",
    "yarn-24": "arXiv: 2305.19466. Lin et al. [2022] S. Lin, J. Hilton, and O. Evans. TruthfulQA: Measuring how models mimic human falsehoods. In Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 3214\u20133252, May 2022. Loshchilov and Hutter [2019] I. Loshchilov and F. Hutter. Decoupled weight decay regularization. In International Conference on Learning Representations, 2019. Mohtashami and Jaggi [2023] A. Mohtashami and M. Jaggi. Landmark attention: Random-access infinite context length for transformers, 2023. arXiv: 2305.16300. Paszke et al. [2019] A. Paszke, S.",
    "yarn-25": "Gross, F. Massa, A. Lerer, J. Bradbury, G. Chanan, T. Killeen, Z. Lin, N. Gimelshein, L. Antiga, A. Desmaison, A. K\u00f6pf, E. Yang, Z. DeVito, M. Raison, A. Tejani, S. Chilamkurthy, B. Steiner, L. Fang, J. Bai, and S. Chintala. PyTorch: An imperative style, high-performance deep learning library. In NeurIPS, pages 8024\u20138035, 2019. Press et al. [2022] O. Press, N.",
    "yarn-26": "Smith, and M. Lewis. Train Short, Test Long: Attention with linear biases enables input length extrapolation. In International Conference on Learning Representations, 2022. Quesnelle et al. [2023] J. Quesnelle, E. Shippole, and \"Kaiokendev\". Llongma: Scaling rotary embeddings through linear positional interpolation. https://huggingface.co/conceptofmind/LLongMA-2-7b/, 2023. Rae et al. [2020] J. W. Rae, A. Potapenko, S.",
    "yarn-27": "M. Jayakumar, C. Hillier, and T.",
    "yarn-28": "P. Lillicrap. Compressive transformers for long-range sequence modelling. In International Conference on Learning Representations, 2020. Roberts et al. [2019] A. Roberts, C. Raffel, K. Lee, M. Matena, N. Shazeer, P. J. Liu, S. Narang, W.",
    "yarn-29": "Li, and Y. Zhou. Exploring the limits of transfer learning with a unified text-to-text transformer. Technical report, Google, 2019. Rozi\u00e8re et al. [2023] B. Rozi\u00e8re, J. Gehring, F. Gloeckle, S. Sootla, I. Gat, X. E. Tan, Y. Adi, J. Liu, T. Remez, J. Rapin, A. Kozhevnikov, I. Evtimov, J. Bitton, M. Bhatt, C. C. Ferrer, A. Grattafiori, W. Xiong, A. D\u00e9fossez, J. Copet, F. Azhar, H. Touvron, L. Martin, N. Usunier, T.",
    "yarn-30": "Scialom, and G. Synnaeve. Code Llama: Open foundation models for code, 2023.",
    "yarn-31": "arXiv: 2308.12950. Shaw et al. [2018] P. Shaw, J. Uszkoreit, and A. Vaswani. Self-attention with relative position representations. In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 2 (Short Papers), pages 464\u2013468, New Orleans, Louisiana, June 2018. Association for Computational Linguistics. Su [2023] J. Su. Rectified rotary position embeddings. https://github.com/bojone/rerope, 2023.",
    "yarn-32": "Su et al. [2022] J. Su, Y. Lu, S. Pan, A. Murtadha, B.",
    "yarn-33": "Wen, and Y. Liu. RoFormer: Enhanced transformer with rotary position embedding, 2022.",
    "yarn-34": "arXiv: 2104.09864. Sun et al. [2022] Y. Sun, L. Dong, B. Patra, S. Ma, S. Huang, A. Benhaim, V. Chaudhary, X. Song, and F. Wei. A length-extrapolatable transformer, 2022. arXiv: 2212.10554. Tancik et al. [2020] M. Tancik, P. P. Srinivasan, B. Mildenhall, S. Fridovich-Keil, N. Raghavan, U. Singhal, R. Ramamoorthi, J. T. Barron, and R. Ng. Fourier features let networks learn high frequency functions in low dimensional domains. In Proceedings of the 34th International Conference on Neural Information Processing Systems, NIPS\u201920, Red Hook, NY, USA, 2020.",
    "yarn-35": "Curran Associates Inc. ISBN 9781713829546. Together.ai [2023] Together.ai. LLaMA-2-7B-32K, 2023. URL https://huggingface.co/togethercomputer/LLaMA-2-7B-32K. Touvron et al. [2023a] H. Touvron, T. Lavril, G. Izacard, X. Martinet, M.-A. Lachaux, T. Lacroix, B. Rozi\u00e8re, N. Goyal, E. Hambro, F. Azhar, A. Rodriguez, A. Joulin, E. Grave, and G. Lample. LLaMA: Open and efficient foundation language models, 2023a. arXiv: 2302.13971. Touvron et al. [2023b] H. Touvron, L. Martin, K. Stone, P. Albert, A. Almahairi, Y. Babaei, N. Bashlykov, S. Batra, P. Bhargava, S. Bhosale, D. Bikel, L. Blecher, C. C. Ferrer, M. Chen, G. Cucurull, D. Esiobu, J. Fernandes, J. Fu, W. Fu, B. Fuller, C. Gao, V. Goswami, N. Goyal, A. Hartshorn, S. Hosseini, R. Hou, H. Inan, M. Kardas, V. Kerkez, M. Khabsa, I. Kloumann, A. Korenev, P. S. Koura, M.-A. Lachaux, T. Lavril, J. Lee, D. Liskovich, Y. Lu, Y. Mao, X. Martinet, T. Mihaylov, P. Mishra, I. Molybog, Y. Nie, A. Poulton, J. Reizenstein, R. Rungta, K. Saladi, A. Schelten, R. Silva, E. M. Smith, R. Subramanian, X. E. Tan, B. Tang, R. Taylor, A. Williams, J. X. Kuan, P. Xu, Z. Yan, I. Zarov, Y. Zhang, A. Fan, M. Kambadur, S. Narang, A. Rodriguez, R. Stojnic, S.",
    "yarn-36": "Edunov, and T. Scialom. Llama 2: Open foundation and fine-tuned chat models, 2023b.",
    "yarn-37": "Vaswani et al. [2017] A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez, L. Kaiser, and I. Polosukhin. Attention is all you need. In Advances in Neural Information Processing Systems, volume 30. Curran Associates, Inc., 2017. Zellers et al. [2019] R. Zellers, A. Holtzman, Y. Bisk, A. Farhadi, and Y. Choi. HellaSwag: Can a machine really finish your sentence? In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, 2019. Zhao et al. [2023] Y. Zhao, A. Gu, R. Varma, L. Luo, C.-C. Huang, M. Xu, L. Wright, H. Shojanazeri, M. Ott, S. Shleifer, A. Desmaison, C. Balioglu, B. Nguyen, G. Chauhan, Y. Hao, and S. Li. PyTorch FSDP: Experiences on scaling fully sharded data parallel, 2023. arXiv: 2304.11277. Appendix A Additional details on interpolation methods\n\nA.1 Short notes on the deduction of \"NTK-aware\" interpolation\n\nIn Section 3.1, we introduce a change of basis from to in the definition of \"NTK-aware\" interpolation method. Here is a short note on its mathematical deduction. Recall that our goal is to spread out the interpolation pressure across the hidden dimensions using a base-change instead of scaling the frequencies by a fixed factor . The property we want to guarantee is that: The lowest frequency needs to be scaled as much as linear positional scaling and the highest frequency to stay constant. We introduce a new base such that the last dimension matches the wavelength of linear interpolation with a scale factor . Since the original RoPE method skips odd dimensions in order to concatenate both and components into a single embedding, the last dimension is . The new base can be chosen so that\n\nb \u2032 | D | \u2212 2 | D | = s \u22c5 b | D | \u2212 2 | D | . superscript superscript \ud835\udc4f \u2032 \ud835\udc37 2 \ud835\udc37 \u22c5 \ud835\udc60 superscript \ud835\udc4f \ud835\udc37 2 \ud835\udc37 {b^{\\prime}}^{\\frac{|D|-2}{|D|}}=s\\cdot b^{\\frac{|D|-2}{|D|}}. (23)\n\nSolving for yields\n\nb \u2032 = b \u22c5 s | D | | D | \u2212 2 . superscript \ud835\udc4f \u2032 \u22c5 \ud835\udc4f superscript \ud835\udc60 \ud835\udc37 \ud835\udc37 2 {b^{\\prime}}=b\\cdot s^{\\frac{|D|}{|D|-2}}. (24)\n\nA.2 The impact of pre-softmax scaling of YaRN on perplexity\n\nIn Section 3.4, we mention the impact of the factor inside the softmax computation of attention weights. Here we fix k-token documents from RedPajama [12]333We choose RedPajama because it is the open-source dataset closest to the training dataset of LLaMA as far as we are aware of., and calculate their perplexity scores with different scaling .",
    "yarn-38": "The result is in Figure 2. For comparison, recall that our recommended factor in this case () is given by the following. 1 t = 0.1 \u200b ln \u2061 ( s ) + 1 \u2248 1.208 . 1 \ud835\udc61 0.1 \ud835\udc60 1 1.208 \\sqrt{\\frac{1}{t}}=0.1\\ln({s})+1\\approx 1.208. (25)\n\nTo show the impact of the factor on different token positions, we cut each k-token document into chunks of tokens, and further plot the mean perplexity change comparing to in percentages\n\nppl \u200b ( t ) \u2212 ppl \u200b ( t = 1 ) ppl \u200b ( t = 1 ) ppl \ud835\udc61 ppl \ud835\udc61 1 ppl \ud835\udc61 1 \\dfrac{\\text{ppl}(t)-\\text{ppl}(t=1)}{\\text{ppl}(t=1)} (26)\n\nof each chunk. The plot is shown in Figure 3. To further demonstrate the best values of across all samples over different token positions, we plot the sample counts with minimal perplexity at a given for each of the position segments over the k-token range in Figure 4. We observe that:\n\n\u2022\n\nfor a suitable , a sample may obtain better perplexity scores across the extended context window;\n\n\u2022\n\nthe best value of is mostly consistent across different samples and different positions.",
    "yarn-39": "We remark that this finding is consistent for different values of and the best value of follows our recommended formula (Eq. 22) closely. Appendix B Additional tables and charts\n\nB.1 GovReport evaluations\n\nIn Section 4.3.1, we mention the evaluation on GovReport documents. The evaluation results are detailed in Table 4 below. B.2 Passkey Retrieval\n\nHere we can observe that the lowest perplexity point alone does not provide a comprehensive depiction on the \"effective context size\" that an LLM can attend to. While the Code Llama 13b model exhibits increasing perplexity above 100k context lengths, it was still able to accurately retrieve the passkey at a context length of 128k. This suggest that while the output of Code Llama might start to degrade in quality above 100k context size, it is still able to maintain strong retrieval capabilities. In addition, as YaRN with was trained for 200 more steps than YaRN with while having a higher passkey accuracy with similar perplexity, we hypothesize that perplexity may not be a great indicator of whether an LLM is able to attend to all tokens and does not exhaustively determine long context performance. This also suggests that the YaRN models with might be relatively undertrained for the passkey retrieval task. B.3 Dynamic scaling on models without any fine-tuning\n\nWe first recall from Section 3.3 that the Dynamic Scaling technique is an inference-time technique that dynamically update the factor in interpolation methods such as PI, \"NTK-by-parts\" and YaRN. We choose the original Llama 2, fix a sample in GovReport and calculate its perplexity on a sliding window of tokens using RoPE, Dynamic-PI and Dynamic-YaRN. Since the original maximal context length of Llama 2 is , we observe that Dynamic Scaling effectively extend the inference length and Dynamic-YaRN achieves better performance than Dynamic-PI. The resulting chart is in Figure 5. We see that\n\n\u2022\n\nDynamic Scaling effectively prevents the blow-up of perplexity score beyond pretrained context window;\n\n\u2022\n\nDynamic-YaRN outperforms Dynamic-PI in terms of long-range perplexity on pretrained Llama-2 without any finetuning. B.4 Mistral\n\nWe additionally extended the Mistral 7B v0.1 model [20], which broadly follows the Llama architecture. For Mistral we trained a 64k context window model () for 1000 steps using 16k sequence lengths with a constant learning rate of . The model\u2019s sliding window attention size was set to the context window size, effectively disabling sliding window attention. We then trained for an additional 500 steps at to arrive at a 128k context window model. The training data was a mix of the pre-train and fine-tune splits of Together Computer\u2019s Long-Data Collections [3]. We evaluated the models following the same procedure as described in 4.3.1, comparing against the base v0.1 model and MistralLite [1], an NTK-aware (M) version of v0.1. The results (Figure 6 and Table 6) were consistent with those of the Llama family of models. \u25c4 Feeling lucky? Conversion report Report an issue View original on arXiv\u25ba\n\nCopyright Privacy Policy\n\nGenerated on Wed Feb 28 09:01:09 2024 by LaTeXML"
}