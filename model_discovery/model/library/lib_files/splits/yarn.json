{
    "yarn-0": "# YaRN: Efficient Context Window Extension of Large Language Models \n\nBowen Peng $^{1 *} \\quad$ Jeffrey Quesnelle ${ }^{1 \\dagger} \\quad$ Honglu Fan $^{23} \\quad$ Enrico Shippole $^{\\ddagger}$<br>${ }^{1}$ Nous Research ${ }^{2}$ EleutherAI ${ }^{3}$ University of Geneva\n\n\n#### Abstract\n\nRotary Position Embeddings (RoPE) have been shown to effectively encode positional information in transformer-based language models.",
    "yarn-1": "However, these models fail to generalize past the sequence length they were trained on. We present YaRN (Yet another RoPE extensioN method), a compute-efficient method to extend the context window of such models, requiring 10 x less tokens and 2.5 x less training steps than previous methods. Using YaRN, we show that LLaMA models can effectively utilize and extrapolate to context lengths much longer than their original pre-training would allow, while also surpassing previous the state-of-the-art at context window extension. In addition, we demonstrate that YaRN exhibits the capability to extrapolate beyond the limited context of a fine-tuning dataset. The models fine-tuned using YaRN has been made available and reproduced online up to 128 k context length at https://github. com/jquesnelle/yarn\n\n\n![](https://cdn.mathpix.com/cropped/2024_09_17_bc3ef2d6a6193947023ag-01.jpg?height=609&width=1161&top_left_y=1601&top_left_x=466)\n\nFigure 1: Sliding window perplexity $(S=256)$ of ten 128 k Proof-pile documents truncated to evaluation context window size\n\n[^0]\n## 1 Introduction\n\nTransformer-based Large Language Models[40] (LLMs) have become the near-ubiquitous choice for many natural language processing (NLP) tasks where long-range abilities such as in-context learning (ICL) has been crucial. In performing the NLP tasks, the maximal length of the sequences (the context window) determined by its training processes has been one of the major limits of a pretrained LLM. Being able to dynamically extend the context window via a small amount of fine-tuning (or without fine-tuning) has become more and more desirable. To this end, the position encodings of transformers are the center of the discussions. The original Transformer architecture used an absolute sinusoidal position encoding, which was later improved to a learnable absolute position encoding [15]. Since then, relative positional encoding schemes [32] have further increased the performance of Transformers. Currently, the most popular relative positional encodings are T5 Relative Bias [30], RoPE [34], XPos [35], and ALiBi [27]. One reoccurring limitation with positional encodings is the inability to generalize past the context window seen during training. While some methods such as ALiBi are able to do limited generalization, none are able to generalize to sequences significantly longer than their pre-trained length [22]. Some works have been done to overcome such limitation. [9] and concurrently [21] proposed to extend the context length by slightly modifying RoPE via Position Interpolation (PI) and fine-tuning on a small amount of data. As an alternative, [6] proposed the \"NTK-aware\" interpolation by taking the loss of high frequency into account. Since then, two improvements of the \"NTK-aware\" interpolation have been proposed, with different emphasis:\n\n- the \"Dynamic NTK\" interpolation method [14] for pre-trained models without fine-tuning. - the \"NTK-by-parts\" interpolation method [7] which performs the best when fine-tuned on a small amount of longer-context data. The \"NTK-aware\" interpolation and the \"Dynamic NTK\" interpolation have already seen their presence in the open-source models such as Code Llama [31] (using \"NTK-aware\" interpolation) and Qwen 7B [2] (using \"Dynamic NTK\"). In this paper, in addition to making a complete account of the previous unpublished works on the \"NTK-aware\", the \"Dynamic NTK\" and the \"NTK-by-part\" interpolations, we present YaRN (Yet another RoPE extensioN method), an improved method to efficiently extend the context window of models trained with Rotary Position Embeddings (RoPE) including the LLaMA [38], the GPTNeoX [5], and the PaLM [10] families of models. YaRN reaches state-of-the-art performances in context window extensions after fine-tuning on less than $\\sim 0.1 \\%$ of the original pre-training data. In the meantime, by combining with the inference-time technique called Dynamic Scaling, the Dynamic-YaRN allows for more than 2x context window extension without any fine-tuning. ## 2 Background and Related Work\n\n### 2.1 Rotary Position Embeddings\n\nThe basis of our work is the Rotary Position Embedding (RoPE) introduced in [34]. We work on a hidden layer where the set of hidden neurons are denoted by $D$. Given a sequence of vectors $\\mathbf{x}_{1}, \\cdots, \\mathbf{x}_{L} \\in \\mathbb{R}^{|D|}$, following the notation of [34], the attention layer first converts the vectors into the query vectors and the key vectors:\n\n$$\n\\mathbf{q}_{m}=f_{q}\\left(\\mathbf{x}_{m}, m\\right) \\in \\mathbb{R}^{|D|}, \\mathbf{k}_{n}=f_{k}\\left(\\mathbf{x}_{n}, n\\right) \\in \\mathbb{R}^{|D|}\n$$\n\nNext, the attention weights are calculated as\n\n$$\n\\operatorname{softmax}\\left(\\frac{\\mathbf{q}_{m}^{T} \\mathbf{k}_{n}}{\\sqrt{|D|}}\\right)\n$$\n\nwhere $\\mathbf{q}_{m}, \\mathbf{k}_{n}$ are considered as column vectors so that $\\mathbf{q}_{m}^{T} \\mathbf{k}_{n}$ is simply the Euclidean inner product. In RoPE, we first assume that $|D|$ is even and identify the embedding space and the hidden states as\ncomplex vector spaces:\n\n$$\n\\mathbb{R}^{|D|} \\cong \\mathbb{C}^{|D| / 2}\n$$\n\nwhere the inner product $\\mathbf{q}^{T} \\mathbf{k}$ becomes the real part of the standard Hermitian inner product $\\operatorname{Re}\\left(\\mathbf{q}^{*} \\mathbf{k}\\right)$. More specifically, the isomorphisms interleave the real part and the complex part\n\n$$\n\\begin{aligned}\n\\left(\\left(\\mathbf{x}_{m}\\right)_{1}, \\cdots,\\left(\\mathbf{x}_{m}\\right)_{|D|}\\right) & \\mapsto\\left(\\left(\\mathbf{x}_{m}\\right)_{1}+i\\left(\\mathbf{x}_{m}\\right)_{2}, \\cdots,\\left(\\left(\\mathbf{x}_{m}\\right)_{|D|-1}+i\\left(\\mathbf{x}_{m}\\right)_{|D|}\\right)\\right) \\\\\n\\left(\\left(\\mathbf{q}_{m}\\right)_{1}, \\cdots,\\left(\\mathbf{q}_{m}\\right)_{|D|}\\right) & \\mapsto\\left(\\left(\\mathbf{q}_{m}\\right)_{1}+i\\left(\\mathbf{q}_{m}\\right)_{2}, \\cdots,\\left(\\left(\\mathbf{q}_{m}\\right)_{|D|-1}+i\\left(\\mathbf{q}_{m}\\right)_{|D|}\\right)\\right)\n\\end{aligned}\n$$\n\nTo convert embeddings $\\mathbf{x}_{m}, \\mathbf{x}_{n}$ into query and key vectors, we are first given $\\mathbb{R}$-linear operators\n\n$$\n\\mathbf{W}_{q}, \\mathbf{W}_{k}: \\mathbb{R}^{|D|} \\rightarrow \\mathbb{R}^{|D|}\n$$\n\nIn complex coordinates, the functions $f_{q}, f_{k}$ are given by\n\n$$\nf_{q}\\left(\\mathbf{x}_{m}, m\\right)=e^{i m \\theta} \\mathbf{W}_{q} \\mathbf{x}_{m}, f_{k}\\left(\\mathbf{x}_{n}, n\\right)=e^{i n \\theta} \\mathbf{W}_{k} \\mathbf{x}_{n}\n$$\n\nwhere $\\theta=\\operatorname{diag}\\left(\\theta_{1}, \\cdots, \\theta_{|D| / 2}\\right)$ is the diagonal matrix with $\\theta_{d}=b^{-2 d /|D|}$ and $b=10000$. This way, RoPE associates each (complex-valued) hidden neuron with a separate frequency $\\theta_{d}$. The benefit of doing so is that the dot product between the query vector and the key vector only depends on the relative distance $m-n$ as follows\n\n$$\n\\begin{aligned}\n& \\left\\langle f_{q}\\left(\\mathbf{x}_{m}, m\\right), f_{k}\\left(\\mathbf{x}_{n}, n\\right)\\right\\rangle_{\\mathbb{R}} \\\\\n= & \\operatorname{Re}\\left(\\left\\langle f_{q}\\left(\\mathbf{x}_{m}, m\\right), f_{k}\\left(\\mathbf{x}_{n}, n\\right)\\right\\rangle_{\\mathbb{C}}\\right) \\\\\n= & \\operatorname{Re}\\left(\\mathbf{x}_{m}^{*} \\mathbf{W}_{q}^{*} \\mathbf{W}_{k} \\mathbf{x}_{n} e^{i \\theta(m-n)}\\right) \\\\\n= & g\\left(\\mathbf{x}_{m}, \\mathbf{x}_{n}, m-n\\right)\n\\end{aligned}\n$$\n\nIn real coordinates, the RoPE can be written using the following function\n$f_{\\mathbf{W}}\\left(\\mathbf{x}_{m}, m, \\theta_{d}\\right)=\\left(\\begin{array}{ccccccc}\\cos m \\theta_{1} & -\\sin m \\theta_{1} & 0 & 0 & \\cdots & 0 & 0 \\\\ \\sin m \\theta_{1} & \\cos m \\theta_{1} & 0 & 0 & \\cdots & 0 & 0 \\\\ 0 & 0 & \\cos m \\theta_{2} & -\\sin m \\theta_{2} & \\cdots & 0 & 0 \\\\ 0 & 0 & \\sin m \\theta_{2} & \\cos m \\theta_{2} & \\cdots & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\cdots & \\cos m \\theta_{l} & -\\sin m \\theta_{l} \\\\ 0 & 0 & 0 & 0 & \\cdots & \\sin m \\theta_{l} & \\cos m \\theta_{l}\\end{array}\\right) \\mathbf{W} \\mathbf{x}_{m}$\nso that\n\n$$\nf_{q}=f_{\\mathbf{W}_{q}}, f_{k}=f_{\\mathbf{W}_{k}}\n$$\n\n### 2.2 Position Interpolation\n\nAs language models are usually pre-trained with a fixed context length, it is natural to ask how to extend the context length by fine-tuning on relatively less amount of data. For language models using RoPE as the position embedding, Chen et al. [9], and concurrently kaiokendev [21] proposed the Position Interpolation (PI) to extend the context length beyond the pre-trained limit. While a direct extrapolation does not perform well on sequences $w_{1}, \\cdots, w_{L}$ with $L$ larger than the pre-trained limit, they discovered that interpolating the position indicies within the pre-trained limit works well with the help of a small amount of fine-tuning. Specifically, given a pre-trained language model with RoPE, they modify the RoPE by\n\n$$\nf_{\\mathbf{W}}^{\\prime}\\left(\\mathbf{x}_{m}, m, \\theta_{d}\\right)=f_{\\mathbf{W}}\\left(\\mathbf{x}_{m}, \\frac{m L}{L^{\\prime}}, \\theta_{d}\\right)\n$$\n\nwhere $L^{\\prime}>L$ is a new context window beyond the pre-trained limit. With the original pre-trained model plus the modified RoPE formula, they fine-tuned the language model further on several orders of magnitude fewer tokens (a few billion in Chen et al. [9]) and successfully acheived context window extension. ### 2.3 Additional Notation\n\nThe ratio between the extended context length and the original context length has been of special importance, and we introduce the notation $s$ defined by\n\n$$\ns=\\frac{L^{\\prime}}{L}\n$$\n\nand we call $s$ the scale factor. We also rewrite and simplify Eq. 10 into the following general form:\n\n$$\nf_{\\mathbf{W}}^{\\prime}\\left(\\mathbf{x}_{m}, m, \\theta_{d}\\right)=f_{\\mathbf{W}}\\left(\\mathbf{x}_{m}, g(m), h\\left(\\theta_{d}\\right)\\right)\n$$\n\nwhere $g(m), h\\left(\\theta_{d}\\right)$ are method-dependent functions. For PI, we have $g(m)=m / s, h\\left(\\theta_{d}\\right)=\\theta_{d}$. In the subsequent sections, when we introduce a new interpolation method, we sometimes only specify the functions $g(m)$ and $h\\left(\\theta_{d}\\right)$. Additionally, we define $\\lambda_{d}$ as the wavelength of the RoPE embedding at $d$-th hidden dimension:\n\n$$\n\\lambda_{d}=\\frac{2 \\pi}{\\theta_{d}}=2 \\pi b^{\\frac{2 d}{|D|}}\n$$\n\nThe wavelength describes the length of tokens needed in order for the RoPE embedding at dimension $d$ to perform a full rotation $(2 \\pi)$.",
    "yarn-2": "Given that some interpolation methods (eg. PI) do not care about the wavelength of the dimensions, we will refer to those methods as \"blind\" interpolation methods, while others do (eg. YaRN), which we will classify as \"targeted\" interpolation methods. ### 2.4 Related work\n\nReRoPE [33] also aims to extend the context size of existing models pre-trained with RoPE, and claims \"infinite\" context length without needing any fine-tuning. This claim is backed by a monotonically decreasing loss with increasing context length up to 16 k on the Llama 2 13B model. It achieves context extension by modifying the attention mechanism and thus is not purely an embedding interpolation method. Since it is currently not compatible with Flash Attention 2 [13] and requires two attention passes during inference, we do not consider it for comparison. Concurrently with our work, LM-Infinite [16] proposes similar ideas to YaRN, but focuses on \"on-thefly\" length generalization for non-fine-tuned models. Since they also modify the attention mechanism of the models, it is not an embedding interpolation method and is not immediately compatible with Flash Attention 2. ## 3 Methodology\n\nWhereas PI stretches all RoPE dimensions equally, we find that the theoretical interpolation bound described by PI [9] is insufficient at predicting the complex dynamics between RoPE and the LLM's internal embeddings. In the following subsections, we describe the main issues with PI we have individually identified and solved, so as to give the readers the context, origin and justifications of each method which we use in concert to obtain the full YaRN method. ### 3.1 Loss of High Frequency information - 'NTK-aware' interpolation\n\nIf we look at RoPE only from an information encoding perspective, it was shown in [36], using Neural Tangent Kernel (NTK) theory, that deep neural networks have trouble learning high frequency information if the input dimension is low and the corresponding embeddings lack high frequency components. Here we can see the similarities: a token's positional information is one-dimensional, and RoPE expands it to an n-dimensional complex vector embedding. RoPE closely resembles Fourier Features [36] in many aspects, as it is possible to define RoPE as a special 1D case of a Fourier Feature. Stretching the RoPE embeddings indiscriminately results in the loss of important high frequency details which the network needs in order to resolve tokens that are both very similar and very close together (the rotation describing the smallest distance needs to not be too small for the network to be able to detect it). We hypothesise that the slight increase of perplexity for short context sizes after fine-tuning on larger context sizes seen in PI [9] might be related to this problem. Under ideal circumstances, there is no reason that fine-tuning on larger context sizes should degrade the performance of smaller context sizes. In order to resolve the problem of losing high frequency information when interpolating the RoPE embeddings, the \"NTK-aware\" interpolation was developed in [6]. Instead of scaling every dimension of RoPE equally by a factor $s$, we spread out the interpolation pressure across multiple dimensions by scaling high frequencies less and low frequencies more. One can obtain such a transformation in many ways, but the simplest would be to perform a base change on the value of $\\theta$. More precisely, following the notations set out in Section 2.3, we define the \"NTK-aware\" interpolation scheme as follows (see the Appendix A.1 for the details of the deduction). Definition 1 The \"NTK-aware\" interpolation is a modification of RoPE by using Eq. 12 with the following functions. $$\n\\begin{aligned}\n& g(m)=m \\\\\n& h\\left(\\theta_{d}\\right)=b^{\\prime-2 d /|D|}\n\\end{aligned}\n$$\n\nwhere\n\n$$\nb^{\\prime}=b \\cdot s^{\\frac{|D|}{|D|-2}}\n$$\n\nGiven the results from [6], this method performs much better at extending the context size of non-finetuned models compared to PI [9]. However, one major disadvantage of this method is that given it is not just an interpolation scheme, some dimensions are slightly extrapolated to \"out-of-bound\" values, thus fine-tuning with \"NTK-aware\" interpolation [6] yields inferior results to PI [9]. Furthermore, due to the \"out-of-bound\" values, the theoretical scale factor $s$ does not accurately describe the true context extension scale. In practice, the scale value $s$ has to be set higher than the expected scale for a given context length extension. We note that shortly before the release of this article, Code Llama [31] was released and uses \"NTK-aware\" scaling by manually scaling the base $b$ to 1 M . ### 3.2 Loss of Relative Local Distances - 'NTK-by-parts' interpolation\n\nIn the case of blind interpolation methods like PI and \"NTK-aware\" interpolation, we treat all the RoPE hidden dimensions equally (as in they have the same effect on the network). However, there are strong clues that point us towards the need for targeted interpolation methods. In this section, we think heavily in terms of the wavelengths $\\lambda_{d}$ defined in Eq. 13 in the formula of RoPE. For simplicity, we omit the subscript $d$ in $\\lambda_{d}$ and the reader is encouraged to think about $\\lambda$ as the wavelength of an arbitrary periodic function. One interesting observation of RoPE embeddings is that given a context size $L$, there are some dimensions $d$ where the wavelength is longer than the maximum context length seen during pretraining $(\\lambda>L)$, this suggests that some dimensions' embeddings might not be distributed evenly in the rotational domain. In such cases, we presume having all unique position pairs implies that the absolute positional information remains intact. On the contrary, when the wavelength is short, only relative positional information is accessible to the network. Moreover, when we stretch all the RoPE dimensions either by a scale $s$ or using a base change $b^{\\prime}$, all tokens become closer to each other, as the dot product of two vectors rotated by a lesser amount is bigger. This scaling severely impairs a LLM's ability to understand small and local relationships between its internal embeddings. We hypothesize that such compression leads to the model being confused on the positional order of close-by tokens, and consequently harming the model's abilities. In order to remedy this issue, given the two previous observations that we have found, we choose not to interpolate the higher frequency dimensions at all while always interpolating the lower frequency dimensions. In particular,\n\n- if the wavelength $\\lambda$ is much smaller than the context size $L$, we do not interpolate;\n- if the wavelength $\\lambda$ is equal to or bigger than the context size $L$, we want to only interpolate and avoid any extrapolation (unlike the previous \"NTK-aware\" method);\n- dimensions in-between can have a bit of both, similar to the \"NTK-aware\" interpolation. As a result, it is more convenient to introduce the ratio $r=\\frac{L}{\\lambda}$ between the original context size $L$ and the wavelength $\\lambda$. In the $d$-th hidden state, the ratio $r$ depends on $d$ in the following way:\n\n$$\nr(d)=\\frac{L}{\\lambda_{d}}=\\frac{L}{2 \\pi b^{\\prime \\frac{2 d}{|D|}}}\n$$\n\nIn order to define the boundary of the different interpolation strategies as above, we introduce two extra parameters $\\alpha, \\beta$. All hidden dimensions $d$ where $r(d)<\\alpha$ are those where we linearly interpolate by a scale $s$ (exactly like PI, avoiding any extrapolation), and the $d$ where $r(d)>\\beta$ are those where we do not interpolate at all. Define the ramp function $\\gamma$ to be\n\n$$\n\\gamma(r)= \\begin{cases}0, & \\text { if } r<\\alpha \\\\ 1, & \\text { if } r>\\beta \\\\ \\frac{r-\\alpha}{\\beta-\\alpha}, & \\text { otherwise }\\end{cases}\n$$\n\nWith the help of the ramp function, the \"NTK-by-parts\" method can be described as follows. Definition 2 The \"NTK-by-parts\" interpolation is a modification of RoPE by using Eq. 12 with the following functions\n\n$$\n\\begin{aligned}\n& g(m)=m \\\\\n& h\\left(\\theta_{d}\\right)=(1-\\gamma(r(d))) \\frac{\\theta_{d}}{s}+\\gamma(r(d)) \\theta_{d}\n\\end{aligned}\n$$\n\nThe values of $\\alpha$ and $\\beta$ should be tuned on a case-by-case basis. For example, we have found experimentally that for the Llama family of models, good values for $\\alpha$ and $\\beta$ are $\\alpha=1$ and $\\beta=32$. Using the techniques described in this section, a variant of the resulting method was released under the name \"NTK-by-parts\" interpolation [7]. This improved method performs better than the previous PI [9] and \"NTK-aware\" 3.1 interpolation methods, both with non-fine-tuned models and with fine-tuned models, as shown in [7]. ### 3.3 Dynamic Scaling - 'Dynamic NTK' interpolation\n\nIn a lot of use cases, multiple forward-passes are performed with varying sequence lengths from 1 to the maximal context size. A typical example is the autoregressive generation where the sequence lengths increment by 1 after each step. There are two ways of applying an interpolation method that uses a scale factor $s$ (including PI, \"NTK-aware\" and \"NTK-by-parts\"):\n\n1. Throughout the whole inference cycle, the embedding layer is fixed including the scale factor $s=L^{\\prime} / L$ where $L^{\\prime}$ is the fixed number of extended context size. 2. In each forward-pass, the position embedding updates the scale factor $s=\\max \\left(1, l^{\\prime} / L\\right)$ where $l^{\\prime}$ is the sequence length of the current sequence. The problem of (1) is that the model may experience a performance discount at a length less than $L$ and an abrupt degradation when the sequence length is longer than $L^{\\prime}$. But by doing Dynamic\n\n[^1]Scaling as (2), it allows the model to gracefully degrade instead of immediately breaking when hitting the trained context limit $L^{\\prime}$. We call this inference-time method the Dynamic Scaling method. When it is combined with \"NTK-awared\" interpolation, we call it \"Dynamic NTK\" interpolation. It first appeared in public as a reddit post in [14]. One notable fact is that the \"Dynamic NTK\" interpolation works exceptionally well on models pretrained on $L$ without any finetuning $\\left(L^{\\prime}=L\\right)$. This is supported by the experiment in Appendix B. 3\nOften in the repeated forward-passes, the kv-caching [8] is applied so that we can reuse the previous key-value vectors and improve the overall efficiency. We point out that in some implementations when the RoPE embeddings are cached, some care has to be taken in order to modify it for Dynamic Scaling with kv-caching. The correct implementation should cache the kv-embeddings before applying RoPE, as the RoPE embedding of every token changes when $s$ changes. ### 3.4 YaRN\n\nIn addition to the previous interpolation techniques, we also observe that introducing a temperature $t$ on the logits before the attention softmax has a uniform impact on perplexity regardless of the data sample and the token position over the extended context window (See Appendix A.2). More precisely, instead of Eq. 2, we modify the computation of attention weights into\n\n$$\n\\operatorname{softmax}\\left(\\frac{\\mathbf{q}_{m}^{T} \\mathbf{k}_{n}}{t \\sqrt{|D|}}\\right)\n$$\n\nThe reparametrization of RoPE as a set of 2D matrices has a clear benefit on the implementation of this attention scaling: we can instead use a \"length scaling\" trick which scales both $\\mathbf{q}_{m}$ and $\\mathbf{k}_{n}$ by a constant factor $\\sqrt{1 / t}$ by simply scaling the complex RoPE embeddings by the same amount. With this, YaRN can effectively alter the attention mechanism without modifying its code. Furthermore, it has zero overhead during both inference and training, as RoPE embeddings are generated in advance and are reused for all forward passes. Combining it with the \"NTK-by-parts\" interpolation, we have the YaRN method. Definition 3 By the \"YaRN method\", we refer to a combination of the attention scaling in Eq. 21 and the \"NTK-by-parts\" interpolation introduced in Section 3.2\n\nFor LLaMA and Llama 2 models, we recommend the following values:\n\n$$\n\\sqrt{\\frac{1}{t}}=0.1 \\ln (s)+1\n$$\n\nThe equation above is found by fitting $\\sqrt{1 / t}$ at the lowest perplexity against the scale extension by various factors $s$ using the \"NTK-by-parts\" method (Section 3.2) on LLaMA 7b, 13b, 33b and 65 b models without fine-tuning.",
    "yarn-3": "We note that the same values of $t$ also apply fairly well to Llama 2 models ( $7 \\mathrm{~b}, 13 \\mathrm{~b}$ and 70b). It suggests that the property of increased entropy and the temperature constant $t$ may have certain degree of \"universality\" and may be generalizable across some models and training data. The YaRN method combines all our findings and surpasses all previous methods in both fine-tuned and non-fine-tuned scenarios. Thanks to its low footprint, YaRN allows for direct compatibility with libraries that modify the attention mechanism such as Flash Attention 2 [13]. ## 4 Experiments\n\nWe show that YaRN successfully achieves context window extension of language models using RoPE as its position embedding.",
    "yarn-4": "Moreover, this result is achieved with only 400 training steps, representing approximately $0.1 \\%$ of the model's original pre-training corpus, a 10 x reduction from Rozi\u00e8re et al. [31] and 2.5 x reduction in training steps from Chen et al. [9], making it highly compute-efficient for training with no additional inference costs. We calculate the perplexity of long documents and score\non established benchmarks to evaluate the resulting models, finding that they surpass all other context window extension methods. We broadly followed the training and evaluation procedures as outlined in [9]. ### 4.1 Training\n\nFor training, we extended the Llama 2 [39] 7B and 13B parameter models. No changes were made to the LLaMA model architecture other than the calculation of the embedding frequencies as described in 3.4 with $s=16$ and $s=32$. We used a learning rate of $2 \\times 10^{-5}$ with no weight decay and a linear warmup of 20 steps along with AdamW [24] $\\beta_{1}=0.9$ and $\\beta_{2}=0.95$. For $s=16$ we fine-tuned for 400 steps with global batch size 64 using PyTorch [26] Fully Sharded Data Parallelism [42] and Flash Attention 2 [13] on the PG19 dataset [29] chunked into 64k segments bookended with the BOS and EOS token. For $s=32$ we followed the same procedure, but started from the finished $s=16$ checkpoint and trained for an additional 200 steps. ### 4.2 Extrapolation and Transfer Learning\n\nIn Code Llama [31], a dataset with 16 k context was used with a scale factor set to $s \\approx 88.6$, which corresponds to a context size of 355 k . They show that the network extrapolates up to 100 k context without ever seeing those context sizes during training. Similar to 3.1 and Rozi\u00e8re et al. [31], YaRN also supports training with a higher scale factor $s$ than the length of the dataset. Due to compute constraints, we test only $s=32$ by further fine-tuning the $s=16$ model for 200 steps using the same dataset with 64 k context. We show in 4.3 .1 that the $s=32$ model successfully extrapolates up to 128 k context using only 64 k context during training. Unlike previous \"blind\" interpolation methods, YaRN is much more efficient at transfer learning when increasing the scale $s$. This demonstrates successful transfer learning from $s=16$ to $s=32$ without the network needing to relearn the interpolated embeddings, as the $s=32$ model is equivalent to the $s=16$ model across the entire context size, despite only being trained on $s=32$ for 200 steps. ### 4.3 Evaluation\n\nThe evaluations focus on three aspects:\n\n1. the perplexity scores of fine-tuned models with extended context window,\n2. the passkey retrieval task on fine-tuned models,\n3. the common LLM benchmark results of fine-tuned models,\n\n### 4.3.1 Long Sequence Language Modeling\n\nTo evaluate the long sequence language modeling performances, we use the GovReport [18] and Proof-pile [4] datasets both of which contain many long sequence samples. For all evaluations, the test splits of both datasets were used exclusively. All perplexity evaluations were calculated using the sliding window method from Press et al. [27] with $S=256$. Firstly, we evaluated how the model performed as the context window increased. We selected 10 random samples from Proof-pile with at least 128k tokens each and evaluated the perplexity of each of these samples when truncated at 2 k steps from a sequence length of 2 k tokens through 128 k tokens. Table 1 shows a side-by-side comparison of Llama-2 model extended from 4096 to 8192 context length via PI (LLongMA-2 7b $\\mathrm{b}^{5}$ ), \"NTK-aware\" and YaRN. Note that PI and \"NTK-aware\" models were trained using the methodology in Chen et al. [9], while YaRN used the same methodology but $2.5 x$ less training steps and data, as described in 4. [^2]| Extension | Trained | Context | Evaluation Context Window Size |  |  |  |  |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Method | Tokens | Window | 2048 | 4096 | 6144 | 8192 | 10240 |\n| PI $(s=2)$ | 1 B | 8 k | 3.92 | 3.51 | $\\mathbf{3 .",
    "yarn-5": "5 1}$ | $\\mathbf{3 . 3 4}$ | 8.07 |\n| NTK $(\\theta=20 \\mathrm{k})$ | 1 B | 8 k | 4.20 | 3.75 | 3.74 | 3.59 | 6.24 |\n| YaRN $(s=2)$ | 400 M | 8 k | $\\mathbf{3 . 9 1}$ | $\\mathbf{3 .",
    "yarn-6": "5 0}$ | $\\mathbf{3 . 5 1}$ | 3.35 | $\\mathbf{6 . 0 4}$ |\n\nTable 1: Sliding window perplexity ( $S=256$ ) of ten 128k Proof-pile documents over Llama-2 extended via PI, NTK and YaRN\n\nWe further evaluated YaRN at the scale factor $s=16,32$ and compared them against a few opensource models fine-tuned from Llama-2 and extended to more than 32 k context window such as Together.ai [37] and \"NTK-aware\" Code Llama [31].",
    "yarn-7": "The results are summarized in Table 2(with a more detailed plot in Figure 1). | Model | Model | Context | Extension | Evaluation Context Window Size |  |  |  |  |\n| ---: | :---: | ---: | :---: | ---: | ---: | ---: | ---: | ---: |\n| Size | Name | Window | Method | 8192 | 32768 | 65536 | 98304 | 131072 |\n| 7B | Together | 32 k | PI | $\\mathbf{3 . 5 0}$ | $\\mathbf{2 . 6 4}$ | $>10^{2}$ | $>10^{3}$ | $>10^{4}$ |\n| 7B | Code Llama | 100 k | NTK | 3.71 | 2.74 | 2.55 | 2.54 | 2.71 |\n| 7B | YaRN $(s=16)$ | 64 k | YaRN | 3.51 | 2.65 | $\\mathbf{2 . 4 2}$ | $>10^{1}$ | $>10^{1}$ |\n| 7B | YaRN $(s=32)$ | 128 k | YaRN | 3.56 | 2.70 | 2.45 | $\\mathbf{2 . 3 6}$ | $\\mathbf{2 . 3 7}$ |\n| 13B | Code Llama | 100 k | NTK | 3.54 | 2.63 | 2.41 | 2.37 | 2.54 |\n| 13B | YaRN $(s=16)$ | 64k | YaRN | $\\mathbf{3 . 2 5}$ | $\\mathbf{2 . 5 0}$ | $\\mathbf{2 . 2 9}$ | $>10^{1}$ | $>10^{1}$ |\n| 13B | YaRN $(s=32)$ | 128 k | YaRN | 3.29 | 2.53 | 2.31 | $\\mathbf{2 . 2 3}$ | $\\mathbf{2 . 2 4}$ |\n\nTable 2: Sliding window perplexity $(S=256)$ of ten 128 k Proof-pile documents truncated to evaluation context window size\n\nWe observe that the model exhibits strong performance across the entire targeted context size, with YaRN interpolation being the first method to successfully extend the effective context size of Llama 2 to 128 k . Of particular note are the YaRN $(s=32)$ models, which show continued declining perplexity through 128 k , despite the fine-tuning data being limited to 64 k tokens in length, demonstrating that the model is able to generalize to unseen context lengths. Furthermore, in Appendix B.1, we show the results of the average perplexity on 50 untruncated GovReport documents with at least 16 k tokens per sample evaluated on the setting of 32 k maximal context window without Dynamic Scaling in Table 4 Similar to the Proof-pile results, the GovReport results show that fine-tuning with YaRN achieves good performance on long sequences. ### 4.3.2 Passkey Retrieval\n\nThe passkey retrieval task as defined in [25] measures a model's ability to retrieve a simple passkey (i.e., a five-digit number) from amongst a large amount of otherwise meaningless text. For our evaluation of the models, we performed 10 iterations of the passkey retrieval task with the passkey placed at a random location uniformly distributed across the evaluation context window on different context window sizes ranging from 8 k to 128 k . Both 7 b and 13 b models fine-tuned using YaRN at 128 k context size passes the passkey retrieval task with very high accuracy $(>99 \\%)$ within the entire context window size.",
    "yarn-8": "We show detailed results in Appendix B. 2 . ### 4.3.3 Standardized Benchmarks\n\nThe Hugging Face Open LLM Leaderboard [19] compares a multitude of LLMs across a standardized set of four public benchmarks. Specifically, we use 25 -shot ARC-Challenge [11], 10-shot HellaSwag [41], 5-shot MMLU [17], and 0 -shot TruthfulQA [23]. To test the degradation of model performance under context extension, we evaluated our models using this suite and compared it to established scores for the Llama 2 baselines as well as publicly available PI and \"NTK-aware\" models. The results are summarized in Table 3. | Model <br> Size | Model <br> Name | Context <br> Window | Extension <br> Method | ARC-c | Hellaswag | MMLU | TruthfulQA |\n| ---: | :---: | ---: | :---: | :---: | :---: | :---: | :---: |\n| 7B | Llama 2 | 4 k | None | $\\mathbf{5 3 . 1}$ | 77.8 | $\\mathbf{4 3 . 8}$ | 39.0 |\n| 7B | Together | 32 k | PI | 47.6 | 76.1 | 43.3 | $\\mathbf{3 9 . 2}$ |\n| 7B | Code Llama | 100 k | NTK | 39.9 | 60.8 | 31.1 | 37.8 |\n| 7B | YaRN $(s=16)$ | 64 k | YaRN | 52.3 | $\\mathbf{7 8 . 8}$ | 42.5 | 38.2 |\n| 7B | YaRN $(s=32)$ | 128 k | YaRN | 52.1 | 78.4 | 41.7 | 37.3 |\n| 13B | Llama 2 | 4 k | None | $\\mathbf{5 9 . 4}$ | 82.1 | $\\mathbf{5 5 . 8}$ | 37.4 |\n| 13B | Code Llama | 100k | NTK | 40.9 | 63.4 | 32.8 | $\\mathbf{4 3 . 8}$ |\n| 13B | YaRN $(s=16)$ | 64 k | YaRN | 58.1 | $\\mathbf{8 2 . 3}$ | 52.8 | 37.8 |\n| 13B | YaRN $(s=32)$ | 128 k | YaRN | 58.0 | 82.2 | 51.9 | 37.3 |\n\nTable 3: Performance of context window extensions methods on the Hugging Face Open LLM benchmark suite compared with original Llama 2 baselines\n\nWe observe that there is minimal performance degradation between the YaRN models and their respective Llama 2 baselines. We also observe that there was on average a $0.49 \\%$ drop in scores between the YaRN $s=16$ and $s=32$ models. From this we conclude that the the iterative extension from 64 k to 128 k results in negligible performance loss. ## 5 Conclusion\n\nIn conclusion, we have shown that YaRN improves upon all existing RoPE interpolation methods and can act as a drop-in replacement to PI, with no downsides and minimal implementation effort. The fine-tuned models preserve their original abilities on multiple benchmarks while being able to attend to a very large context size. Furthermore, YaRN allows efficient extrapolation with finetuning on shorter datasets and can take advantage of transfer learning for faster convergence, both of which are crucial under compute-constrained scenarios. Finally, we have shown the effectiveness of extrapolation with YaRN where it is able to \"train short, and test long\". ## 6 Reproducibility\n\nTo aid in reproducibility, we provide, as supplementary material, the entirety of of the code used to train the YaRN models in Table 2, as well as the evaluation code that produced Figure 1 and Tables 1, 2, 3, 4, and 5 . The code also contains implementations of various extension methods referenced throughout the paper. For training YaRN, we used the publicly available PG19 dataset [29] tokenized to 64 k tokens. ## References\n\n[1] Mistrallite. URL https://huggingface.co/amazon/MistralLite. [2] Introducing Qwen-7B: Open foundation and human-aligned models (of the state-of-the-arts). URL https://github.com/QwenLM/Qwen-7B/blob/main/tech_memo.md. [3] Long-data collections. URL https://huggingface.co/datasets/togethercomputer/ Long-Data-Collections\n[4] Z.",
    "yarn-9": "Azerbayev, E.",
    "yarn-10": "Ayers, , and B. Piotrowski. Proof-pile, 2022. URLhttps://github.com/ zhangir-azerbayev/proof-pile.",
    "yarn-11": "[5] S. Black, S. Biderman, E. Hallahan, Q. Anthony, L. Gao, L. Golding, H. He, C. Leahy, K. McDonell, J. Phang, M. Pieler, U. S. Prashanth, S. Purohit, L. Reynolds, J. Tow, B. Wang, and S. Weinbach. GPT-NeoX-20B: An open-source autoregressive language model, 2022. arXiv: 2204.06745 . [6] bloc97. NTK-Aware Scaled RoPE allows LLaMA models to have extended $(8 \\mathrm{k}+)$ context size without any fine-tuning and minimal perplexity degradation., 2023. URL https://www.reddit.com/r/LocalLLaMA/comments/14lz7j5/ntkaware_ scaled_rope_allows_llama_models_to_have/. [7] bloc97. Add NTK-Aware interpolation \"by parts\" correction, 2023. URL https://github com/jquesnelle/scaled-rope/pull/1.",
    "yarn-12": "[8] C. Chen. Transformer Inference Arithmetic, 2022. URL https://kipp.ly/blog/ transformer-inference-arithmetic/\n[9] S.",
    "yarn-13": "Chen, S. Wong, L. Chen, and Y. Tian. Extending context window of large language models via positional interpolation, 2023.",
    "yarn-14": "arXiv: 2306.15595. [10] A. Chowdhery, S. Narang, J. Devlin, M. Bosma, G. Mishra, A. Roberts, P. Barham, H. W. Chung, C. Sutton, S. Gehrmann, P. Schuh, K. Shi, S. Tsvyashchenko, J. Maynez, A. Rao, P. Barnes, Y. Tay, N. Shazeer, V. Prabhakaran, E. Reif, N. Du, B. Hutchinson, R. Pope, J. Bradbury, J. Austin, M. Isard, G. Gur-Ari, P. Yin, T. Duke, A. Levskaya, S. Ghemawat, S. Dev, H. Michalewski, X. Garcia, V. Misra, K. Robinson, L. Fedus, D. Zhou, D. Ippolito, D. Luan, H. Lim, B. Zoph, A. Spiridonov, R. Sepassi, D. Dohan, S. Agrawal, M. Omernick, A. M. Dai, T. S. Pillai, M. Pellat, A. Lewkowycz, E. Moreira, R. Child, O. Polozov, K. Lee, Z. Zhou, X. Wang, B. Saeta, M. Diaz, O. Firat, M. Catasta, J. Wei, K. Meier-Hellstern, D. Eck, J. Dean, S. Petrov, and N. Fiedel. PaLM: Scaling language modeling with pathways, 2022.",
    "yarn-15": "arXiv: 2204.02311 . [11] P. Clark, I. Cowhey, O. Etzioni, T. Khot, A. Sabharwal, C. Schoenick, and O. Tafjord. Think you have solved question answering? try ARC, the AI2 Reasoning Challenge, 2018. arXiv: 1803.05457 .",
    "yarn-16": "[12] T. Computer. Redpajama: An open source recipe to reproduce llama training dataset, 2023. URLhttps://github.com/togethercomputer/RedPajama-Data\n[13] T. Dao. Flashattention-2: Faster attention with better parallelism and work partitioning, 2023. arXiv: 2307.08691. [14] emozilla. Dynamically Scaled RoPE further increases performance of long context LLaMA with zero fine-tuning, 2023. URL/https://www.reddit.com/r/LocalLLaMA/comments/ 14mrgpr/dynamically_scaled_rope_further_increases/.",
    "yarn-17": "[15] J. Gehring, M. Auli, D. Grangier, D. Yarats, and Y. N. Dauphin. Convolutional sequence to sequence learning, 2017.",
    "yarn-18": "arXiv: 1705.03122. [16] C. Han, Q. Wang, W. Xiong, Y. Chen, H. Ji, and S. Wang. LM-Infinite: Simple on-the-fly length generalization for large language models, 2023.",
    "yarn-19": "arXiv: 2308.16137. [17] D. Hendrycks, C. Burns, S. Basart, A. Zou, M. Mazeika, D. Song, and J. Steinhardt. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021. [18] L. Huang, S. Cao, N. Parulian, H. Ji, and L. Wang. Efficient attentions for long document summarization. In Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 1419-1436. Association for Computational Linguistics, June 2021. [19] Hugging Face. Open LLM Leaderboard, 2023. URL https://huggingface.co/spaces/ HuggingFaceH4/open_llm_leaderboard.",
    "yarn-20": "[20] A. Q. Jiang, A. Sablayrolles, A. Mensch, C. Bamford, D. S. Chaplot, D. de las Casas, F. Bressand, G. Lengyel, G. Lample, L. Saulnier, L. R. Lavaud, M.-A. Lachaux, P. Stock, T. L. Scao, T. Lavril, T. Wang, T. Lacroix, and W.",
    "yarn-21": "E. Sayed. Mistral 7b, 2023. [21] kaiokendev. Things I'm learning while training superhot., 2023. URL https://kaiokendev github.io/til\\#extending-context-to-8k\n[22] A.",
    "yarn-22": "Kazemnejad, I. Padhi, K. N. Ramamurthy, P. Das, and S. Reddy. The impact of positional encoding on length generalization in transformers, 2023.",
    "yarn-23": "arXiv: 2305.19466. [23] S. Lin, J. Hilton, and O. Evans. TruthfulQA: Measuring how models mimic human falsehoods. In Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 3214-3252, May 2022. [24] I. Loshchilov and F. Hutter. Decoupled weight decay regularization. In International Conference on Learning Representations, 2019. [25] A. Mohtashami and M. Jaggi. Landmark attention: Random-access infinite context length for transformers, 2023.",
    "yarn-24": "arXiv: 2305.16300. [26] A. Paszke, S. Gross, F. Massa, A. Lerer, J. Bradbury, G. Chanan, T. Killeen, Z. Lin, N. Gimelshein, L. Antiga, A. Desmaison, A. K\u00f6pf, E. Yang, Z. DeVito, M. Raison, A. Tejani, S. Chilamkurthy, B. Steiner, L. Fang, J. Bai, and S. Chintala. PyTorch: An imperative style, high-performance deep learning library. In NeurIPS, pages 8024-8035, 2019. [27] O. Press, N. Smith, and M. Lewis. Train Short, Test Long: Attention with linear biases enables input length extrapolation. In International Conference on Learning Representations, 2022.",
    "yarn-25": "[28] J. Quesnelle, E. Shippole, and \"Kaiokendev\". Llongma: Scaling rotary embeddings through linear positional interpolation. https://huggingface.co/conceptofmind/LLongMA-2-7b/.",
    "yarn-26": "2023. [29] J. W. Rae, A. Potapenko, S.",
    "yarn-27": "M. Jayakumar, C. Hillier, and T.",
    "yarn-28": "P. Lillicrap. Compressive transformers for long-range sequence modelling. In International Conference on Learning Representations, 2020. [30] A. Roberts, C. Raffel, K. Lee, M. Matena, N. Shazeer, P. J. Liu, S. Narang, W.",
    "yarn-29": "Li, and Y. Zhou. Exploring the limits of transfer learning with a unified text-to-text transformer. Technical report, Google, 2019. [31] B. Rozi\u00e8re, J. Gehring, F. Gloeckle, S. Sootla, I. Gat, X. E. Tan, Y. Adi, J. Liu, T. Remez, J. Rapin, A. Kozhevnikov, I. Evtimov, J. Bitton, M. Bhatt, C. C. Ferrer, A. Grattafiori, W. Xiong, A. D\u00e9fossez, J. Copet, F. Azhar, H. Touvron, L. Martin, N. Usunier, T. Scialom, and G. Synnaeve. Code Llama: Open foundation models for code, 2023.",
    "yarn-30": "arXiv: 2308.12950. [32] P. Shaw, J. Uszkoreit, and A. Vaswani. Self-attention with relative position representations. In Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 2 (Short Papers), pages 464-468, New Orleans, Louisiana, June 2018. Association for Computational Linguistics. [33] J. Su. Rectified rotary position embeddings. https://github.com/bojone/rerope.",
    "yarn-31": "2023. [34] J. Su, Y. Lu, S. Pan, A. Murtadha, B.",
    "yarn-32": "Wen, and Y. Liu. RoFormer: Enhanced transformer with rotary position embedding, 2022.",
    "yarn-33": "arXiv: 2104.09864. [35] Y. Sun, L. Dong, B. Patra, S. Ma, S. Huang, A. Benhaim, V. Chaudhary, X. Song, and F. Wei. A length-extrapolatable transformer, 2022. arXiv: 2212.10554. [36] M. Tancik, P. P. Srinivasan, B. Mildenhall, S. Fridovich-Keil, N. Raghavan, U. Singhal, R. Ramamoorthi, J. T. Barron, and R. Ng. Fourier features let networks learn high frequency functions in low dimensional domains. In Proceedings of the 34th International Conference on Neural Information Processing Systems, NIPS'20, Red Hook, NY, USA, 2020.",
    "yarn-34": "Curran Associates Inc. ISBN 9781713829546. [37] Together.ai. LLaMA-2-7B-32K, 2023. URL https://huggingface.co/ togethercomputer/LLaMA-2-7B-32K\n[38] H. Touvron, T. Lavril, G. Izacard, X. Martinet, M.-A. Lachaux, T. Lacroix, B. Rozi\u00e8re, N. Goyal, E. Hambro, F. Azhar, A. Rodriguez, A. Joulin, E. Grave, and G. Lample. LLaMA: Open and efficient foundation language models, 2023.",
    "yarn-35": "arXiv: 2302.13971. [39] H. Touvron, L. Martin, K. Stone, P. Albert, A. Almahairi, Y. Babaei, N. Bashlykov, S. Batra, P. Bhargava, S. Bhosale, D. Bikel, L. Blecher, C. C. Ferrer, M. Chen, G. Cucurull, D. Esiobu, J. Fernandes, J. Fu, W. Fu, B. Fuller, C. Gao, V. Goswami, N. Goyal, A. Hartshorn, S. Hosseini, R. Hou, H. Inan, M. Kardas, V. Kerkez, M. Khabsa, I. Kloumann, A. Korenev, P. S. Koura, M.-A. Lachaux, T. Lavril, J. Lee, D. Liskovich, Y. Lu, Y. Mao, X. Martinet, T. Mihaylov, P. Mishra, I. Molybog, Y. Nie, A. Poulton, J. Reizenstein, R. Rungta, K. Saladi, A. Schelten, R. Silva, E. M. Smith, R. Subramanian, X. E. Tan, B. Tang, R. Taylor, A. Williams, J. X. Kuan, P. Xu, Z. Yan, I. Zarov, Y. Zhang, A. Fan, M. Kambadur, S. Narang, A. Rodriguez, R. Stojnic, S.",
    "yarn-36": "Edunov, and T. Scialom. Llama 2: Open foundation and fine-tuned chat models, 2023. [40] A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez, L. Kaiser, and I. Polosukhin. Attention is all you need. In Advances in Neural Information Processing Systems, volume 30. Curran Associates, Inc., 2017. [41] R. Zellers, A. Holtzman, Y. Bisk, A. Farhadi, and Y. Choi. HellaSwag: Can a machine really finish your sentence? In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, 2019. [42] Y. Zhao, A. Gu, R. Varma, L. Luo, C.-C. Huang, M. Xu, L. Wright, H. Shojanazeri, M. Ott, S. Shleifer, A. Desmaison, C. Balioglu, B. Nguyen, G. Chauhan, Y. Hao, and S. Li. PyTorch FSDP: Experiences on scaling fully sharded data parallel, 2023. arXiv: 2304.11277. ## A Additional details on interpolation methods\n\n## A. 1 Short notes on the deduction of \"NTK-aware\" interpolation\n\nIn Section 3.1, we introduce a change of basis from $b$ to $b^{\\prime}$ in the definition of \"NTK-aware\" interpolation method. Here is a short note on its mathematical deduction. Recall that our goal is to spread out the interpolation pressure across the hidden dimensions using a base-change instead of scaling the frequencies by a fixed factor $s$. The property we want to guarantee is that: The lowest frequency needs to be scaled as much as linear positional scaling and the highest frequency to stay constant. We introduce a new base $b^{\\prime}$ such that the last dimension matches the wavelength of linear interpolation with a scale factor $s$. Since the original RoPE method skips odd dimensions in order to concatenate both $\\cos \\left(\\frac{2 \\pi x}{\\lambda}\\right)$ and $\\sin \\left(\\frac{2 \\pi x}{\\lambda}\\right)$ components into a single embedding, the last dimension $d \\in D$ is $|D|-2$. The new base $b^{\\prime}$ can be chosen so that\n\n$$\nb^{\\prime \\frac{|D|-2}{|D|}}=s \\cdot b^{\\frac{|D|-2}{|D|}}\n$$\n\nSolving for $b^{\\prime}$ yields\n\n$$\nb^{\\prime}=b \\cdot s^{\\frac{|D|}{|D|-2}}\n$$\n\n## A. 2 The impact of pre-softmax scaling of YaRN on perplexity\n\nIn Section 3.4, we mention the impact of the factor $t$ inside the softmax computation of attention weights. Here we fix 896 16k-token documents from RedPajama [12] and calculate their perplexity scores with different scaling $1 / \\sqrt{t}$. The result is in Figure 2. For comparison, recall that our recommended factor in this case $(s=8)$ is given by the following. $$\n\\sqrt{\\frac{1}{t}}=0.1 \\ln (s)+1 \\approx 1.208\n$$\n\n[^3]To show the impact of the factor $1 / \\sqrt{t}$ on different token positions, we cut each 16 k -token document into chunks of 2048 tokens, and further plot the mean perplexity change comparing to $t=1$ in percentages\n\n$$\n\\frac{\\operatorname{ppl}(t)-\\operatorname{ppl}(t=1)}{\\operatorname{ppl}(t=1)}\n$$\n\nof each chunk. The plot is shown in Figure 3\nTo further demonstrate the best values of $t$ across all samples over different token positions, we plot the sample counts with minimal perplexity at a given $1 / \\sqrt{t}$ for each of the 8 position segments over the 16 k-token range in Figure 4 . We observe that:\n\n- for a suitable $t$, a sample may obtain better perplexity scores across the extended context window;\n- the best value of $t$ is mostly consistent across different samples and different positions. We remark that this finding is consistent for different values of $s$ and the best value of $t$ follows our recommended formula (Eq. 22 , closely. ## B Additional tables and charts\n\n## B. 1 GovReport evaluations\n\nIn Section 4.3.1, we mention the evaluation on GovReport documents.",
    "yarn-37": "The evaluation results are detailed in Table 4 below. ## B. 2 Passkey Retrieval\n\nHere we can observe that the lowest perplexity point alone does not provide a comprehensive depiction on the \"effective context size\" that an LLM can attend to. While the Code Llama 13b model exhibits increasing perplexity above 100 k context lengths, it was still able to accurately retrieve the passey at a context length of 128 k . This suggest that while the output of Code Llama might start to degrade in quality above 100 k context size, it is still able to maintain strong retrieval capabilities. In addition, as YaRN with $s=32$ was trained for 200 more steps than YaRN with $s=16$ while having a higher passkey accuracy with similar perplexity, we hypothesize that perplexity may not be a great indicator of whether an LLM is able to attend to all tokens and does not exhaustively determine long context performance. This also suggests that the YaRN models with $s=16$ might be relatively undertrained for the passkey retrieval task. ## B. 3 Dynamic scaling on models without any fine-tuning\n\nWe first recall from Section 3.3 that the Dynamic Scaling technique is an inference-time technique that dynamically update the factor $s$ in interpolation methods such as PI, \"NTK-by-parts\" and YaRN. We choose the original Llama 2, fix a sample in GovReport and calculate its perplexity on a sliding window of 256 tokens using RoPE, Dynamic-PI and Dynamic-YaRN. Since the original maximal context length of Llama 2 is 4096, we observe that Dynamic Scaling effectively extend the inference length and Dynamic-YaRN achieves better performance than Dynamic-PI. The resulting chart is in Figure 5 . We see that\n\n- Dynamic Scaling effectively prevents the blow-up of perplexity score beyond pretrained context window;\n- Dynamic-YaRN outperforms Dynamic-PI in terms of long-range perplexity on pretrained Llama-2 without any finetuning. attention pre-softmax scaling vs final perplexity over 5616 k -token documents $(\\mathrm{s}=8)$\n\n![](https://cdn.mathpix.com/cropped/2024_09_17_bc3ef2d6a6193947023ag-16.jpg?height=565&width=1052&top_left_y=344&top_left_x=531)\n\nFigure 2: Fix $s=8$, compare the LLaMA 7 b perplexity on 89616 k-token documents over different scaling $1 / \\sqrt{t}$. The shaded area represents 1 standard deviation $(68 \\%)$. ![](https://cdn.mathpix.com/cropped/2024_09_17_bc3ef2d6a6193947023ag-16.jpg?height=627&width=1110&top_left_y=1118&top_left_x=475)\n\nFigure 3: Fix $s=8$, compare the mean of perplexity change percentages $\\frac{\\operatorname{ppl}(t)-\\operatorname{ppl}(t=1)}{\\operatorname{ppl}(t=1)}$ at different segments of token positions on 89616 k -token documents over different scaling $1 / \\sqrt{t}$. | Model <br> Size | Model <br> Name | Context <br> Window | Extension <br> Method | Perplexity |\n| ---: | :---: | ---: | :---: | :---: |\n| 7B | Together | 32 k | PI | 3.67 |\n| 7B | Code Llama | 100 k | NTK | 4.44 |\n| 7B | YaRN $(s=16)$ | 64 k | YaRN | $\\mathbf{3 . 5 9}$ |\n| 7B | YaRN $(s=32)$ | 128 k | YaRN | 3.64 |\n| 13B | Code Llama | 100 k | NTK | 4.22 |\n| 13B | YaRN $(s=16)$ | 64 k | YaRN | $\\mathbf{3 . 3 5}$ |\n| 13B | YaRN $(s=32)$ | 128 k | YaRN | 3.39 |\n\nTable 4: Sliding window perplexity $(S=256)$ of 50 long GovReport documents with a fixed context window size of 32 k\n\nThe sample counts with minimal perplexity at a given $1 / \\sqrt{ } \\mathrm{t}$ (different lines represent different position segments at the 16 k -token samples)\n\n![](https://cdn.mathpix.com/cropped/2024_09_17_bc3ef2d6a6193947023ag-17.jpg?height=554&width=1061&top_left_y=338&top_left_x=510)\n\nFigure 4: The sample counts (out of the 896 samples) with minimal perplexity at a given $1 / \\sqrt{t}$ for a given segment of token positions over the 16 k -token range. | Model <br> Size | Model <br> Name | Scaling <br> Factor $(s)$ | Context <br> Window | Training <br> Data Context | Extension <br> Method | Passkey <br> Context | Passkey <br> Accuracy |\n| ---: | :---: | ---: | ---: | :---: | :---: | :---: | :---: |\n| 7B | Together | 4 | 32 k | 32 k | PI | 32 k | $100 \\%$ |\n| 7B | Code Llama | 88.6 | 100 k | 16 k | NTK | 112 k | $94.3 \\%$ |\n| 7B | YaRN | 16 | 64 k | 64 k | YaRN | 64 k | $96.3 \\%$ |\n| 7B | YaRN | 32 | 128 k | 64 k | YaRN | 128 k | $99.4 \\%$ |\n| 13B | Code Llama | 88.6 | 100 k | 16 k | NTK | 128 k | $99.4 \\%$ |\n| 13B | YaRN | 16 | 64 k | 64 k | YaRN | 64 k | $97.5 \\%$ |\n| 13B | YaRN | 32 | 128 k | 64 k | YaRN | 128 k | $99.4 \\%$ |\n\nTable 5: Passkey retrieval performance of various models. The passkey context denotes the maximum tested context window size where the accuracy of passkey retrieval was $>=80 \\%$, and the passkey accuracy is the average accuracy of passkey retrieval on all context sizes tested that were smaller or equal than the passkey context size. The comparison between RoPE, Dynamic-PI and Dynamic-YaRN on Llama-2 7b\n\n![](https://cdn.mathpix.com/cropped/2024_09_17_bc3ef2d6a6193947023ag-17.jpg?height=616&width=1182&top_left_y=1752&top_left_x=447)\n\nFigure 5: The comparison between RoPE, Dynamic-PI and Dynamic-YaRN using Llama 2 on a long GovReport sample. This model has not been finetuned for long context. ![](https://cdn.mathpix.com/cropped/2024_09_17_bc3ef2d6a6193947023ag-18.jpg?height=619&width=1174&top_left_y=308&top_left_x=454)\n\nFigure 6: Sliding window perplexity $(S=256)$ of ten 128k Proof-pile documents truncated to evaluation context window size\n\n## B. 4 Mistral\n\nWe additionally extended the Mistral 7B v0.1 model [20], which broadly follows the Llama architecture. For Mistral we trained a 64k context window model $(s=8)$ for 1000 steps using 16k sequence lengths with a constant learning rate of $1 \\times 10^{-6}$. The model's sliding window attention size was set to the context window size, effectively disabling sliding window attention. We then trained for an additional 500 steps at $s=16$ to arrive at a 128 k context window model. The training data was a mix of the pre-train and fine-tune splits of Together Computer's Long-Data Collections [3]. We evaluated the models following the same procedure as described in 4.3.1, comparing against the base v0.1 model and MistralLite [1], an NTK-aware $(\\theta=1 \\mathrm{M}$ ) version of v0.1. The results (Figure 6 and Table 6ere consistent with those of the Llama family of models. | Model | Model | Context | Extension | Evaluation Context Window Size |  |  |  |  |\n| ---: | :---: | ---: | :---: | ---: | ---: | ---: | ---: | ---: |\n| Size | Name | Window | Method | 4096 | 8192 | 16384 | 65536 | 131072 |\n| 7B | Mistral v0.1 | 8 k | - | $\\mathbf{3 . 0 9}$ | $\\mathbf{2 . 9 6}$ | 36.8 | $>10^{3}$ | $>10^{3}$ |\n| 7B | MistralLite | 16 k | NTK | 3.26 | 3.13 | 47.3 | $>10^{3}$ | $>10^{3}$ |\n| 7B | YaRN $(s=8)$ | 64 k | YaRN | 3.18 | 3.04 | $\\mathbf{2 . 6 5}$ | $\\mathbf{2 . 2 0}$ | 57.4 |\n| 7B | YaRN $(s=16)$ | 128 k | YaRN | 3.21 | 3.08 | 2.68 | 2.24 | $\\mathbf{2 . 1 9}$ |\n\nTable 6: Sliding window perplexity ( $S=256$ ) of ten 128 k Proof-pile documents truncated to evaluation context window size\n\n\n[^0]:    *Reddit: /u/bloc97 GitHub: bloc97\n    ${ }^{\\dagger}$ Reddit: /u/emozilla X: @theemozilla GitHub: jquesnelle\n    ${ }^{\\ddagger}$ X: @EnricoShippole GitHub: conceptofmind\n\n[^1]:    ${ }^{4}$ The interpolation by linear ramp on $h$ may have alternatives, such as a harmonic mean over $\\theta_{d} / s$ and $\\theta_{d}$ converted from a linear interpolation on wavelengths.",
    "yarn-38": "The choice of $h$ here was for the simplicity of implementation, but both would work. [^2]:    ${ }^{5}$ LLongMA-2 7 b [28] is fine-tuned from Llama-2 7 b , trained at 8 k context length with PI using the RedPajama dataset [12]. [^3]:    ${ }^{6}$ We choose RedPajama because it is the open-source dataset closest to the training dataset of LLaMA as far as we are aware of.",
    "yarn-39": ""
}