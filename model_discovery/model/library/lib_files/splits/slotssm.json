{
    "slotssm-0": "# Slot State Space Models \n\nJindong Jiang*<br>Rutgers University<br>Fei Deng<br>Rutgers University\n\nGautam Singh<br>Rutgers University\n\nMinseung Lee\nKAIST\n\nSungjin Ahn*<br>KAIST\n\n\n#### Abstract\n\nRecent State Space Models (SSMs) such as S4, S5, and Mamba have shown remarkable computational benefits in long-range temporal dependency modeling. However, in many sequence modeling problems, the underlying process is inherently modular and it is of interest to have inductive biases that mimic this modular structure. In this paper, we introduce SlotSSMs, a novel framework for incorporating independent mechanisms into SSMs to preserve or encourage separation of information. Unlike conventional SSMs that maintain a monolithic state vector, SlotSSMs maintains the state as a collection of multiple vectors called slots. Crucially, the state transitions are performed independently per slot with sparse interactions across slots implemented via the bottleneck of self-attention. In experiments, we evaluate our model in object-centric video understanding, 3D visual reasoning, and video prediction tasks, which involve modeling multiple objects and their long-range temporal dependencies. We find that our proposed design offers substantial performance gains over existing sequence modeling methods. Project page is available at https://slotssms.github.io/\n\n\n## 1 Introduction\n\nState space models (SSMs) have recently emerged as a promising class of sequence models, achieving remarkable success in language modeling [17, 35, 14, 29, 5] due to their long-term memory capability and computational efficiency. Compared to Transformers [2] whose attention mechanisms also facilitate capturing long-range dependencies, SSMs are more efficient during both training and inference. Notably, SSMs offer parallel training with sub-quadratic complexity, and recurrent generation with constant cost per time step. These benefits have motivated the application of SSMs to sequences of other modalities such as audio [11] and video [6]. Typically, SSMs use a monolithic state vector to summarize all past information. This design can struggle to model sequences with modular underlying structures, which are common in physical processes and real-world dynamics. For example, physical objects largely follow independent dynamics based on their own properties, with strong interactions happening only sparsely (e.g., when objects come in close contact). A monolithic state vector would excessively entangle the dynamics of different entities, thereby hurting generalization. It could be beneficial to incorporate inductive biases for independent mechanisms [12] into the sequence modeling architecture. Recent progress in object-centric learning [25, 32, 22] has led to several methods for discovering modular object-centric structures and modeling their dynamics from videos with no or only weak supervision [23, 8, 34]. Similar to RIMs [12], they build modularity into the RNN architecture to separately keep track of the dynamics of each object. However, RNNs are prone to vanishing\n\n[^0]![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-02.jpg?height=448&width=1411&top_left_y=227&top_left_x=357)\n\nFigure 1: SlotSSMs vs existing models. (a) SlotSSMs incorporate modularity through independent state transitions and sparse interactions via self-attention. (b) Traditional SSMs utilize a monolithic state vector for all past information. (c) Multi-slot Transformer-based models offer modularity but with high computational complexity. (d) Multi-slot RNN-based models have modular states but can't parallelize training (red lock). SlotSSMs combine parallelizable training, memory efficiency, and modularity for efficient temporal modeling. gradients [30] and are not amenable to parallel training, making it hard to scale these methods up to modeling long-range effects that span hundreds of time steps. In this paper, we propose Slot State Space Models (SlotSSMs), a novel and general SSM framework that have built-in inductive biases for discovering and maintaining independent mechanisms. Instead of using monolithic state vectors, SlotSSMs maintain a set of modular slot states whose transition dynamics are designed to be largely independent, with only sparse interaction across slots introduced through the bottleneck of self-attention. The number of slots can be flexible across the layers of SlotSSMs, allowing slots to have a different level of abstraction at each layer. Furthermore, SlotSSMs inherit the strengths of SSMs, namely parallelizable training, memory efficiency, and long-range reasoning capabilities, giving it an advantage over methods based on RNNs and Transformers. Our contributions are summarized as follows. First, we propose SlotSSMs, a novel and general architecture that incorporates independent mechanisms into SSMs for modeling inherently modular physical processes. Second, we show that SlotSSMs can be specialized to solve object-centric learning tasks. It achieves comparable or better performance than existing RNN-based methods and the Transformer baseline that we develop, while being more computationallly efficient. Third, we further investigate the abilities of SlotSSMs as a general sequence modeling framework, demonstrating its advantages in video understanding and prediction, long-range reasoning, and 3D visual reasoning. ## 2 Preliminaries\n\nA state space model (SSM) defines a sequence-to-sequence mapping between the input $e_{1: T} \\in \\mathbb{R}^{T \\times D}$ and the output $\\boldsymbol{y}_{1: T} \\in \\mathbb{R}^{T \\times D}$ by the following recurrence [18, 17, 35, 29]:\n\n$$\n\\begin{aligned}\n\\boldsymbol{h}_{t} & =\\overline{\\boldsymbol{A}}_{t} \\boldsymbol{h}_{t-1}+\\overline{\\boldsymbol{B}}_{t} \\boldsymbol{e}_{t} \\\\\n\\boldsymbol{y}_{t} & =\\boldsymbol{C}_{t} \\boldsymbol{h}_{t}\n\\end{aligned}\n$$\n\nHere, $T$ denotes the sequence length, $\\boldsymbol{e}_{t}, \\boldsymbol{y}_{t} \\in \\mathbb{R}^{D}$ are the input and output vectors at each time step $t$, and $\\boldsymbol{h}_{t} \\in \\mathbb{R}^{H}$ is the hidden state that summarizes relevant information from the history $\\boldsymbol{e}_{\\leq t}$. The matrices $\\overline{\\boldsymbol{A}}_{t} \\in \\mathbb{R}^{H \\times H}, \\overline{\\boldsymbol{B}}_{t} \\in \\mathbb{R}^{H \\times D}$, and $\\boldsymbol{C}_{t} \\in \\mathbb{R}^{D \\times H}$ are constructed from learnable parameters of the SSM in specific ways that encourage modeling long-range dependencies while maintaining computational efficiency. For example, $\\overline{\\boldsymbol{A}}_{t}$ commonly takes a diagonal or block-diagonal form, with its (complex) eigenvalues distributed close to the unit circle at initialization [15, 17, 19, 16, 35, 29]. When the SSM is time-invariant, meaning $\\overline{\\boldsymbol{A}}_{t}, \\overline{\\boldsymbol{B}}_{t}, \\boldsymbol{C}_{t}$ are constant with respect to $t$, the computation of $\\boldsymbol{y}_{1: T}$ can be parallelized given $\\boldsymbol{e}_{1: T}$, leading to efficient training. Recent works [14,5] have further shown that it is possible to condition $\\overline{\\boldsymbol{A}}_{t}, \\overline{\\boldsymbol{B}}_{t}, \\boldsymbol{C}_{t}$ on the input $\\boldsymbol{e}_{t}$ without losing training efficiency. As illustrated in Figure 2 (Left), they employ learnable functions $\\overline{\\boldsymbol{A}}: \\mathbb{R}^{D} \\rightarrow \\mathbb{R}^{H \\times H}, \\overline{\\boldsymbol{B}}: \\mathbb{R}^{D} \\rightarrow$ $\\mathbb{R}^{H \\times D}, \\boldsymbol{C}: \\mathbb{R}^{D} \\rightarrow \\mathbb{R}^{D \\times H}$ to generate input-dependent matrices $\\overline{\\boldsymbol{A}}_{t}, \\overline{\\boldsymbol{B}}_{t}, \\boldsymbol{C}_{t}$ :\n\n$$\n\\overline{\\boldsymbol{A}}_{t}=\\overline{\\boldsymbol{A}}\\left(\\boldsymbol{e}_{t}\\right), \\quad \\overline{\\boldsymbol{B}}_{t}=\\overline{\\boldsymbol{B}}\\left(\\boldsymbol{e}_{t}\\right), \\quad \\boldsymbol{C}_{t}=\\boldsymbol{C}\\left(\\boldsymbol{e}_{t}\\right)\n$$\n\n![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-03.jpg?height=435&width=1136&top_left_y=246&top_left_x=489)\n\nFigure 2: SSM vs SlotSSM. SlotSSM encourages modularity by maintaining a set of separate slot state representations, each updated independently using separate transition matrices and input matrices, allowing for more efficient and scalable modeling of complex sequences with inherent modular structures. This brings the ability to selectively emphasize or ignore certain information based on the input, leading to more flexible sequence modeling. Because the (block-)diagonal structure of $\\overline{\\boldsymbol{A}}_{t}$ limits information propagation across dimensions, SSMs are typically interleaved with mixing layers such as linear projections or MLPs to mix information across dimensions. Mixing can also be promoted by using dense $\\overline{\\boldsymbol{B}}_{t}$ and $\\boldsymbol{C}_{t}$ matrices. ## 3 Slot State Space Models (SlotSSMs)\n\nStandard SSMs use monolithic vectors for inputs, outputs, and hidden states, and mix information across all dimensions. This lack of modularity could cause difficulties in modeling real-world dynamics such as object interactions, where the underlying process consists of multiple entities and is inherently modular [12]. In this section, we present slot state space models (SlotSSMs), a new class of SSMs with built-in inductive biases for encouraging and preserving modularity. Our key idea is to maintain a set of separate slot state representations (called slots in short), and process the slots independently and symmetrically. To do this, we format the input vector $\\boldsymbol{e}_{t} \\in \\mathbb{R}^{D}$ as a concatenation of $K$ slot representations $\\left\\{s_{t}^{k} \\in \\mathbb{R}^{D_{s}}\\right\\}_{k=1}^{K}$, where $D_{s}=D / K$. The output $\\boldsymbol{y}_{t} \\in \\mathbb{R}^{D}$ and hidden state $\\boldsymbol{h}_{t} \\in \\mathbb{R}^{H}$ are formatted similarly:\n\n$$\n\\boldsymbol{e}_{t}=\\operatorname{concat}\\left[\\boldsymbol{s}_{t}^{1}, \\ldots, \\boldsymbol{s}_{t}^{K}\\right], \\quad \\boldsymbol{y}_{t}=\\operatorname{concat}\\left[\\boldsymbol{y}_{t}^{1}, \\ldots, \\boldsymbol{y}_{t}^{K}\\right], \\quad \\boldsymbol{h}_{t}=\\operatorname{concat}\\left[\\boldsymbol{h}_{t}^{1}, \\ldots, \\boldsymbol{h}_{t}^{K}\\right]\n$$\n\nwhere $\\boldsymbol{y}_{t}^{k} \\in \\mathbb{R}^{D_{s}}$ and $\\boldsymbol{h}_{t}^{k} \\in \\mathbb{R}^{H_{s}}$ are the output and the hidden state corresponding to slot $s_{t}^{k}$, with $H_{s}=H / K$. In this section, we focus on preserving modularity when the input already complies with the slot format. When coupled with a slot encoder, the SlotSSM can help encourage the emergence of modularity from unstructured inputs such as video frames, as we will discuss in Section 4. To preserve modularity, we make sure that SlotSSM do not mix information across different slots. More precisely, the hidden state $\\boldsymbol{h}_{t}^{k}$ and output $\\boldsymbol{y}_{t}^{k}$ only integrate information from the history of the corresponding input slot $s_{\\leq t}^{k}$. As illustrated in Figure 2 (Right), this can be achieved by making $\\overline{\\boldsymbol{A}}_{t}, \\overline{\\boldsymbol{B}}_{t}, \\boldsymbol{C}_{t}$ block-diagonal, where the $k$-th block is only conditioned on the $k$-th slot:\n\n$$\n\\overline{\\boldsymbol{A}}_{t}=\\operatorname{diag}\\left(\\left\\{\\overline{\\boldsymbol{A}}\\left(\\boldsymbol{s}_{t}^{k}\\right)\\right\\}_{k=1}^{K}\\right), \\quad \\overline{\\boldsymbol{B}}_{t}=\\operatorname{diag}\\left(\\left\\{\\overline{\\boldsymbol{B}}\\left(\\boldsymbol{s}_{t}^{k}\\right)\\right\\}_{k=1}^{K}\\right), \\quad \\boldsymbol{C}_{t}=\\operatorname{diag}\\left(\\left\\{\\boldsymbol{C}\\left(\\boldsymbol{s}_{t}^{k}\\right)\\right\\}_{k=1}^{K}\\right)\n$$\n\nImplementation details. The SlotSSM formulation in Equation 4 is general and can accommodate various choices of the $\\overline{\\boldsymbol{A}}, \\overline{\\boldsymbol{B}}, \\boldsymbol{C}$ functions. In our implementation, we adopt those from Mamba [14]. Specifically, $\\overline{\\boldsymbol{A}}\\left(s_{t}^{k}\\right), \\overline{\\boldsymbol{B}}\\left(s_{t}^{k}\\right), \\boldsymbol{C}\\left(s_{t}^{k}\\right)$ are themselves block-diagonal matrices with $D_{s}$ blocks, one for each slot dimension. The $i$-th blocks $\\overline{\\boldsymbol{A}}^{(i)}\\left(s_{t}^{k}\\right) \\in \\mathbb{R}^{N \\times N}$ and $\\overline{\\boldsymbol{B}}^{(i)}\\left(s_{t}^{k}\\right) \\in \\mathbb{R}^{N \\times 1}$ are obtained by discretizing their continuous-time counterparts $\\boldsymbol{A}^{(i)}$ and $\\boldsymbol{B}^{(i)}\\left(s_{t}^{k}\\right)$ using the time step $\\Delta^{(i)}\\left(s_{t}^{k}\\right)$ and the zero-order hold $(\\mathrm{ZOH})$ rule:\n\n$$\n\\overline{\\boldsymbol{A}}^{(i)}\\left(s_{t}^{k}\\right), \\overline{\\boldsymbol{B}}^{(i)}\\left(s_{t}^{k}\\right)=\\mathrm{ZOH}\\left(\\Delta^{(i)}\\left(s_{t}^{k}\\right), \\boldsymbol{A}^{(i)}, \\boldsymbol{B}^{(i)}\\left(s_{t}^{k}\\right)\\right), \\quad i=1, \\ldots, D_{s}\n$$\n\n![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-04.jpg?height=549&width=1266&top_left_y=235&top_left_x=424)\n\nFigure 3: Sequence modeling architecture with SlotSSM. SlotSSMs are hybrid models combining SSMs and attention mechanisms. Each layer consists of a Slot Encoder, SlotSSM, and Slot Mixer. The Slot Encoder uses a Transformer with cross-attention to extract slots from inputs. The SlotSSM independently updates these slots with separate state transitions. The Slot Mixer introduces interactions between slots through self-attention. Here, $N=H_{s} / D_{s}$ is the hidden state size per slot dimension, $\\boldsymbol{A}^{(i)} \\in \\mathbb{R}^{N \\times N}$ is an input-independent learnable model parameter, and $\\Delta^{(i)}: \\mathbb{R}^{D} \\rightarrow \\mathbb{R}, \\boldsymbol{B}^{(i)}: \\mathbb{R}^{D} \\rightarrow \\mathbb{R}^{N \\times 1}$ are learnable functions implemented as neural networks. Similarly, the $i$-th block $\\boldsymbol{C}^{(i)}\\left(s_{t}^{k}\\right)$ is computed by the learnable function $\\boldsymbol{C}^{(i)}: \\mathbb{R}^{D} \\rightarrow \\mathbb{R}^{1 \\times N}$. For simplicity and efficiency, $\\boldsymbol{B}^{(i)}$ and $\\boldsymbol{C}^{(i)}$ are shared across all $1 \\leq i \\leq D_{s}$, and $\\boldsymbol{A}^{(i)}$ is parameterized as a diagonal matrix. ## 4 Modular Sequence Modeling with SlotSSM\n\nThe SlotSSM proposed in Section 3 are designed to preserve modularity when the input is already separated into slots. In this section, we complement SlotSSM with a slot encoder that extracts slot representations from unstructured inputs (Section 4.1), and a slot mixer that introduces sparse interactions across slots (Section 4.2). We then present a sequence modeling architecture (Section 4.3) that encourages discovery of underlying modular processes by stacking these components. ### 4.1 Slot Encoder\n\nWe assume the unstructured input $x_{t}$ at each time step $t$ is represented as a sequence of $M$ tokens:\n\n$$\n\\boldsymbol{x}_{t}=\\left(\\boldsymbol{x}_{t}^{1}, \\ldots, \\boldsymbol{x}_{t}^{M}\\right), \\quad \\boldsymbol{x}_{t}^{m} \\in \\mathbb{R}^{D_{x}}\n$$\n\nFor example, image inputs can be represented as CNN feature maps ( $M$ is the number of cells in the feature map), or as embeddings of non-overlapping image patches ( $M$ is the number of patches), as proposed in ViT [7]. To extract $K$ slot representations from $\\boldsymbol{x}_{t}$, we use $K$ learnable CLS tokens $\\left\\{\\mathrm{CLS}_{t}^{k} \\in \\mathbb{R}^{D_{x}}\\right\\}_{k=1}^{K}$ as queries and perform cross-attention with the input tokens through a Transformer [40]:\n\n$$\n\\left\\{\\operatorname{CLS}_{t}^{k}\\right\\}_{k=1}^{K} \\leftarrow \\text { Transformer }\\left(\\mathrm{q}=\\left\\{\\mathrm{CLS}_{t}^{k}\\right\\}_{k=1}^{K}, \\mathrm{kv}=\\left\\{\\boldsymbol{x}_{t}^{m}\\right\\}_{m=1}^{M}\\right)\n$$\n\nThe Transformer also includes self-attention within the CLS tokens, allowing them to communicate with each other and capture information from different parts of the input, thereby facilitating the emergence of modularity. The slot representations are then obtained by applying a linear projection to the corresponding output embeddings of the CLS tokens:\n\n$$\ns_{t}^{k}=\\operatorname{Linear}\\left(\\operatorname{CLS}_{t}^{k}\\right), \\quad k=1, \\ldots, K\n$$\n\n### 4.2 Slot Mixer\n\nThe slot encoder obtains slot decomposition purely based on single time steps, which can be suboptimal. In addition, the SlotSSM processes each slot fully independently, making it hard to correct\nmistakenly decomposed slots or model interarctions across slots. To resolve both issues, we interleave SlotSSM with slot mixers. The slot mixer consists of two residual blocks, and is applied to the outputs $\\left\\{\\boldsymbol{y}_{t}^{k}\\right\\}_{k=1}^{K}$ of the SlotSSM. The first block introduces interaction across slots through self-attention [40], whereas the second block uses MLP to further process the gathered information within each slot:\n\n$$\n\\begin{aligned}\n\\left(\\boldsymbol{y}_{t}^{1}, \\ldots, \\boldsymbol{y}_{t}^{K}\\right) & \\leftarrow\\left(\\boldsymbol{y}_{t}^{1}, \\ldots, \\boldsymbol{y}_{t}^{K}\\right)+\\operatorname{SelfAttn}\\left(\\operatorname{LN}\\left(\\boldsymbol{y}_{t}^{1}\\right), \\ldots, \\operatorname{LN}\\left(\\boldsymbol{y}_{t}^{K}\\right)\\right) \\\\\n\\left(\\boldsymbol{y}_{t}^{1}, \\ldots, \\boldsymbol{y}_{t}^{K}\\right) & \\leftarrow\\left(\\boldsymbol{y}_{t}^{1}, \\ldots, \\boldsymbol{y}_{t}^{K}\\right)+\\left(\\operatorname{MLP}\\left(\\operatorname{LN}\\left(\\boldsymbol{y}_{t}^{1}\\right)\\right), \\ldots, \\operatorname{MLP}\\left(\\operatorname{LN}\\left(\\boldsymbol{y}_{t}^{K}\\right)\\right)\\right)\n\\end{aligned}\n$$\n\nHere, $\\mathrm{LN}(\\cdot)$ denotes layer normalization [1]. Because $\\boldsymbol{y}_{t}^{k}$ carries information from the entire history of each slot, it provides the opportunity to refine the slot representations based on temporal dynamics. ### 4.3 Sequence Modeling Architecture\n\nWe now present a generic architecture for modeling sequences with modular underlying processes. Given a sequence of unstructured inputs $\\boldsymbol{x}_{1: T}$, our goal is to obtain a set of $K_{l}$ modular representations at each time step $t$ and at each layer $l$ that summarizes all underlying processes up to time $t$. In general, the number of slots $K_{l}$ at each layer can be different, potentially allowing fewer but more abstract slots at higher layers. To accommodate this, we insert a slot encoder wherever the number of slots changes, and repurpose it to extract a different number of slots from existing slot representations. This is achieved by treating the slots output from the previous layer as keys and values in Equation 7 When the number of slots does not change, we can simply copy the slots from the previous layer. As shown in Figure 3, our proposed architecture stacks the (optional) slot encoder, SlotSSM, and slot mixer together at each layer. We use the subscript ' $\\mid l$ ' to denote the relevant variables at layer $l$. For notational convenience, we denote the output of slot mixer at layer $l-1$ by $\\left\\{\\boldsymbol{x}_{t \\mid l-1}^{k}\\right\\}_{k=1}^{K_{l-1}}$. This serves as the input to layer $l$. We use $\\left\\{\\boldsymbol{x}_{t \\mid 0}^{k}\\right\\}_{k=1}^{K_{0}}$ to denote the input in Equation 6 , where $K_{0}:=M$. The computation at each layer $l=1, \\ldots, L$ can then be summarized as follows:\n\n$$\n\\begin{aligned}\n\\left\\{\\boldsymbol{s}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}} & =\\operatorname{SlotEncoder}\\left(\\left\\{\\boldsymbol{x}_{t \\mid l-1}^{k}\\right\\}_{k=1}^{K_{l-1}}\\right) \\\\\n\\left\\{\\boldsymbol{y}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}},\\left\\{\\boldsymbol{h}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}} & =\\operatorname{SlotSSM}\\left(\\left\\{\\boldsymbol{s}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}},\\left\\{\\boldsymbol{h}_{t-1 \\mid l}^{k}\\right\\}_{k=1}^{K_{l}}\\right) \\\\\n\\left\\{\\boldsymbol{x}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}} & =\\operatorname{SlotMixer}\\left(\\left\\{\\boldsymbol{y}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}}\\right)\n\\end{aligned}\n$$\n\nThe final output $\\left\\{\\boldsymbol{x}_{t \\mid L}^{k}\\right\\}_{k=1}^{K_{L}}$ can be used for various tasks, such as predicting the next observation and the properties of underlying processes (e.g., position, velocity). ## 5 Object-Centric Learning with SlotSSM\n\nIn this section, we present a concrete example of adapting the generic sequence modeling architecture proposed in Section 4 to solve a specific task. We consider the task of object-centric representation learning from unannotated videos of interacting objects, a typical example of sequences with modular underlying structures. The goal is to obtain a representation for each individual object that captures relevant attributes such as object position, size, shape, color, etc. without any object-level annotation. ### 5.1 Object-Centric SlotSSMs (OC-SlotSSMs)\n\nInspired by previous works [25, 43], we make slight modifications to our sequence modeling architecture to facilitate the discovery of modular structures. We call the resulting model OC-SlotSSMs. First, we use the same number of slots across all layers. It is thus unnecessary to have a slot encoder per layer. However, we find it helpful to still have it, but in another form that encourages iterative refinement of the slots. Specifically, we use the slots output from the previous layer $\\left\\{\\boldsymbol{x}_{t \\mid l-1}^{k}\\right\\}_{k=1}^{K}$ as queries, and provide the input tokens $\\left\\{\\boldsymbol{x}_{t \\mid 0}^{m}\\right\\}_{m=1}^{M}$ as keys and values. Second, we introduce competition among slots in the attention layers of the slot encoder. We achieve this by using inverted attention [38, 43], which is essentially cross attention with the Softmax operation performed over the\nqueries instead of the keys. This has the effect of softly assigning each input token to a slot, thereby promoting modularity. The computation at each layer $l=1, \\ldots, L$ can be summarized as follows:\n\n$$\n\\begin{aligned}\n\\left\\{\\boldsymbol{s}_{t \\mid l}^{k}\\right\\}_{k=1}^{K} & =\\operatorname{InvAttn}\\left(\\mathrm{q}=\\left\\{\\boldsymbol{x}_{t \\mid l-1}^{k}\\right\\}_{k=1}^{K}, \\mathrm{kv}=\\left\\{\\boldsymbol{x}_{t \\mid 0}^{m}\\right\\}_{m=1}^{M}\\right) \\\\\n\\left\\{\\boldsymbol{y}_{t \\mid l}^{k}\\right\\}_{k=1}^{K},\\left\\{\\boldsymbol{h}_{t \\mid l}^{k}\\right\\}_{k=1}^{K} & =\\operatorname{SlotSSM}\\left(\\left\\{\\boldsymbol{s}_{t \\mid l}^{k}\\right\\}_{k=1}^{K},\\left\\{\\boldsymbol{h}_{t-1 \\mid l}^{k}\\right\\}_{k=1}^{K}\\right) \\\\\n\\left\\{\\boldsymbol{x}_{t \\mid l}^{k}\\right\\}_{k=1}^{K} & =\\operatorname{SlotMixer}\\left(\\left\\{\\boldsymbol{y}_{t \\mid l}^{k}\\right\\}_{k=1}^{K}\\right)\n\\end{aligned}\n$$\n\nWe note that the queries in the first inverted attention layer are the learnable CLS tokens $\\left\\{\\operatorname{CLS}_{t \\mid 0}^{k}\\right\\}_{k=1}^{K}$. ### 5.2 Training Pipeline\n\nFollowing previous works in object-centric learning [25, 23, 34], we adopt an auto-encoding training pipeline. Given a sequence of video frames $\\left\\{\\boldsymbol{o}_{t} \\in \\mathbb{R}^{H} \\times W \\times 3\\right\\}_{t=1}^{T}$, we obtain the input $\\boldsymbol{x}_{t \\mid 0}$ to our sequence modeling architecture by applying a CNN encoder to each frame $\\boldsymbol{o}_{t}$ and adding a positional embedding for each feature map cell. The output slots $\\left\\{\\boldsymbol{x}_{t \\mid L}^{k}\\right\\}_{k=1}^{K}$ are each decoded into an object image $\\hat{\\boldsymbol{o}}_{t}^{k} \\in \\mathbb{R}^{H \\times W \\times 3}$ and an alpha mask $\\boldsymbol{\\alpha}_{t}^{k} \\in \\mathbb{R}^{H \\times W \\times 1}$ by a spatial broadcast decoder [42]. The final reconstruction $\\hat{\\boldsymbol{o}}_{t} \\in \\mathbb{R}^{H \\times W \\times 3}$ is given by the alpha-composition of the object images:\n\n$$\n\\hat{\\boldsymbol{o}}_{t}^{k}, \\boldsymbol{\\alpha}_{t}^{k}=\\operatorname{Decoder}\\left(\\boldsymbol{x}_{t \\mid L}^{k}\\right), \\quad \\hat{\\boldsymbol{o}}_{t}=\\sum_{k=1}^{K} \\frac{\\exp \\left(\\boldsymbol{\\alpha}_{t}^{k}\\right)}{\\sum_{j=1}^{K} \\exp \\left(\\boldsymbol{\\alpha}_{t}^{j}\\right)} \\cdot \\hat{\\boldsymbol{o}}_{t}^{k}\n$$\n\nThe training objective is to minimize the reconstruction $\\operatorname{error} \\mathcal{L}=\\frac{1}{T} \\sum_{t=1}^{T}\\left\\|\\hat{\\boldsymbol{o}}_{t}-\\boldsymbol{o}_{t}\\right\\|_{2}^{2}$. ## 6 Related Work\n\nState Space Models (SSMs). Popularized by S4 [17], SSMs have attracted growing interest in language modeling and as a sequence modeling framework in general. The original S 4 follows the HiPPO theory [15] to parameterize and initialize the state transition matrices, which is quite mathematically involved. Most recent works have proposed simplified versions that use diagonal transition matrices [19, 16, 35] and pure RNN formulation (i.e., without reliance on ODE discretization) [20, 29, 5]. Several works have proposed hybrid architectures of SSMs and Transformers to incorporate their complementary strengths [50, 27, 9, 21, 14]. In addition to language modeling, SSMs have been applied to various domains, including time-series generation [48], audio generation [11], visual classificiation and generation [28, 24, 21, 41, 49, 47], and reinforcement learning [4, 26, 6, 31]. Our study introduces the first SSM with inductive biases for modeling inherently modular processes. Object-Centric Learning. Object-centric learning seeks to discover modular structures and independent mechanisms [12] such as objects and their relations from multi-object images and videos with weak or no supervision. Recent works are predominantly based on the Slot Attention [25] model, which uses a GRU [3] and competitive attention mechanisms to iteratively refine slot representations [32, 34, 23, 8, 45, 33, 22, 46]. However, GRUs and RNNs in general are prone to vanishing gradient issues [30], and the training must be done in a sequential way. These weaknesses render them incapable of scaling up to long-range videos. Our SlotSSMs framework can be specialized to solve object-centric learning tasks. With SSMs at its core, SlotSSMs enjoy parallelizable training and remarkable long-term memory abilities. As a general framework, SlotSSMs can also tackle other tasks such as long-range visual reasoning. ## 7 Experiments\n\nWe present an extensive evaluation of our models across a variety of tasks. Section 7.1 illustrates the need for modular latent states through a multi-object video prediction task. Section 7.2 demonstrates the advantages of SlotSSMs over Transformers and RNNs using a newly proposed long-context reasoning benchmark. Section 7.3 investigates the object-centric learning capabilities of OC-SlotSSMs. Finally, Section 7.4 showcases the 3D visual reasoning capabilities using the CATER benchmark [10]. ![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-07.jpg?height=507&width=1404&top_left_y=233&top_left_x=359)\n\nFigure 4: Multi-Object Video Prediction Task. Left: Generated video frames at every second step, showing 10 of the 20 total frames generated. Green color indicates ground-truth and red color indicates predictions. Right: MSE over a 20-frame autoregressive rollout, given 10 context frames. SlotSSM demonstrates its efficiency in modeling multi-object dynamics. ### 7.1 Multi-Object Video Prediction\n\nWe begin with a multi-object video modeling task to demonstrate the benefit of incorperating modularity into state space. Dataset and Task. We utilize the bouncing balls video dataset introduced by [39]. This dataset comprises videos of white balls bouncing off each other within an empty background window. Each ball is initialized with random positions, velocities, and masses, which govern the physical behavior of their interactions. The task is to perform conditional video generation, specifically $p\\left(\\mathbf{x}_{T+1: T+W} \\mid \\mathbf{x}_{1: T}\\right)$. This task is inherently modular as it requires models to maintain memory of each object's physical attributes and to understand the interaction rules of moving objects. Experimental Setup. We train the model using teacher-forcing on video sequences of 20 frames with binary cross-entropy loss as the training objective. During testing, we provide $T=10$ context frames and the model performs an autoregressive rollout of $W=20$ frames, using its own predictions.",
    "slotssm-1": "We evaluate model performance using Mean Squared Error (MSE) loss between the predicted and ground truth images. Models. We employ the SlotSSM architecture described in Section 4.3, and we adopt the Mamba Block [14] as the SSM implementation for both SlotSSM and baseline models. We use the same number of slots for all layers, and thus only apply the Slot Encoder at the first layer. We compare our model against the following baselines:\n\n1. Single State SSM: Shares the same architecture as our model but uses a monolithic state. 2. Single State SSM (Split): A Single State SSM paired with multi-slot encoder and decoder. Slots are concatenated and provided to the SSM, then split into multiple slots for the decoder. 3. RIM [12]: A slot-based RNN model that uses separate RNN weights for each slot and introduces sparse slot update and interaction based on input attention values. 4. Transformer: Vanilla Transformer model with single input embedding at each time step. 5. SlotTransformer: Transformer model with multiple input slots at each time step, analogous to SlotSSMs. All models share the same encoder and decoder architectures. For the encoder, we use the Transformer encoder described in Section 4.1, with a single CLS token for single-state models. The decoder consists of 3 Transformer layers with self-attention and cross-attention blocks, where patch-wise positional embeddings self-attend and then serve as queries to attend to the slots. For all slot-based models, we use 6 slots. For RIM, we set $k=4$ for top-k active modules as described in the original paper. We carefully design hyperparameters to match model sizes across baselines, with one exception: RIM inherently requires a larger model size due to separate RNN weights per slot. Additional implementation detials can be found in Appendix B\n(a) Long-Context Construction\n\n![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-08.jpg?height=334&width=760&top_left_y=299&top_left_x=368)\n\nInput Sequence (b) Model Efficiency\n\n![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-08.jpg?height=358&width=632&top_left_y=290&top_left_x=1126)\n\nFigure 5: Long-Context Construction and Model Efficiency in the Blinking Color Balls Benchmark. Left: We construct long-sequence inputs by patchifying the context images. Right: Comparison of model inference latency with batch size 6 . SlotSSM demonstrates computational efficiency for long-sequence processing tasks. Results. Figure 4 presents the comparative performance of our models. SlotSSM outperforms all baselines, including a marginal improvement over SlotTransformer. The substantial performance gap between SlotSSM and Single State SSM highlights the importance of maintaining modular slot states for effective multi-object dynamics learning. The comparison between Transformer and SlotTransformer also corroborates this finding. Notably, SlotSSM also significantly outperforms Single State SSM (Split) which uses the same modular encoder and decoder. This result highlights that modularity in temporal modeling-the core contribution of SlotSSM-is the most critical factor for the improved performance. Additionally, the RNN-based multi-slot model, RIM, performs better than other single-state baselines but still lags significantly behind SlotSSM and SlotTransformer. ### 7.2 Long-Context Reasoning\n\nWe now evaluate the long-context reasoning capabilities of SlotSSM. To enable a rigorous assessment in a multi-object setting, we propose the novel Blinking Color Balls Benchmark. Blinking Color Balls Benchmark. The benchmark comprises two variants: the Earliest Color and the Most Frequent Color versions. Both variants consist of episodes of image sequence $\\mathbf{x}_{1: T}$, partitioned into context images $\\mathbf{x}_{1: T-1}$ and a target image $\\mathbf{x}_{T}$. For each timestep in $\\mathbf{x}_{1: T-1}$, all bouncing balls are initially colored white. Then, one ball is randomly selected and assigned a non-white color, which is randomly sampled from a set of 5 predefined colors The coloring of balls in the target image $\\mathbf{x}_{T}$ depends on the variant:\n\n- Earliest Color: Each ball's color is determined by the earliest non-white color assigned to it in the context sequence. If a ball is never assigned a non-white color, it remains white. - Most Frequent Color: Each ball's color is determined by the most frequently assigned non-white color across all context frames. In case of ties, the earliest color is used. If a ball is never assigned a non-white color, it remains white. To transform the dataset into a long-range reasoning task, we patchify each context image into non-overlapping patches and provide the flattened patch sequence as input to the model. We present this process in Figure 5(a). Specifically, each context image is divided into $P \\times P$ patches, which are then flattened into a sequence of length $P^{2}$. For a context length of $T-1$, this results in a total input sequence length of $L=(T-1) \\times P^{2}$. Consequently, the models must identify and track objects from partial views provided by the patches, while simultaneously remembering and counting the color assignments for each object, making the task highly challenging and non-trivial. The final task is to predict the target image given this long sequential input. Experimental Setup. We evaluate models on Earliest Color with $T=6$ and Most Frequent Color with $T \\in\\{6,11\\}$, and we employ patch sizes of $P \\in\\{4,8,16\\}$. The resulting input sequence lengths are $L \\in\\{80,160,320,640,1280,2560\\}$. Note that Most Frequent Color with $T=11$ setting poses a greater challenge because the increased context length leads to more color assignments, requiring the models to exhibit stronger memorization and reasoning capabilities. ![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-09.jpg?height=398&width=1391&top_left_y=242&top_left_x=365)\n\nFigure 6: Long-Context Reasoning in Blinking Balls Benchmark. SlotSSM maintains consistent performance across sequence lengths from 80 to 2560, whereas baseline models show degraded performance or fail to complete training due to high memory and computational requirements. Models. We employ the same encoder, decoder, and the SlotSSM architectures as described in Section 7.1 For slot encoding, each image patch is treated as a small image and processed by the transformer slot encoder. The resulting slots from the last time step are then provided to the transformer decoder to predict the full target image. We compare our SlotSSM against several baselines: Single State SSM, SlotTransformer, and RIM. Additionally, we introduce a novel multi-slot design called SlotRNNs, which shares model weights across the RNNs of each slot and uses self-attention layers between time steps as the slot mixer. SlotRNNs can be viewed as a special case of RIMs, with shared RNN weights across states and dense state updates instead of sparse state updates. Empirically, we find that SlotRNNs exhibit more stable training and improved performance compared to RIMs. For a fair comparison, all slot-based models use 6 slots. We also carefully match the model size as in Section 7.1\n\nResults. Figure 6 presents the target image prediction error. SlotSSM demonstrates clear advantages over Single State SSM, SlotRNN, and RIM across all sequence lengths. For shorter sequences (length 80 and 160), Single State SSM and SlotRNN maintain relatively low error rates. However, their performance degrades significantly for sequences longer than 320 frames. Surprisingly, despite its modular architecture, RIM fails to generalize on any sequence length. We hypothesize that the separate weights for each slot in RIMs hinder optimization, and this issue is partially addressed by our proposed baseline SlotRNNs, which share weights across slots while maintaining modularity. SlotTransformer performs competitively for sequences up to 640 frames, which benefits from their direct access to all historical inputs. Nonetheless, SlotSSM exhibits superior long-range reasoning capabilities, particularly for sequences of 1280 and 2560 frames, where other models can not run due to memory and computational constraints. Figure 5(b) highlights the computational efficiency of SlotSSM. While SlotTransformer achieves similar inference latency for shorter sequences, their performance quickly declines as the sequence length increases due to its quadratic computational complexity. In contrast, SlotSSM maintains a stable and efficient inference process across all sequence lengths. Note that due to the high memory consumption of SlotTransformer, a batch size of 6 is used to evaluate the inference latency of all models. We include qulitative comparisons in Appendix A.3 to offer further insights into these models' strengths and weaknesses. ### 7.3 Unsupervised Object-Centric Learning\n\nIn this section, we evaluate the performance of the Object-Centric SlotSSMs (OC-SlotSSM) variant in unsupervised object-centric representation learning. Datasets. We evaluate the OC-SlotSSM model using the MOVi video dataset [13], specifically focusing on the MOVi-A and MOVi-B subsets. Both datasets contain videos of up to 10 objects moving in a 3 D environment. MOVi-B introduces additional complexity compared to $\\mathrm{MOVi}-\\mathrm{A}$ by incorporating a wider variety of object types and multi-colored backgrounds. Tasks. Following the evaluation protocol in prior object-centric learning works [25, 22], we evaluate the models on two downstream tasks: unsupervised object segmentation and attribute prediction. For the segmentation task, we report the FG-ARI and mIoU metrics on video sequences. In the attribute\n\n![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-10.jpg?height=275&width=1393&top_left_y=242&top_left_x=364)\n\nFigure 7: Object-Centric Learning Results. Left: Qualitative comparison of segmentation masks on MOVi-A. OC-SlotSSM demonstrate less object spliting and better boundary adherence. Right: Quantitative evaluation on unsupervised object segmentation and attribute prediction. OC-SlotSSM outperforms SAVi on most metrics. prediction task, we measure the quality of representations by inferring object properties from them. For discrete attributes such as object shape, we report the prediction accuracy, while for continuous attributes like object position, we use the $R^{2}$ metric. Models. We compare OC-SlotSSM against SAVi [23], an RNN-based object-centric learning approach. Both models use a CNN encoder to extract image features as model input tokens $\\left\\{\\boldsymbol{x}_{t \\mid 0}^{m}\\right\\}_{m=1}^{M}$, which are processed by their respective attention mechanisms (inverted attention in OC-SlotSSM and slot attention in SAVi ) to produce slots. The slots are then used to reconstruct the image and generate segmentation masks for each object using a spatial broadcast decoder, with reconstruction as the training objective. For unsupervised object segmentation, we directly use the object masks obtained during unsupervised training. To evaluate attribute prediction, we match the slots to object IDs using Hungarian matching based on the segmentation masks, and then employ linear heads and 2-layer MLPs to predict discrete and continuous attributes, respectively, where the slots remain frozen.",
    "slotssm-2": "Results. Figure 7 presents the results. The results demonstrate that OC-SlotSSM consistently outperforms SAVi in unsupervised object segmentation on both $\\mathrm{MOVi}-\\mathrm{A}$ and $\\mathrm{MOVi}-\\mathrm{B}$. The qualitative comparison (Figure 7, left) shows that OC-SlotSSM generates masks with tighter object boundaries and fewer object splitting, which also leads to improved attribute prediction accuracy (Figure 7 right). Furthermore, our experiments reveal that OC-SlotSSM exhibits superior stability during training compared to SAVi , which tends to collapse into a single slot representing the entire scene when trained for an extended period. This collapse is not reflected in the validation loss, so we apply early stopping based on manual inspection. In contrast, OC-SlotSSM does not suffer from this instability, demonstrating its robustness in learning object-centric representations. ### 7.4 3D Visual Reasoning\n\nFinally, we explore the application of SlotSSM and OC-SlotSSM to 3D visual reasoning tasks using the CATER benchmark [10].",
    "slotssm-3": "CATER Benchmark. CATER consists of 300-frame video episodes of objects moving around in a 3D environment. The movement of the objects can lead to partial occlusions and even complete coverage of smaller objects by larger ones. The primary task is snitch localization, which involves predicting the location of a golden snitch at the final frame. Note that the snitch is always present but may be invisible due to occlusion or coverage by other objects. To solve this task, models must be able to reason about the snitch's location based on its last known position and the movement of other objects in a 3D space. Success in this task would demonstrate the models' capacity for complex visual reasoning and their potential for application in real-world dynamic 3D environments.",
    "slotssm-4": "Experimental Setup. We consider two experiment settings: direct training and pre-training + fine-tuning. In the direct training setting, models are trained end-to-end on the snitch localization task without any auxiliary objectives. In the pre-training + fine-tuning setting, models are first pre-trained on video-only inputs using a reconstruction objective, and then fine-tuned on the task-specific signal. During pre-training, we randomly sample 32 frames, which are not necessarily consecutive, from the original 300 -frame videos as input to the model. For direct training and fine-tuning, we first split the input sequence into 50 non-overlapping segments, each containing 6 frames. Then, from each segment, we randomly select one frame, resulting in a subsampled sequence of 50 frames that spans\n\nTable 1: Performance on CATER Snitch Localization Task. | Model | No Pre-train |  |  | Pre-train |  |\n| :--- | :---: | :---: | :---: | :---: | :---: |\n|  | Top-1 Acc (\\%) | Top-5 Acc (\\%) | Top-1 Acc (\\%) | Top-5 Acc (\\%) |  |\n| Single State SSM | 10.27 | 27.21 |  | 41.15 | 65.70 |\n| SlotTransformer | 41.09 | 62.24 |  | 49.21 | 70.24 |\n| SlotSSM | 25.64 | 45.03 |  | 54.73 | 74.42 |\n| OC-SlotSSM | $\\mathbf{6 1 .",
    "slotssm-5": "5 8}$ | $\\mathbf{8 4 . 0 0}$ |  | $\\mathbf{6 9 . 2 7}$ | $\\mathbf{9 0 . 4 8}$ |\n\nthe entire video duration. At test time, we evenly sample 50 frames from the video by skipping every 6 frames. The final snitch location is quantized into a $6 \\times 6$ grid, and the problem is formulated as a classification task. Models. In our investigation, we evaluate the performance of SlotSSM, OC-SlotSSM, Single State SlotSSM, and SlotTransformer. We exclude RNN-based baselines, such as SAVi, as our preliminary experiments reveal that they are unstable when handling long video inputs and prone to collapse to a constant output. For the visual pre-training setting, we employ a spatial broadcast decoder, common to all models, to reconstruct the input images. During downstream training/fine-tuning, we feed the slots from the final time step into a transformer predictor with single CLS token, followed by a linear layer on the output CLS token to predict the snitch's position. Results. Table 1 presents the Top-1 and Top-5 prediction accuracy on the CATER Snitch Localization task. Firstly, consistent with our previous findings, SlotSSM outperforms Single State SSM, which demonstrates the importance of modular structure in latent states for reasoning tasks involving multiple objects. When comparing SlotSSM with SlotTransformer, we see a notable difference between the direct training and pre-training settings. In direct training, SlotTransformer surpasses SlotSSM, possibly due to their optimization advantage, as the model can directly access to all previous states which facilitates learning of the task. However, SlotSSM benefits more from the pre-training phase, potentially attributed to the explicit memory capacity enabled by SSM states. Consequently, pre-trained SlotSSMs outperform their SlotTransformer counterparts. Remarkably, OC-SlotSSM achieves the highest accuracy, outperforming all baselines by a large margin in both direct training and pre-training settings. This performance gain might be attributed to the explicit decomposition of the scene into object-centric representations, which facilitates the reasoning about object properties, relationships, and interactions. ## 8 Conclusion \\& Limitations\n\nIn this work, we presented SlotSSMs a novel approach to incorporating modular structure and inductive biases into State Space Models for improved sequence modeling. By maintaining a collection of independent slot vectors and performing state transitions independently per slot with sparse interactions via self-attention, SlotSSMs effectively captures the inherent modularity present in many real-world processes. The experimental results in object-centric video understanding and video prediction tasks demonstrate the substantial performance gains offered by SlotSSMs over existing sequence modeling methods. SlotSSMs' success illustrates the importance of designing architectures that align with the problem domain's underlying modular structure. It also paves the way for future research in modular and object-centric sequence modeling. However, it has some limitations that future studies could address. First, although the proposed architecture is not only applicable to video modeling but also to other modalities like text, we have not explored this aspect in this study. It remains a matter for future work. Second, due to our academic research lab's computing resource constraints, we were unable to significantly scale up the proposed model to industry-scale in terms of model size and data size. Lastly, future studies should investigate the effect of increased visual complexity in videos. ## Impact Statement\n\nThe introduction of SlotSSMs, a novel framework that incorporates independent mechanisms into State Space Models (SSMs), has the potential to significantly impact the field of sequence modeling. By leveraging the modular structure inherent in many real-world processes, SlotSSMs offers a more\nintuitive and effective approach to modeling long-range temporal dependencies in object-centric video understanding and prediction tasks. The substantial performance gains demonstrated by SlotSSMs over existing sequence modeling methods highlight the importance of designing architectures that align with the underlying structure of the problem domain. This breakthrough could lead to the development of more efficient and accurate models for a wide range of applications, such as robotics, autonomous vehicles, and video surveillance systems. Moreover, the success of SlotSSMs in capturing the modular nature of real-world processes could inspire further research into modular and objectcentric sequence modeling. This could result in the development of even more advanced architectures that can better handle the complexity and diversity of real-world data. Because this is a general backbone architecture for sequence modeling, it doesn't raise direct ethical concerns. However, its ethical implications depend on the way downstream application developers use the model. ## Acknowledgements\n\nThis work is supported by Brain Pool Plus Program (No. 2021H1D3A2A03103645) and Young Researcher Program (No. 2022R1C1C1009443) through the National Research Foundation of Korea (NRF) funded by the Ministry of Science and ICT. ## References\n\n[1] Jimmy Ba, Jamie Ryan Kiros, and Geoffrey Hinton. Layer normalization. arXiv preprint arXiv:1607.06450, 2016. [2] Chang Chen, Yi-Fu Wu, Jaesik Yoon, and Sungjin Ahn. TransDreamer: Reinforcement learning with Transformer world models.",
    "slotssm-6": "In Deep RL Workshop NeurIPS 2021, 2021. [3] Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated recurrent neural networks on sequence modeling. arXiv preprint arXiv:1412.3555, 2014. [4] Shmuel Bar David, Itamar Zimerman, Eliya Nachmani, and Lior Wolf. Decision S4: Efficient sequence-based RL via state spaces layers.",
    "slotssm-7": "In International Conference on Learning Representations, 2023. [5] Soham De, Samuel L Smith, Anushan Fernando, Aleksandar Botev, George Cristian-Muraru, Albert Gu, Ruba Haroun, Leonard Berrada, Yutian Chen, Srivatsan Srinivasan, et al. Griffin: Mixing gated linear recurrences with local attention for efficient language models.",
    "slotssm-8": "arXiv preprint arXiv:2402.19427, 2024. [6] Fei Deng, Junyeong Park, and Sungjin Ahn. Facing off world model backbones: RNNs, Transformers, and S4. Advances in Neural Information Processing Systems, 36, 2024. [7] Alexey Dosovitskiy, Lucas Beyer, Alexander Kolesnikov, Dirk Weissenborn, Xiaohua Zhai, Thomas Unterthiner, Mostafa Dehghani, Matthias Minderer, Georg Heigold, Sylvain Gelly, Jakob Uszkoreit, and Neil Houlsby. An image is worth 16x16 words: Transformers for image recognition at scale. In International Conference on Learning Representations, 2021. [8] Gamaleldin F. Elsayed, Aravindh Mahendran, Sjoerd van Steenkiste, Klaus Greff, Michael Curtis Mozer, and Thomas Kipf. Savi++: Towards end-to-end object-centric learning from realworld videos.",
    "slotssm-9": "ArXiv, abs/2206.07764, 2022. [9] Daniel Y Fu, Tri Dao, Khaled Kamal Saab, Armin W Thomas, Atri Rudra, and Christopher R\u00e9. Hungry Hungry Hippos: Towards language modeling with state space models.",
    "slotssm-10": "In International Conference on Learning Representations, 2023. [10] Rohit Girdhar and Deva Ramanan. CATER: A diagnostic dataset for Compositional Actions and TEmporal Reasoning.",
    "slotssm-11": "In International Conference on Learning Representations, 2020. [11] Karan Goel, Albert Gu, Chris Donahue, and Christopher R\u00e9. It's raw! Audio generation with state-space models. In International Conference on Machine Learning, 2022. [12] Anirudh Goyal, Alex Lamb, Jordan Hoffmann, Shagun Sodhani, Sergey Levine, Yoshua Bengio, and Bernhard Sch\u00f6lkopf. Recurrent independent mechanisms. ArXiv, abs/1909.10893, 2021. [13] Klaus Greff, Francois Belletti, Lucas Beyer, Carl Doersch, Yilun Du, Daniel Duckworth, David Fleet, Dan Gnanapragasam, Florian Golemo, Charles Herrmann, Thomas Kipf, Abhijit Kundu, Dmitry Lagun, Issam H. Laradji, Hsueh-Ti Liu, Henning Meyer, Yishu Miao, Derek Nowrouzezahrai, Cengiz Oztireli, Etienne Pot, Noha Radwan, Daniel Rebain, Sara Sabour, Mehdi S. M. Sajjadi, Matan Sela, Vincent Sitzmann, Austin Stone, Deqing Sun, Suhani Vora, Ziyu Wang, Tianhao Wu, Kwang Moo Yi, Fangcheng Zhong, and Andrea Tagliasacchi. Kubric: A scalable dataset generator.",
    "slotssm-12": "arXiv preprint arXiv:2203.03570, 2022. [14] Albert Gu and Tri Dao. Mamba: Linear-time sequence modeling with selective state spaces.",
    "slotssm-13": "arXiv preprint arXiv:2312.00752, 2023. [15] Albert Gu, Tri Dao, Stefano Ermon, Atri Rudra, and Christopher R\u00e9. HiPPO: Recurrent memory with optimal polynomial projections.",
    "slotssm-14": "In Advances in Neural Information Processing Systems, 2020. [16] Albert Gu, Karan Goel, Ankit Gupta, and Christopher R\u00e9. On the parameterization and initialization of diagonal state space models. In Advances in Neural Information Processing Systems, 2022. [17] Albert Gu, Karan Goel, and Christopher R\u00e9. Efficiently modeling long sequences with structured state spaces. In International Conference on Learning Representations, 2022. [18] Albert Gu, Isys Johnson, Karan Goel, Khaled Kamal Saab, Tri Dao, Atri Rudra, and Christopher R\u00e9. Combining recurrent, convolutional, and continuous-time models with linear state space layers. In Advances in Neural Information Processing Systems, 2021. [19] Ankit Gupta, Albert Gu, and Jonathan Berant. Diagonal state spaces are as effective as structured state spaces. In Advances in Neural Information Processing Systems, 2022. [20] Ankit Gupta, Harsh Mehta, and Jonathan Berant. Simplifying and understanding state space models with diagonal linear RNNs. arXiv preprint arXiv:2212.00768, 2022. [21] Md Mohaiminul Islam and Gedas Bertasius. Long movie clip classification with state-space video models. In ECCV, 2022. [22] Jindong Jiang, Fei Deng, Gautam Singh, and Sungjin Ahn. Object-centric slot diffusion. Advances in Neural Information Processing Systems, 36, 2024. [23] Thomas Kipf, Gamaleldin F. Elsayed, Aravindh Mahendran, Austin Stone, Sara Sabour, Georg Heigold, Rico Jonschkowski, Alexey Dosovitskiy, and Klaus Greff. Conditional Object-Centric Learning from Video. arXiv preprint arXiv:2111.12594, 2021. [24] David M Knigge, David W Romero, Albert Gu, Efstratios Gavves, Erik J Bekkers, Jakub Mikolaj Tomczak, Mark Hoogendoorn, and Jan-jakob Sonke. Modelling long range dependencies in ND: From task-specific to a general purpose CNN. In International Conference on Learning Representations, 2023. [25] Francesco Locatello, Dirk Weissenborn, Thomas Unterthiner, Aravindh Mahendran, Georg Heigold, Jakob Uszkoreit, Alexey Dosovitskiy, and Thomas Kipf. Object-centric learning with slot attention, 2020. [26] Chris Lu, Yannick Schroecker, Albert Gu, Emilio Parisotto, Jakob Foerster, Satinder Singh, and Feryal Behbahani. Structured state space models for in-context reinforcement learning. arXiv preprint arXiv:2303.03982, 2023. [27] Harsh Mehta, Ankit Gupta, Ashok Cutkosky, and Behnam Neyshabur. Long range language modeling via gated state spaces. In International Conference on Learning Representations, 2023 . [28] Eric Nguyen, Karan Goel, Albert Gu, Gordon Downs, Preey Shah, Tri Dao, Stephen Baccus, and Christopher R\u00e9. S4ND: Modeling images and videos as multidimensional signals with state spaces.",
    "slotssm-15": "In Advances in Neural Information Processing Systems, 2022. [29] Antonio Orvieto, Samuel L Smith, Albert Gu, Anushan Fernando, Caglar Gulcehre, Razvan Pascanu, and Soham De. Resurrecting recurrent neural networks for long sequences. In International Conference on Machine Learning, 2023. [30] Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio. On the difficulty of training recurrent neural networks. In International Conference on Machine Learning, 2013. [31] Mohammad Reza Samsami, Artem Zholus, Janarthanan Rajendran, and Sarath Chandar. Mastering memory tasks with world models.",
    "slotssm-16": "In The Twelfth International Conference on Learning Representations, 2024. [32] Gautam Singh, Fei Deng, and Sungjin Ahn. Illiterate dall-e learns to compose.",
    "slotssm-17": "In International Conference on Learning Representations, 2022. [33] Gautam Singh, Yeongbin Kim, and Sungjin Ahn. Neural Systematic Binder.",
    "slotssm-18": "In International Conference on Learning Representations, 2023. [34] Gautam Singh, Yi-Fu Wu, and Sungjin Ahn. Simple unsupervised object-centric learning for complex and naturalistic videos.",
    "slotssm-19": "arXiv preprint arXiv:2205.14065, 2022. [35] Jimmy T.H. Smith, Andrew Warrington, and Scott Linderman. Simplified state space layers for sequence modeling. In International Conference on Learning Representations, 2023. [36] Chen Sun, Calvin Luo, Xingyi Zhou, Anurag Arnab, and Cordelia Schmid. Does visual pretraining help end-to-end reasoning?",
    "slotssm-20": "Advances in Neural Information Processing Systems, 36, 2024 . [37] Yi Tay, Mostafa Dehghani, Samira Abnar, Yikang Shen, Dara Bahri, Philip Pham, Jinfeng Rao, Liu Yang, Sebastian Ruder, and Donald Metzler. Long Range Arena: A benchmark for efficient Transformers.",
    "slotssm-21": "In International Conference on Learning Representations, 2021. [38] Yao-Hung Hubert Tsai, Nitish Srivastava, Hanlin Goh, and Ruslan Salakhutdinov. Capsules with inverted dot-product attention routing.",
    "slotssm-22": "In International Conference on Learning Representations, 2020. [39] Sjoerd Van Steenkiste, Michael Chang, Klaus Greff, and J\u00fcrgen Schmidhuber. Relational neural expectation maximization: Unsupervised discovery of objects and their interactions.",
    "slotssm-23": "arXiv preprint arXiv:1802.10353, 2018. [40] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, \u0141ukasz Kaiser, and Illia Polosukhin. Attention is all you need. In Advances in neural information processing systems, pages 5998-6008, 2017. [41] Jue Wang, Wentao Zhu, Pichao Wang, Xiang Yu, Linda Liu, Mohamed Omar, and Raffay Hamid. Selective structured state-spaces for long-form video understanding. In CVPR, 2023. [42] Nicholas Watters, Loic Matthey, Christopher P. Burgess, and Alexander Lerchner. Spatial broadcast decoder: A simple architecture for learning disentangled representations in vaes. arXiv preprint arXiv:1901.07017, 2019. [43] Yi-Fu Wu, Klaus Greff, Gamaleldin Fathy Elsayed, Michael Curtis Mozer, Thomas Kipf, and Sjoerd van Steenkiste. Inverted-attention transformers can learn object representations: Insights from slot attention. In UniReps: the First Workshop on Unifying Representations in Neural Models, 2023. [44] Yi-Fu Wu, Jaesik Yoon, and Sungjin Ahn. Generative video transformer: Can objects be the words? In International Conference on Machine Learning, pages 11307-11318. PMLR, 2021. [45] Ziyi Wu, Nikita Dvornik, Klaus Greff, Thomas Kipf, and Animesh Garg. Slotformer: Unsupervised visual dynamics simulation with object-centric models.",
    "slotssm-24": "arXiv preprint arXiv:2210.05861, 2022. [46] Ziyi Wu, Jingyu Hu, Wuyue Lu, Igor Gilitschenski, and Animesh Garg. Slotdiffusion: Objectcentric generative modeling with diffusion models. In Thirty-seventh Conference on Neural Information Processing Systems, 2023. [47] Jing Nathan Yan, Jiatao Gu, and Alexander M. Rush. Diffusion models without attention, 2023. [48] Linqi Zhou, Michael Poli, Winnie Xu, Stefano Massaroli, and Stefano Ermon. Deep latent state space models for time-series generation. In International Conference on Machine Learning, 2023. [49] Lianghui Zhu, Bencheng Liao, Qian Zhang, Xinlong Wang, Wenyu Liu, and Xinggang Wang. Vision mamba: Efficient visual representation learning with bidirectional state space model.",
    "slotssm-25": "arXiv preprint arXiv:2401.09417, 2024. [50] Simiao Zuo, Xiaodong Liu, Jian Jiao, Denis Charles, Eren Manavoglu, Tuo Zhao, and Jianfeng Gao. Efficient long sequence modeling via state space augmented Transformer. arXiv preprint arXiv:2212.08136, 2022. ## A Blinking Color Balls Benchmark\n\n## A. 1 Motivation\n\nReal-world videos are often inherently modular, involving multiple dynamic entities and their interactions across time. However, existing long-range reasoning tasks, such as those in the Long-Range Arena Benchmark [37], are typically designed to focus on single-object settings and recognizing a single dynamic pattern in the observations. To bridge this gap and facilitate more comprehensive evaluation, we propose the Blinking Color Balls Benchmark, a long-range visual reason benchmark desgined in a multi-object setting. ![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-16.jpg?height=490&width=1126&top_left_y=669&top_left_x=497)\n\nFigure 8: Blinking Color Balls Benchmark Overview. Left: Context frames with independent random ball picking and color assignments for each frame. Top figures indicate the sequential color assignment. Right: Target image for the Earliest Color and Most Frequent Color variants. Top figures indicate the color assignment rules. ## A. 2 Dataset Design\n\nWe provide an illustrative example of the dataset design in Figure 8 . Each episode of the dataset contains a context-target pair $\\left(\\mathbf{x}_{1: T-1}, \\mathbf{x}_{T}\\right)$. At each timestep in $\\mathbf{x}_{1: T-1}$, all bouncing balls are first colored white, and then one ball is randomly picked and colored with one of 5 non-white colors. This process is repeated for all context frames, and it is represented in the rows in Figure 8ttop). Note that the object picking and coloring are performed independently for each timestep, thus one ball could be selected none or multiple times and colorized with the same or different colors across different timesteps. The target images are then constructed with two rules: Earliest Color and Most Frequent Color. The Earliest Color rule picks the earliest non-white color assigned to the ball as the final color, while the Most Frequent Color rule counts the assignment of each non-white color and picks the color with the highest count (if there are ties, the earlier color among the highest is chosen). In Figure 8, we differentiate the two datasets using the same context sequence, which will result in different target images based on the rule. Note that regardless of the color assignment, the objects are moving and follow the physical bouncing rules throughout the full sequence. More image samples can be found in Figure 9 . ![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-16.jpg?height=302&width=1350&top_left_y=2120&top_left_x=382)\n\nFigure 9: Blinking Color Balls Samples. ![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-17.jpg?height=397&width=1275&top_left_y=246&top_left_x=422)\n\nFigure 10: Blinking Color Balls Qualitative Comparison. Results shown for the Most Frequent Color variant with a sequence length of 80 frames. Finally, as illustrated in Figure 5 (a), we transform the conditional image generation task into a long-range reasoning task by using patchified context images as input. Instead of providing the $T-1$ context images directly to the model, we flatten non-overlapping patches of the original images to create a long input sequence. Given $P \\times P$ patches per image, the context length becomes $L=(T-1) \\times P^{2}$. Note that patchification is used intentionally to construct long sequences for the benchmark; SlotSSMs in general do not inherently require patchified inputs and instead use a Slot Encoder to extract slots as input at each time step. ## A. 3 Challenges and Qualitative Comparison\n\nThe Blinking Color Balls tasks pose significant challenges for the models, as they are required to associate partial views of objects from temporally distant patches to learn their movement patterns and color assignment rules. We can define two levels of challenges: (1) identifying each object from the patches and predicting their positions based on their dynamics, and (2) determining the final color assignment of each object based on the given rules. The first challenge is relatively straightforward, as it primarily involves the dynamics of objects from the immediate past two frames prior to the target time step. However, the second challenge is particularly difficult, as it requires the model to reason over the entire input sequence, necessitating the identification of an object's history from partially observed patches in a long-range context. Figure 10 presents a qualitative comparison of the models' performance on the task. The results reveal a clear categorization of the models based on their capability to address the two levels of challenges. The baseline RIM model successfully predicts the object positions in the target image but struggles with learning the color assignment rules. Consequently, it predicts the color white that generally have the highest appearance probability for all objects. Note that the rendered images are based on the argmax of the logits over the color categories. Models such as SlotRNN and Single State SSM demonstrate the ability to learn color assignments, but they make mistakes in some cases. In contrast, SlotSSM and SlotTransformer successfully achieve both accurate position prediction and color assignment. ## B Additional Implementation Details\n\n## B. 1 SlotSSMs and OC-SlotSSMs\n\nSlot Encoder. The main difference between the SlotSSMs and OC-SlotSSMs variants is in the design of the Slot Encoders as illustrated in Figure 11. The Slot Encoder in SlotSSMs is implemented as a multi-layer transformer with self-attention and cross-attention modules. Given the input tokens $\\mathcal{X}_{t}=\\left\\{\\boldsymbol{x}_{t}^{m}\\right\\}_{m=1}^{M}$, the structure of each layer in the Slot Encoder can be delineated into three modules:\n\n$$\n\\begin{aligned}\n& \\mathcal{C}_{t}=\\operatorname{Self} \\operatorname{Attn}\\left(\\mathcal{C}_{t}\\right) \\\\\n& \\mathcal{C}_{t}=\\operatorname{Cross} \\operatorname{Attn}\\left(\\mathrm{q}=\\mathcal{C}_{t}, \\mathrm{kv}=\\mathcal{X}_{t}\\right) \\\\\n& \\mathcal{C}_{t}=\\operatorname{MLP}\\left(\\mathcal{C}_{t}\\right)\n\\end{aligned}\n$$\n\nWe use 3 layers in all our experiments. Note that we also apply skip connections and layer normalization in the input for all three modules, but have omitted them in the equations for brevity. The regular cross-attention used here employs softmax normalization over the attention weights applied to the input tokens:\n\n$$\n\\begin{aligned}\nQ & =W_{Q}\\left(\\mathcal{C}_{t}\\right), \\quad K=W_{K}\\left(\\mathcal{X}_{t}\\right), \\quad V=W_{V}\\left(\\mathcal{X}_{t}\\right) \\\\\n\\mathcal{C}_{t}^{\\text {out }} & =\\operatorname{softmax}\\left(\\frac{Q K^{T}}{\\sqrt{D}}, \\quad \\text { axis='keys'}\\right) V\n\\end{aligned}\n$$\n\nIn the OC-SlotSSMs layers, the Slot Encoder is implemented as a single inverted attention layer. This layer differs from the regular cross attention by the way attention weights are normalized:\n\n$$\n\\begin{aligned}\nQ & =W_{Q}\\left(\\mathcal{C}_{t}\\right), \\quad K=W_{K}\\left(\\mathcal{X}_{t}\\right), \\quad V=W_{V}\\left(\\mathcal{X}_{t}\\right) \\\\\nA & =\\operatorname{softmax}\\left(\\frac{Q K^{T}}{\\sqrt{D}}, \\quad \\text { axis='queries' }\\right) \\\\\nA_{i, j} & =\\frac{A_{i, j}}{\\sum_{j=1}^{N_{K}} A_{i, j}} \\\\\n\\mathcal{C}_{t}^{\\text {out }} & =A V\n\\end{aligned}\n$$\n\nThe inverted attention layer applies softmax normalization over the queries, introducing a competition among the query tokens over the attention to the input tokens and thereby promoting disentanglement for the input tokens. |  |  | Dataset \\& Models |  |\n| :--- | :--- | :---: | :---: |\n| Module | Hyperparameter | Blinking Color Balls (SlotSSMs) | MOVi-A (OC-SlotSSMs) |\n| General | Batch Size | 128 | 24 |\n|  | Training Steps | 300 K | 500 K |\n|  | Sequence Length | $\\{80,160,320,640,1024,2048\\}$ | 6 |\n|  | Optimizer | AdamW | AdamW |\n|  | Weight Decay | 0.1 | 0.1 |\n|  | Learning Rate | $8 \\mathrm{e}-4$ | $3 \\mathrm{e}-4$ |\n| Slot Encoder | Input Tokenizer | MLP(Patchify $\\left.\\left(\\boldsymbol{x}_{\\text {input }}\\right)\\right)$ | Flatten(CNN $\\left.\\left(\\boldsymbol{x}_{\\text {input }}\\right)\\right)$ |\n|  | Encoder Type | Self-Cross Attention | Inverted Attention |\n|  | Applied Layers | First Layer | All Layers |\n|  | Hidden Size | 64 | 192 |\n|  | Dropout | 0 | 0 |\n|  | Heads | 4 | 4 |\n| SlotSSM | Hidden Size | 64 | 192 |\n|  | \\# Slots | 6 | 11 |\n|  | SSM Model | Mamba Block | Mamba Block |\n|  | State Size | 16 | 16 |\n|  | State Expand | 1.25 | 1.25 |\n| Slot Mixer | Dropout | 0 | 0 |\n|  | Heads | 4 | 4 |\n\nTable 2: Hyperparameters of our model used in our experiments. SSM Blocks. For the implementation of the SSM models, we leverage recent advances in linear state space models and design our SSM block in SlotSSM based on the Mamba architecture [14]. The block-diagonal transition of slots is implemented as parallel runs of SSM blocks that share the same model weights. ![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-19.jpg?height=1242&width=1121&top_left_y=239&top_left_x=497)\n\nFigure 11: SlotSSMs vs OC-SlotSSMs. $$\n\\begin{aligned}\n& \\left\\{\\boldsymbol{y}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}},\\left\\{\\boldsymbol{h}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}}=\\operatorname{SlotSSM}\\left(\\left\\{\\boldsymbol{s}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}},\\left\\{\\boldsymbol{h}_{t-1 \\mid l}^{k}\\right\\}_{k=1}^{K_{l}}\\right) \\\\\n& \\Longrightarrow \\quad \\boldsymbol{y}_{t \\mid l}^{k}, \\boldsymbol{h}_{t \\mid l}^{k}=\\operatorname{MambaBlock}\\left(\\boldsymbol{s}_{t \\mid l}^{k}, \\boldsymbol{h}_{t-1 \\mid l}^{k}\\right), \\quad \\forall k \\in\\left\\{1, \\ldots, K_{l}\\right\\}\n\\end{aligned}\n$$\n\nWe include pseudo-code of the Mamba block implementation in Algorithm 1.",
    "slotssm-26": "For a more detailed description of the Mamba architecture and its underlying principles, we refer the readers to the original paper [14]. ## B. 2 Baseline Models\n\nWe use the official implementation of RIM from GitHub ${ }^{2}$, as well as the SAVi implementation from STEVE ${ }^{3}$ We describe the implementation of the proposed baselines SlotRNN and SlotTransformer in the following. SlotRNN. SlotRNN adopts a similar design to SlotSSM, but replaces the SSMs with GRUs [3]. In this architecture, the slots are processed in parallel across different slots at each time step and sequentially across time steps. The implementation of each layer is summarized as follows. [^1]\\[\n\n$$\n\\begin{aligned}\n\\left\\{\\boldsymbol{s}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}} & =\\operatorname{SlotEncoder}\\left(\\left\\{\\boldsymbol{x}_{t \\mid l-1}^{k}\\right\\}_{k=1}^{K_{l-1}}\\right) \\\\\n\\boldsymbol{h}_{t \\mid l}^{k} & =\\operatorname{GRU}\\left(s_{t \\mid l}^{k}, \\boldsymbol{h}_{t-1 \\mid l}^{k}\\right), \\quad \\forall k \\in\\left\\{1, \\ldots, K_{l}\\right\\} \\\\\n\\left\\{\\boldsymbol{h}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}} & =\\operatorname{SelfAttention}\\left(\\left\\{\\boldsymbol{h}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}}\\right) \\\\\n\\left\\{\\boldsymbol{x}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}} & =\\left\\{\\boldsymbol{h}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}}\n\\end{aligned}\n$$\n\\]\n\nSlotTransformer. SlotTransformer uses the same SlotEncoder as SlotSSM to obtain slot representations. At each time step, the slots from the current step are concatenated with the slots from all previous time steps. This combined sequence is then processed using a Transformer with causal mask in time dimension which ensures that each slot can only obtain information from prior or current time steps. The implementation of each layer is summarized as follows:\n\n$$\n\\begin{aligned}\n\\left\\{\\boldsymbol{s}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}} & =\\operatorname{SlotEncoder}\\left(\\left\\{\\boldsymbol{x}_{t \\mid l-1}^{k}\\right\\}_{k=1}^{K_{l-1}}\\right) \\\\\n\\left\\{\\boldsymbol{x}_{<=t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}} & =\\operatorname{Transformer}\\left(\\left\\{\\boldsymbol{s}_{t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}} \\cup\\left\\{\\boldsymbol{s}_{<t \\mid l}^{k}\\right\\}_{k=1}^{K_{l}}\\right)\n\\end{aligned}\n$$\n\n## B. 3 Blinking Color Balls Experiemtns\n\nWe show the hyperparameters used in the experiments in Table 2.",
    "slotssm-27": "Input Tokenizer. Each patch in the input sequence is treated as an image and further split into non-overlapping patches of size $4 \\times 4$. Each patch is then augmented with spatial and temporal positional embeddings, followed by an MLP layer to compute the final tokens for the Slot Encoder. Decoder. During image decoding, we use a self-cross attention layer with positional embeddings as input and slots as context. Given the positional embeddings $\\mathcal{P}_{t}=\\left\\{\\boldsymbol{p}_{t}^{m}\\right\\}_{m=1}^{H W}$ and slots from SlotSSM $\\mathcal{S}_{t}=\\left\\{s_{t}^{k}\\right\\}_{k=1}^{K}$, each layer of the transformer decoder can be described as follows:\n\n$$\n\\begin{aligned}\n& \\mathcal{P}_{t}=\\operatorname{SelfAttn}\\left(\\mathcal{P}_{t}\\right) \\\\\n& \\mathcal{P}_{t}=\\operatorname{CrossAttn}\\left(\\mathrm{q}=\\mathcal{P}_{t}, \\mathrm{kv}=\\mathcal{S}_{t}\\right) \\\\\n& \\mathcal{P}_{t}=\\operatorname{MLP}\\left(\\mathcal{P}_{t}\\right)\n\\end{aligned}\n$$\n\nWe use a total of 3 layers, and the final pixel logits are computed using a linear head.",
    "slotssm-28": "Training Objective. During training, we transform the image prediction problem into a pixel-wise classification task. Specifically, for a target image $\\boldsymbol{x}_{N} \\in \\mathbb{R}^{H \\times W \\times 3}$, we compute a quantization by categorizing each pixel into one of 7 discrete color categories:\n\n$$\n\\boldsymbol{x}_{N}^{Q}(i, j)=Q\\left(\\boldsymbol{x}_{N}(i, j)\\right) \\quad \\forall i \\in\\{1,2, \\ldots, H\\}, j \\in\\{1,2, \\ldots, W\\}\n$$\n\nwhere $Q: \\mathbb{R}^{3} \\rightarrow \\mathbb{C}$ is the quantization function that maps a 3-dimensional color vector to one of the 7 color categories in the set $\\mathbb{C}=\\left\\{\\boldsymbol{c}_{1}, \\ldots, \\boldsymbol{c}_{7}\\right\\}$. Each $\\boldsymbol{c}_{k} \\in \\mathbb{R}^{3}$ represents a color vector corresponding to a discrete color category. This is a lossless quantization process since the raw images are generated with the same set of discrete colors. The final training objective is the cross-entropy loss between the model output $\\hat{\\boldsymbol{x}}_{N}$ and the target $\\boldsymbol{x}_{N}^{Q}$ :\n\n$$\n\\mathcal{L}=-\\sum_{i=1}^{H} \\sum_{j=1}^{W} \\sum_{k=1}^{6} \\boldsymbol{x}_{N}^{Q}(i, j, k) \\log \\left(\\hat{\\boldsymbol{x}}_{N}(i, j, k)\\right)\n$$\n\n## B. 4 Unsupervised Object-Centric Learning Experiments\n\nThe hyperparameters used in the experiments are presented in Table 2 Table 4 details the structure of the spatial broadcast decoder described in Section 5.2\n\nTo compute the input tokens, the input images are first processed by a CNN network to generate a 2 D feature map.",
    "slotssm-29": "The architecture of the CNN network is described in Table 3. We use a downsampling factor of 2, resulting in an output 2D feature map of size $64 \\times 64$ for an input image size of $128 \\times 128$. The 2D feature map is then flattened into a sequence of length 4096 and provided to the inverted attention mechanism. Table 3: The CNN encoder architecture used for object-centric learning. | Layer | Kernel Size | Stride | Padding | Channels | Activation |\n| :--- | :---: | :---: | :---: | :---: | :---: |\n| Conv | $5 \\times 5$ | 2 | 2 | 192 | ReLU |\n| Conv | $5 \\times 5$ | 1 | 2 | 192 | ReLU |\n| Conv | $5 \\times 5$ | 1 | 2 | 192 | ReLU |\n| Conv | $5 \\times 5$ | 1 | 2 | 192 | None |\n\nTable 4: Spatial broadcast decoder architecture for image reconstruction in object-centric learning, it outputs RGB and alpha-mixing logits. | Layer | Kernel Size | Stride | Padding | Channels | Activation |\n| :---: | :---: | :---: | :---: | :---: | :---: |\n| Slot Normalization | - | - | - | - | - |\n| Positional Embedding | - | - | - | - | - |\n| ConvTranspose2d | $5 \\times 5$ | 2 | 2 (Output Padding: 1) | 64 | ReLU |\n| ConvTranspose2d | $5 \\times 5$ | 2 | 2 (Output Padding: 1) | 64 | ReLU |\n| ConvTranspose2d | $5 \\times 5$ | 2 | 2 (Output Padding: 1) | 64 | ReLU |\n| ConvTranspose2d | $5 \\times 5$ | 2 | 2 (Output Padding: 1) | $3+1$ | None |\n\n## B. 5 3D Visual Reasoning Experiments\n\nModel Configuration For both SlotSSM and OC-SlotSSM, we employ architectures similar to those described in Table 2, with a few modifications to accommodate the complexity of the 3D visual reasoning task. We use 12 slots and a hidden size of 64 for all modules to reduce memory consumption. Additionally, we utilize a spatial broadcast decoder for all models during the pre-training phase. Due to limited computational resources, we apply a model size of 8 for both pre-training and finetuning/direct training phases. It is worth noting that the model performance could potentially be further improved with a properly tuned batch size during training. Data Augmentation To prevent overfitting, we apply data augmentation on all training phases, following the practices of prior works [44, 36]. During the model pre-training phase, we randomly sample 32 frames from the original 300 frames. Note that the sampled frames may not be consecutive, which is an intentional aspect of the data augmentation. For the fine-tuning or direct training phase, we first split the 300 frames with non-overlapping segments of length 6 , then we randomly select 1 frame from each segment to construct a input sequence of length 50. Predictor To predict the location of the snitch, we employ a transformer-based predictor. Specifically, we concatenate the learned slot representations with a learned CLS token and feed the resulting sequence into a 2-layer transformer. The output CLS token is then passed through a linear layer to predict the logits for snitch localization. ## C Emerging Modularity in SlotSSMs\n\nTo gain further insights into the learned representations of the slot-based models, we investigate how the slots are utilized in the image generation process. This can be done by visualizing the attention mechanisms in the decoders. Figure 12 presents the results of this analysis. For the transformer decoders used in the video prediction and blinking color balls tasks, we compute the argmax over the slots in the cross-attention map (Eq. 36, which represents the attention of the positional tokens over the slots employed to obtain information for reconstruction at each position. In the case of the spatial broadcast decoder,\n\n![](https://cdn.mathpix.com/cropped/2024_09_17_a6be023ad0137d5f7ab5g-22.jpg?height=839&width=1380&top_left_y=253&top_left_x=365)\n\nFigure 12: Emerging Modularity in SlotSSMs. Object-centric state representations naturally emerged to accommodate the underlying structure of the data. we take the argmax over the alpha-mixing logits $\\boldsymbol{\\alpha}_{t}$ (Eq. 17). The visualizations reveal that each slot tends to specialize in representing a specific object or a coherent part of the scene. This emerged object-centric representation allows the model to efficiently capture the dynamics and interactions of the objects, leading to improved performance in tasks such as video prediction and reasoning in the blinking color balls benchmark. Interestingly, even though the slot encoder used in the video prediction and blinking color balls benchmarks does not explicitly enforce spatial disentanglement constraints like the inverted attention mechanism in OC-SlotSSMs does, the models still learn to represent the sequences in an objectcentric manner. This emergent modularity suggests that the SlotSSM design can naturally encourages the model to discover and exploit the underlying structure of the data which is a crucial capability for modeling complex visual inputs such as real-world videos. ```\nAlgorithm 1 Mamba Block. The algorithm receives a \\(T\\)-length sequence of the same slot across\ntime \\(\\mathbf{s}_{1: T} \\in \\mathbb{R}^{T \\times D}\\). The algorithm outputs the updated slots \\(\\mathbf{s}_{1: T}\\). Note that the model imposes the\ndiagonal structure on the A matrix. Input: \\(\\mathbf{s} \\in \\mathbb{R}^{T \\times D}\\)\n    Block params: SSM linear \\(\\mathrm{S}_{B}, \\mathrm{~S}_{C}, \\mathrm{~S}_{\\Delta}\\); Transition matrix \\(\\mathbf{A} \\in \\mathbb{R}^{D \\times N}\\); LayerNorm LN; Linear\n    Linear \\(_{1}\\), Linear \\({ }_{2}\\); 1D Conv Conv1D\n        for \\(t=1 \\ldots T\\) in parallel\n            \\(\\mathbf{s}_{t}\\), res \\(_{\\mathbf{t}}=\\operatorname{Linear}_{1}\\left(\\mathbf{s}_{t}\\right)\\)\n            \\(\\mathbf{s}_{t}=\\operatorname{SiLU}\\left(\\operatorname{Conv1D}\\left(\\mathbf{s}_{t}\\right)\\right)\\)\n        SSM block:\n            \\(\\mathbf{B} \\in \\mathbb{R}^{T \\times N} \\leftarrow \\mathrm{S}_{B}(\\mathbf{s})\\)\n            \\(\\mathbf{C} \\in \\mathbb{R}^{T \\times N} \\leftarrow \\mathrm{S}_{C}(\\mathbf{s})\\)\n            \\(\\Delta \\in \\mathbb{R}^{T \\times D} \\leftarrow\\) SoftPlus(Parameter \\(+\\mathrm{S}_{\\Delta}(\\mathbf{s})\\) )\n            \\(\\overline{\\mathbf{A}}, \\overline{\\mathbf{B}} \\in \\mathbb{R}^{T \\times D \\times N} \\leftarrow \\operatorname{discretize}(\\Delta, \\mathbf{A}, \\mathbf{B})\\)\n            \\(\\mathbf{h}_{0}=\\mathbf{0}^{D \\times N}\\)\n            for \\(t=1 \\ldots T\\) in parallel (scan) \\# GPU hardware accelerated \\(\\mathrm{y} \\leftarrow \\operatorname{SSM}(\\bar{A}, \\bar{B}, C)(\\mathrm{s})\\). \\(\\mathbf{h}_{t}=\\overline{\\mathbf{A}}_{t} \\circ \\mathbf{h}_{t-1}+\\overline{\\mathbf{B}}_{t} \\mathbf{s}_{t} \\quad\\) \\# Hadamard product for diagonal \\(\\overline{\\mathbf{A}}\\). \\(\\mathbf{y}_{t}=\\mathbf{C}_{t} \\mathbf{h}_{t}\\)\n        for \\(t=1 \\ldots T\\) in parallel\n            \\(\\mathbf{y}_{t}=\\mathbf{y}_{t} * \\operatorname{SiLU}\\left(\\mathbf{r e s}_{\\mathbf{t}}\\right)\\)\n            \\(\\mathbf{y}_{t}=\\) Linear \\(_{2}\\left(\\mathbf{y}_{t}\\right)\\)\n        return y\n```\n\n\n[^0]:    ${ }^{*}$ Correspondence to jindong.jiang@rutgers.",
    "slotssm-30": "edu and sungjin. ahn@kaist.ac.kr. [^1]:    ${ }^{2}$ https://github.com/anirudh9119/RIMs\n    ${ }^{3}$ https://github.com/singhgautam/steve\n\n"
}