{
    "rfa-0": "# RANDOM FEATURE ATTENTION \n\nHao Peng ${ }^{\\star *}$ Nikolaos Pappas ${ }^{\\star}$ Dani Yogatama ${ }^{*} \\quad$ Roy Schwartz ${ }^{\\complement}$<br>Noah A. Smith $\\diamond$ Lingpeng Kong**<br>${ }^{4}$ Paul G. Allen School of Computer Science \\& Engineering, University of Washington<br>${ }^{*}$ DeepMind $\\diamond$ Allen Institute for Artificial Intelligence<br>${ }^{\\text {\u00ae }}$ School of Computer Science \\& Engineering, Hebrew University of Jerusalem<br>${ }^{\\bullet}$ Department of Computer Science, The University of Hong Kong<br>\\{hapeng, npappas, nasmith\\}@cs.washington.edu<br>dyogatama@google.com, roys@cs.huji.ac.il, lpk@cs.hku.hk\n\n\n#### Abstract\n\nTransformers are state-of-the-art models for a variety of sequence modeling tasks. At their core is an attention function which models pairwise interactions between the inputs at every timestep. While attention is powerful, it does not scale efficiently to long sequences due to its quadratic time and space complexity in the sequence length. We propose RFA, a linear time and space attention that uses random feature methods to approximate the softmax function, and explore its application in transformers. RFA can be used as a drop-in replacement for conventional softmax attention and offers a straightforward way of learning with recency bias through an optional gating mechanism. Experiments on language modeling and machine translation demonstrate that RFA achieves similar or better performance compared to strong transformer baselines. In the machine translation experiment, RFA decodes twice as fast as a vanilla transformer. Compared to existing efficient transformer variants, RFA is competitive in terms of both accuracy and efficiency on three long text classification datasets. Our analysis shows that RFA's efficiency gains are especially notable on long sequences, suggesting that RFA will be particularly useful in tasks that require working with large inputs, fast decoding speed, or low memory footprints. ## 1 INTRODUCTION\n\nTransformer architectures (Vaswani et al., 2017) have achieved tremendous success on a variety of sequence modeling tasks (Ott et al., 2018; Radford et al., 2018; Parmar et al., 2018, Devlin et al., 2019, Parisotto et al. 2020, inter alia). Under the hood, the key component is attention (Bahdanau et al. 2015), which models pairwise interactions of the inputs, regardless of their distances from each other. This comes with quadratic time and memory costs, making the transformers computationally expensive, especially for long sequences. A large body of research has been devoted to improving their time and memory efficiency (Tay et al., 2020c). Although better asymptotic complexity and prominent gains for long sequences have been achieved (Lee et al. 2019; Child et al., 2019, Beltagy et al. 2020, inter alia), in practice, many existing approaches are less well-suited for moderatelength ones: the additional computation steps required by some approaches can overshadow the time and memory they save (Kitaev et al., 2020, Wang et al. 2020, Roy et al., 2020, inter alia). This work proposes random feature attention (RFA), an efficient attention variant that scales linearly in sequence length in terms of time and space, and achieves practical gains for both long and moderate length sequences. RFA builds on a kernel perspective of softmax (Rawat et al., 2019). Using the well-established random feature maps (Rahimi \\& Recht, 2007, Avron et al., 2016, \\$2, RFA approximates the dot-then-exponentiate function with a kernel trick (Hofmann et al. 2008): $\\exp (\\mathbf{x} \\cdot \\mathbf{y}) \\approx \\phi(\\mathbf{x}) \\cdot \\phi(\\mathbf{y})$. Inspired by its connections to gated recurrent neural networks Hochreiter \\& Schmidhuber, 1997, Cho et al., 2014) and fast weights (Schmidhuber, 1992), we further augment RFA with an optional gating mechanism, offering a straightforward way of learning with recency bias when locality is desired. [^0]RFA and its gated variant ( $\\S 3$ ) can be used as a drop-in substitute for the canonical softmax attention, and increase the number of parameters by less than $0.1 \\%$. We explore its applications in transformers on language modeling, machine translation, and long text classification ( $\\$ 4$. Our experiments show that RFA achieves comparable performance to vanilla transformer baselines in all tasks, while outperforming a recent related approach (Katharopoulos et al., 2020). The gating mechanism proves particularly useful in language modeling: the gated variant of RFA outperforms the transformer baseline on WikiText-103. RFA shines in decoding, even for shorter sequences. In our head-to-head comparison on machine translation benchmarks, RFA decodes around $2 \\times$ faster than a transformer baseline, without accuracy loss. Comparisons to several recent efficient transformer variants on three long text classification datasets show that RFA is competitive in terms of both accuracy and efficiency. Our analysis ( $\\$ 5$ ) shows that more significant time and memory efficiency improvements can be achieved for longer sequences: $12 \\times$ decoding speedup with less than $10 \\%$ of the memory for 2,048-length outputs. ## 2 BACKGROUND\n\n### 2.1 AtTention In SEQUEnce ModeLing\n\nThe attention mechanism (Bahdanau et al. 2015) has been widely used in many sequence modeling tasks. Its dot-product variant is the key building block for the state-of-the-art transformer architectures (Vaswani et al. 2017). Let $\\left\\{\\mathbf{q}_{t}\\right\\}_{t=1}^{N}$ denote a sequence of $N$ query vectors, that attend to sequences of $M$ key and value vectors. At each timestep, the attention linearly combines the values weighted by the outputs of a softmax:\n\n$$\n\\operatorname{attn}\\left(\\mathbf{q}_{t},\\left\\{\\mathbf{k}_{i}\\right\\},\\left\\{\\mathbf{v}_{i}\\right\\}\\right)=\\sum_{i} \\frac{\\exp \\left(\\mathbf{q}_{t} \\cdot \\mathbf{k}_{i} / \\tau\\right)}{\\sum_{j} \\exp \\left(\\mathbf{q}_{t} \\cdot \\mathbf{k}_{j} / \\tau\\right)} \\mathbf{v}_{i}^{\\top}\n$$\n\n$\\tau$ is the temperature hyperparameter determining how \"flat\" the softmax is Hinton et al. 2015, 1\nCalculating attention for a single query takes $\\mathcal{O}(M)$ time and space.",
    "rfa-1": "For the full sequence of $N$ queries the space amounts to $\\mathcal{O}(M N)$. When the computation cannot be parallelized across the queries, e.g., in autoregressive decoding, the time complexity is quadratic in the sequence length. ### 2.2 RANDOM FEATURE METHODS\n\nThe theoretical backbone of this work is the unbiased estimation of the Gaussian kernel by Rahimi \\& Recht (2007). Based on Bochner's theorem (Bochner 1955), Rahimi \\& Recht (2007) proposed random Fourier features to approximate a desired shift-invariant kernel. The method nonlinearly transforms a pair of vectors x and y using a random feature map $\\phi$; the inner product between $\\phi(\\mathbf{x})$ and $\\phi(\\mathbf{y})$ approximates the kernel evaluation on $\\mathbf{x}$ and $\\mathbf{y}$. More precisely:\nTheorem 1 Rahimi \\& Recht, 2007). Let $\\phi: \\mathbb{R}^{d} \\rightarrow \\mathbb{R}^{2 D}$ be a nonlinear transformation:\n\n$$\n\\phi(\\mathbf{x})=\\sqrt{1 / D}\\left[\\sin \\left(\\mathbf{w}_{1} \\cdot \\mathbf{x}\\right), \\ldots, \\sin \\left(\\mathbf{w}_{D} \\cdot \\mathbf{x}\\right), \\cos \\left(\\mathbf{w}_{1} \\cdot \\mathbf{x}\\right), \\ldots, \\cos \\left(\\mathbf{w}_{D} \\cdot \\mathbf{x}\\right)\\right]^{\\top}\n$$\n\nWhen d-dimensional random vectors $\\mathbf{w}_{i}$ are independently sampled from $\\mathcal{N}\\left(\\mathbf{0}, \\sigma^{2} \\mathbf{I}_{d}\\right)$,\n\n$$\n\\mathbb{E}_{\\mathbf{w}_{i}}[\\phi(\\mathbf{x}) \\cdot \\boldsymbol{\\phi}(\\mathbf{y})]=\\exp \\left(-\\|\\mathbf{x}-\\mathbf{y}\\|^{2} / 2 \\sigma^{2}\\right)\n$$\n\nVariance of the estimation is inversely proportional to $D$ (Appendix A.2, Yu et al., 2016). Random feature methods proved successful in speeding up kernel methods (Oliva et al., 2015, Avron et al. 2017, Sun, 2019, inter alia), and more recently are used to efficiently approximate softmax (Rawat et al. 2019). In $\\$ 3.1$, we use it to derive an unbiased estimate to $\\exp (\\langle\\cdot, \\cdot\\rangle)$ and then an efficient approximation to softmax attention. ## 3 MODEL\n\nThis section presents RFA ( $\\$ 3.1$ ) and its gated variant ( $\\$ 3.2$ ). In $\\$ 3.3$ we lay out several design choices and relate RFA to prior works. We close by practically analyzing RFA's complexity ( $\\$ 3.4$ ). [^1]![](https://cdn.mathpix.com/cropped/2024_09_12_1812cf4ebe91908f3210g-03.jpg?height=237&width=678&top_left_y=266&top_left_x=363)\n(a) Softmax attention. ![](https://cdn.mathpix.com/cropped/2024_09_12_1812cf4ebe91908f3210g-03.jpg?height=243&width=685&top_left_y=266&top_left_x=1075)\n(b) Random feature attention. Figure 1: Computation graphs for softmax attention (left) and random feature attention (right). Here, we assume cross attention with source length $M$ and target length $N$. ### 3.1 RANdOM Feature AtTEntion\n\nRFA builds on an unbiased estimate to $\\exp (\\langle\\cdot, \\cdot\\rangle)$ from Theorem 1 , which we begin with:\n\n$$\n\\begin{aligned}\n\\exp \\left(\\mathbf{x} \\cdot \\mathbf{y} / \\sigma^{2}\\right) & =\\exp \\left(\\|\\mathbf{x}\\|^{2} / 2 \\sigma^{2}+\\|\\mathbf{y}\\|^{2} / 2 \\sigma^{2}\\right) \\exp \\left(-\\|\\mathbf{x}-\\mathbf{y}\\|^{2} / 2 \\sigma^{2}\\right) \\\\\n& \\approx \\exp \\left(\\|\\mathbf{x}\\|^{2} / 2 \\sigma^{2}+\\|\\mathbf{y}\\|^{2} / 2 \\sigma^{2}\\right) \\boldsymbol{\\phi}(\\mathbf{x}) \\cdot \\boldsymbol{\\phi}(\\mathbf{y})\n\\end{aligned}\n$$\n\nThe last line does not have any nonlinear interaction between $\\phi(\\mathbf{x})$ and $\\phi(\\mathbf{y})$, allowing for a linear time/space approximation to attention. For clarity we assume the query and keys are unit vectors $\\square^{2}$\n\n$$\n\\begin{aligned}\n\\operatorname{attn}\\left(\\mathbf{q}_{t},\\left\\{\\mathbf{k}_{i}\\right\\},\\left\\{\\mathbf{v}_{i}\\right\\}\\right) & =\\sum_{i} \\frac{\\exp \\left(\\mathbf{q}_{t} \\cdot \\mathbf{k}_{i} / \\sigma^{2}\\right)}{\\sum_{j} \\exp \\left(\\mathbf{q}_{t} \\cdot \\mathbf{k}_{j} / \\sigma^{2}\\right)} \\mathbf{v}_{i}^{\\top} \\\\\n& \\approx \\sum_{i} \\frac{\\phi\\left(\\mathbf{q}_{t}\\right)^{\\top} \\boldsymbol{\\phi}\\left(\\mathbf{k}_{i}\\right) \\mathbf{v}_{i}^{\\top}}{\\sum_{j} \\phi\\left(\\mathbf{q}_{t}\\right) \\cdot \\boldsymbol{\\phi}\\left(\\mathbf{k}_{j}\\right)} \\\\\n& =\\frac{\\phi\\left(\\mathbf{q}_{t}\\right)^{\\top} \\sum_{i} \\boldsymbol{\\phi}\\left(\\mathbf{k}_{i}\\right) \\otimes \\mathbf{v}_{i}}{\\phi\\left(\\mathbf{q}_{t}\\right) \\cdot \\sum_{j} \\boldsymbol{\\phi}\\left(\\mathbf{k}_{j}\\right)}=\\operatorname{RFA}\\left(\\mathbf{q}_{t},\\left\\{\\mathbf{k}_{i}\\right\\},\\left\\{\\mathbf{v}_{i}\\right\\}\\right)\n\\end{aligned}\n$$\n\n$\\otimes$ denotes the outer product between vectors, and $\\sigma^{2}$ corresponds to the temperature term $\\tau$ in Eq. 1\nRFA can be used as a drop-in-replacement for softmax-attention. (a) The input is revealed in full to cross attention and encoder self-attention. Here RFA calculates attention using Eq. 5\n(b) In causal attention RFA attends only to the prefix ${ }^{3}$ This allows for a recurrent computation. Tuple $\\left(\\mathbf{S}_{t} \\in \\mathbb{R}^{2 D \\times d}, \\mathbf{z}_{t} \\in \\mathbb{R}^{2 D}\\right)$ is used as the \"hidden state\" at time step $t$ to keep track of the history, similar to those in RNNs. Then $\\operatorname{RFA}\\left(\\mathbf{q}_{t},\\left\\{\\mathbf{k}_{i}\\right\\}_{i \\leq t},\\left\\{\\mathbf{v}_{i}\\right\\}_{i \\leq t}\\right)=$ $\\phi\\left(\\mathbf{q}_{t}\\right)^{\\top} \\mathbf{S}_{t} /\\left(\\phi\\left(\\mathbf{q}_{t}\\right) \\cdot \\mathbf{z}_{t}\\right)$, where\n\n$$\n\\mathbf{S}_{t}=\\mathbf{S}_{t-1}+\\phi\\left(\\mathbf{k}_{t}\\right) \\otimes \\mathbf{v}_{t}, \\quad \\mathbf{z}_{t}=\\mathbf{z}_{t-1}+\\phi\\left(\\mathbf{k}_{t}\\right)\n$$\n\n$2 D$ denotes the size of $\\phi(\\cdot)$. Appendix A. 1 summarizes the computation procedure of RFA, and Figure 1 compares it against the softmax attention. Appendix A. 3 derives causal RFA in detail. Analogously to the softmax attention, RFA has its multiheaded variant (Vaswani et al., 2017). In our experiments we use causal RFA in a transformer language model ( $\\$ 4.1$, and both cross and causal RFA in the decoder of a sequence-to-sequence machine translation model. ### 3.2 RFA-GATE: LEARNING WITH RECENCy BiAS\n\nThe canonical softmax attention does not have any explicit modeling of distance or locality. In learning problems where such inductive bias is crucial (Ba et al., 2016, Parmar et al., 2018, Miconi et al. 2018; Li et al. 2019, inter alia), transformers heavily rely on positional encodings. Answering to this, many approaches have been proposed, e.g., learning the attention spans Sukhbaatar et al. [^2]2019, Wu et al. 2020), and enhancing the attention computation with recurrent (Hao et al., 2019, Chen et al. 2019) or convolutional (Wu et al. 2019, Mohamed et al. 2019) components. RFA faces the same issue, but its causal attention variant (Eq. 6) offers a straightforward way of learning with recency bias. We draw inspiration from its connections to RNNs, and augment RFA with a learned gating mechanism (Hochreiter \\& Schmidhuber, 1997, Cho et al., 2014, Peng et al., 2018, inter alia):\n\n$$\n\\begin{aligned}\ng_{t} & =\\operatorname{sigmoid}\\left(\\mathbf{w}_{g} \\cdot \\mathbf{x}_{t}+b_{g}\\right) \\\\\n\\mathbf{S}_{t} & =g_{t} \\mathbf{S}_{t-1}+\\left(1-g_{t}\\right) \\boldsymbol{\\phi}\\left(\\mathbf{k}_{t}\\right) \\otimes \\mathbf{v}_{t} \\\\\n\\mathbf{z}_{t} & =g_{t} \\mathbf{z}_{t-1}+\\left(1-g_{t}\\right) \\boldsymbol{\\phi}\\left(\\mathbf{k}_{t}\\right)\n\\end{aligned}\n$$\n\n$\\mathbf{w}_{g}$ and $b_{g}$ are learned parameters, and $\\mathbf{x}_{t}$ is the input representation at timestep $t{ }^{4}$ By multiplying the learned scalar gates $0<g_{t}<1$ against the hidden state $\\left(\\mathbf{S}_{t}, \\mathbf{z}_{t}\\right)$, history is exponentially decayed, favoring more recent context. The gating mechanism shows another benefit of RFA: it would be otherwise more difficult to build similar techniques into the softmax attention, where there is no clear sense of \"recurrence\" (Appendix A.5). It proves useful in our language modeling experiments ( $\\$ 4.1$ ). ### 3.3 DISCUSSION\n\nOn query and key norms, and learned random feature variance. Eq. 5 assumes both the query and keys are of norm-1. It therefore approximates a softmax attention that normalizes the queries and keys before multiplying them, and then scales the logits by dividing them by $\\sigma^{2}$. Empirically, this normalization step scales down the logits (Vaswani et al., 2017) and enforces that $-1 \\leq \\mathbf{q}^{\\top} \\mathbf{k} \\leq 1$. In consequence, the softmax outputs would be \"flattened\" if not for $\\sigma$, which can be set a priori as a hyperparameter (Yu et al., 2016; Avron et al., 2017, Sun, 2019, inter alia). Here we instead learn it from data with the reparameterization trick (Kingma \\& Welling, 2014):\n\n$$\n\\widetilde{\\mathbf{w}}_{i} \\sim \\mathcal{N}\\left(\\mathbf{0}, \\mathbf{I}_{d}\\right), \\quad \\mathbf{w}_{i}=\\boldsymbol{\\sigma} \\circ \\widetilde{\\mathbf{w}}_{i}\n$$\n\n$\\mathbf{I}_{d}$ is the $d \\times d$ identity matrix, and $\\circ$ denotes elementwise product between vectors. $d$-dimensional vector $\\sigma$ is learned, but random vectors $\\widetilde{\\mathbf{w}}_{i}$ are not $\\square^{5}$\nThis norm-1 constraint is never mandatory. Rather, we employ it for notation clarity and easier implementation. In preliminary experiments we find it has little impact on the performance when $\\sigma$ is set properly or learned from data. Eq. 12 in Appendix Apresents RFA without imposing it. Going beyond the Gaussian kernel. More broadly, random feature methods can be applied to a family of shift-invariant kernels, with the Gaussian kernel being one of them. In the same family, the order-1 arc-cosine kernel (Cho \\& Saul, 2009) can be approximated with feature map: $\\phi_{\\arccos }(\\mathbf{x})=\\sqrt{1 / D}\\left[\\operatorname{ReLU}\\left(\\mathbf{w}_{1} \\cdot \\mathbf{x}\\right), \\ldots, \\operatorname{ReLU}\\left(\\mathbf{w}_{D} \\cdot \\mathbf{x}\\right)\\right]^{\\top}$ (Alber et al., 2017, ${ }^{6}$ In our experiments, the Gaussian and arc-cosine variants achieve similar performance.",
    "rfa-2": "This supplements the exploration of alternatives to softmax in attention (Tsai et al., 2019; Gao et al., 2019). Relations to prior work. Katharopoulos et al. (2020) inspire the causal attention variant of RFA. They use a feature map based on the exponential linear unit activation (Clevert et al. 2016): elu $(\\cdot)+1$. It significantly underperforms both the baseline and RFA in our controlled experiments, showing the importance of a properly-chosen feature map. Random feature approximation of attention is also explored by a concurrent work (Choromanski et al., 2020), with applications in masked language modeling for proteins. They propose positive random features to approximate softmax, aiming for a lower variance in critical regions. RFA instead normalizes the queries and keys before random projection to reduce variance. Going beyond both, RFA establishes the benefits of random feature methods as a more universal substitute for softmax across all attention variants, facilitating its applications in, e.g., sequence-to-sequence learning. [^3]There are interesting connections between gated RFA and fast weights (Schmidhuber, 1992, 1993, Ba et al., 2016, Miconi et al., 2018, inter alia). Emphasizing recent patterns, they learn a temporal memory to store history similarly to Eqs. 7 . The main difference is that RFA additionally normalizes the output using $\\phi\\left(\\mathbf{q}_{t}\\right) \\cdot \\mathbf{z}$ as in Eq. 6, a by-product of approximating softmax's partition function.",
    "rfa-3": "It is intriguing to study the role of this normalization term, which we leave to future work. ### 3.4 COMPLEXITY ANALYSIS\n\nTime. Scaling linearly in the sequence lengths, RFA needs less computation (in terms of number of operations) for long sequences. This implies speedup wherever the quadratic-time softmax attention cannot be fully-parallelized across time steps. More specifically:\n\n- Significant speedup can be expected in autoregressive decoding, both conditional (e.g., machine translation) and unconditional (e.g., sampling from a language model). For example, $1.9 \\times$ speedup is achieved in our machine translation experiments ( $\\$ 4.2$; ; and more for longer sequences (e.g., $12 \\times$ for 2,048-length ones; $\\$ 5$ ). - Some applications (e.g., language modeling, text classification) reveal inputs to the model in full $\\square^{7}$ When there are enough threads to parallelize softmax attention across time steps, hardly any speedup from RFA can be achieved; when there are not, typically for very long sequences $(>1,000)$, substantial speed gain is possible. For example, RFA does not achieve any speedup when working with 512 -length context ( $\\$ 4.1$, but achieves a $5.3 \\times$ speedup with 4,000-length context ( $\\$ 4.2$ ). Memory. Asymptotically, RFA has a better memory efficiency than its softmax counterpart (linear vs. quadratic). To reach a more practical conclusion, we include in our analysis the cost of the feature maps. $\\phi$ 's memory overhead largely depends on its size $D$. For example, let's consider the cross attention of a decoder. RFA uses $\\mathcal{O}(4 D+2 D d)$ space to store $\\boldsymbol{\\phi}\\left(\\mathbf{q}_{t}\\right), \\sum_{i} \\boldsymbol{\\phi}\\left(\\mathbf{k}_{i}\\right) \\otimes \\mathbf{v}_{i}$, and $\\sum_{i} \\boldsymbol{\\phi}\\left(\\mathbf{k}_{i}\\right)$ (Eq.",
    "rfa-4": "5. line 12 of Algo. 2, 8 In contrast, softmax cross attention stores the encoder outputs with $\\mathcal{O}(M d)$ memory, with $M$ being the source length. In this case RFA has a lower memory overhead when $2 D \\ll M$. Typically $D$ should be no less than $d$ in order for reasonable approximation ( Yu et al. 2016); In a transformer model, $d$ is the size of an attention head, which is usually around 64 or 128 (Vaswani et al. 2017, Ott et al., 2018). This suggests that RFA can achieve significant memory saving with longer sequences, which is supported by our empirical analysis in $\\$ 5$. Further, using moderate sized feature maps is also desirable, so that its overhead does not overshadow the time and memory RFA saves. We experiment with $D$ at $d$ and $2 d$; the benefit of using $D>2 d$ is marginal. Appendix A.6 discusses the time and space complexity in more detail, and Appendix C. 2 studies the effect of random feature size on performance. ## 4 EXPERIMENTS\n\nWe evaluate RFA on language modeling, machine translation, and long text classification. ### 4.1 LANGUAGE MODELING\n\nSetting. We experiment with WikiText-103 (Merity et al., 2017). It is based on English Wikipedia. Table 5 in Appendix B summarizes some of its statistics. We compare the following models:\n\n- BASE is our implementation of the strong transformer-based language model by Baevski \\& Auli (2019). - RFA builds on BASE, but replaces the softmax attention with random feature attention. We experiment with both Gaussian and arc-cosine kernel variants. - RFA-GATE additionally learns a sigmoid gate on top of RFA (\\$3.2). It also has a Gaussian kernel variant and a arc-cosine kernel one 9\n- $\\phi_{\\text {elu }}$ is a baseline to RFA. Instead of the random feature methods it uses the elu $(\\cdot)+1$ feature map, as in Katharopoulos et al. (2020). [^4]To ensure fair comparisons, we use comparable implementations, tuning, and training procedure. All models use a 512 block size during both training and evaluation, i.e., they read as input a segment of 512 consecutive tokens, without access to the context from previous mini-batches. RFA variants use 64 -dimensional random feature maps. We experiment with two model size settings, small (around 38M parameters) and big (around 242M parameters); they are described in Appendix B. 1 along with other implementation details. | Model | Small |  | Big |  |\n| :---: | :---: | :---: | :---: | :---: |\n|  | Dev. | Test | Dev. | Test |\n| BASE | 33.0 | 34.5 | 24.5 | 26.2 |\n| $\\phi_{\\text {elu }}$ (Katharopoulos et al. 2020) | 38.4 | 40.1 | 28.7 | 30.2 |\n| RFA-Gaussian | 33.6 | 35.7 | 25.8 | 27.5 |\n| RFA-arccos | 36.0 | 37.7 | 26.4 | 28.1 |\n| RFA-GATE-Gaussian | 31.3 | 32.7 | 23.2 | 25.0 |\n| RFA-GATE-arccos | 32.8 | 34.0 | 24.8 | 26.3 |\n| RFA-GATE-Gaussian-Stateful | 29.4 | 30.5 | 22.0 | 23.5 |\n\nTable 1: Language model perplexity (lower is better) on the WikiText-103 development and test sets. Bolded numbers outperform BASE. Results. Table 1 compares the models' performance in perplexity on WikiText-103 development and test data. Both kernel variants of RFA, without gating, outperform $\\phi_{\\text {elu }}$ by more than 2.4 and 2.1 test perplexity for the small and big model respectively, confirming the benefits from using random feature approximation ${ }^{10}$ Yet both underperform BASE, with RFA-Gaussian having a smaller gap. Comparing RFA against its gated variants, a more than 1.8 perplexity improvement can be attributed to the gating mechanism; and the gap is larger for small models. Notably, RFA-Gate-Gaussian outperforms BASE under both size settings by at least 1.2 perplexity. In general, RFA models with Gaussian feature maps outperform their arc-cosine counterparts ${ }^{11}$ From the analysis in $\\$ 3.4$ we would not expect speedup by RFA models, nor do we see any in the experiments ${ }^{12}$\nClosing this section, we explore a \"stateful\" variant of RFA-GATE-Gaussian. It passes the last hidden state $\\left(\\mathbf{S}_{t}, \\mathbf{z}_{t}\\right)$ to the next mini-batch during both training and evaluation, a technique commonly used in RNN language models (Merity et al. 2018). This is a consequence of RFA's RNN-style computation, and is less straightforward to be applicable in the vanilla transformer models ${ }^{13}$ From the last row of Table 1 we see that this brings a more than 1.5 test perplexity improvement. ### 4.2 MaChine TranSLATION\n\nDatasets. We experiment with three standard machine translation datasets. - WMT14 EN-DE and EN-FR (Bojar et al., 2014). Our data split and preprocessing follow those of Vaswani et al. (2017). We share the source and target vocabularies within each language pair, with 32,768 byte pair encoding types (BPE; Sennrich et al. 2016). - IWSLT14 DE-EN (Cettolo et al. 2014) is based on TED talks. The preprocessing follows Edunov et al. (2018). Separate vocabularies of 9K/7K BPE types are used for the source and target. Table 5 in Appendix Bsummarizes some statistics of the datasets. [^5]Setting. We compare the RFA variants described in $\\S 4.1$. They build on a BASE model that is our implementation of the base-sized transformer (Vaswani et al, 2017). All RFA models apply random feature attention in decoder cross and causal attention, but use softmax attention in encoders. This setting yields the greatest decoding time and memory savings ( $\\$ 3.4$. We use $128 / 64$ for $D$ in cross/causal attention. RFA-GATE learns sigmoid gates in the decoder causal attention. The $\\phi_{\\text {elu }}$ baseline uses the same setting and applies feature map in both decoder cross and causal attention, but not in the encoders. Further details are described in Appendix B. 2\n\n|  | WMT14 |  |  | IWSLT14 |  |\n| :--- | :---: | :---: | :---: | :---: | :---: |\n| Model | EN-DE | EN-FR |  | DE-EN | Speed |\n| BASE | 28.1 | 39.0 |  | 34.6 | $1.0 \\times$ |\n| $\\phi_{\\text {elu }}$ (Katharopoulos et al. 2020$)$ | 21.3 | 34.0 |  | 29.9 | $2.0 \\times$ |\n| RFA-Gaussian | 28.0 | 39.2 |  | 34.5 | $1.8 \\times$ |\n| RFA-arccos | 28.1 | 38.9 |  | 34.4 | $1.9 \\times$ |\n| RFA-GATE-Gaussian | 28.1 | 39.0 |  | 34.6 | $1.8 \\times$ |\n| RFA-GATE-arccos | 28.2 | 39.2 |  | 34.4 | $1.9 \\times$ |\n\nTable 2: Machine translation test set BLEU. The decoding speed (last column) is relative to BASE. All models are tested on a single TPU v2 accelerator, with batch size 32. Results. Table 2 compares the models' test set BLEU on three machine translation datasets. Overall both Gaussian and arc-cosine variants of RFA achieve similar performance to BASE on all three datasets, significantly outperforming Katharopoulos et al. (2020). Differently from the trends in the language modeling experiments, here the gating mechanism does not lead to substantial gains. Notably, all RFA variants decode more than $1.8 \\times$ faster than BASE. ### 4.3 LONG TEXT ClaSSIFICATION\n\nWe further evaluate RFA's accuracy and efficiency when used as text encoders on three NLP tasks from the recently proposed Long Range Arena benchmark (Tay et al., 2021), designed to evaluate efficient Transformer variants on tasks that require processing long sequences ${ }^{14}$\nExperimental setting and datasets. We compare RFA against baselines on the following datasets:\n\n- ListOps (LO; Nangia \\& Bowman, 2018) aims to diagnose the capability of modelling hierarchically structured data.",
    "rfa-5": "Given a sequence of operations on single-digit integers, the model predicts the solution, also a single-digit integer. It is formulated as a 10-way classification. We follow Tay et al. (2021) and consider sequences with $500-2,000$ symbols. - Character-level text classification with the IMDb movie review dataset (Maas et al., 2011). This is a binary sentiment classification task. - Character-level document retrieval with the ACL Anthology Network (AAN; Radev et al. 2009) dataset. The model classifies whether there is a citation between a pair of papers. To ensure fair comparisons, we implement RFA on top of the transformer baseline by Tay et al. (2021), and closely follow their preprocessing, data split, model size, and training procedure. Speed and memory are evaluated on the IMDb dataset. For our RFA model, we use $D=64$ for the IMDb dataset, and $D=128$ for others.",
    "rfa-6": "We refer the readers to Tay et al.",
    "rfa-7": "(2021) for further details. Results. From Table 3 we can see that RFA outperforms the transformer baseline on two out of the three datasets, achieving the best performance on IMDb with $66 \\%$ accuracy. Averaging across three datasets, RFA outperforms the transformer by $0.3 \\%$ accuracy, second only to Zaheer et al. (2020) with a $0.1 \\%$ accuracy gap. In terms of time and memory efficiency, RFA is among the strongest. RFA speeds up over the transformer by 1.1-5.3\u00d7, varying by sequence length. Importantly, compared to the only two baselines that perform comparably to the baseline transformer model (Tay et al. 2020a, Zaheer et al. 2020), RfA has a clear advantage in both speed and memory efficiency, and is the only model that is competitive in both accuracy and efficiency. 14 https://github.com/google-research/long-range-arena\n\n| Model | Accuracy |  |  |  | Speed |  |  |  | Memory |  |  |  |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n|  | LO | IMDb | AAN | Avg. | 1 K | $2 K$ | 3K | 4K | 1K | $2 K$ | 3 K | 4 K |\n| Transformer | 36.4 | 64.3 | 57.5 | 52.7 | 1.0 | 1.0 | 1.0 | 1.0 | 1.00 | 1.00 | 1.00 | 1.00 |\n| Wang et al. (2020) | 35.7 | 53.9 | 52.3 | 47.3 | 1.2 | 1.9 | 3.7 | 5.5 | 0.44 | 0.21 | 0.18 | 0.10 |\n| Kitaev et al. (2020) | 37.3 | 56.1 | 53.4 | 48.9 | 0.5 | 0.4 | 0.7 | 0.8 | 0.56 | 0.37 | 0.28 | 0.24 |\n| Tay et al. 2020 b | 17.1 | 63.6 | 59.6 | 46.8 | 1.1 | 1.6 | 2.9 | 3.8 | 0.55 | 0.31 | 0.20 | 0.16 |\n| Tay et al. 2020 a) | 37.0 | 61.7 | 54.7 | 51.1 | 1.1 | 1.2 | 2.9 | 1.4 | 0.76 | 0.75 | 0.74 | 0.74 |\n| Zaheer et al. (2020) | 36.0 | 64.0 | 59.3 | 53.1 | 0.9 | 0.8 | 1.2 | 1.1 | 0.90 | 0.56 | 0.40 | 0.30 |\n| Katharopoulos et al. (2020) | 16.1 | 65.9 | 53.1 | 45.0 | 1.1 | 1.9 | 3.7 | 5.6 | 0.44 | 0.22 | 0.14 | 0.11 |\n| Choromanski et al. (2020) | 18.0 | 65.4 | 53.8 | 45.7 | 1.2 | 1.9 | 3.8 | 5.7 | 0.44 | 0.22 | 0.15 | 0.11 |\n| RFA-Gaussian (This work) | 36.8 | 66.0 | 56.1 | 53.0 | 1.1 | 1.7 | 3.4 | 5.3 | 0.53 | 0.30 | 0.21 | 0.16 |\n\nTable 3: Accuracy (higher is better) of different models on LO, IMDb, and AAN, along with their speed (higher is better) and peak memory consumption (lower is better) varying sequence lengths $(1-4 \\mathrm{~K})$. Speed and memory are evaluated on the IMDb dataset and relative to the transformer's. Bold font indicates the best performance in each column, and underlined numbers outperform the transformer in accuracy. Transformer's and previous works' numbers are due to Tay et al. (2021). ![](https://cdn.mathpix.com/cropped/2024_09_12_1812cf4ebe91908f3210g-08.jpg?height=496&width=1372&top_left_y=1013&top_left_x=373)\n\nFigure 2: Conditional decoding speed (left) and memory overhead (right) varying the output lengths. All models are tested on a single TPU v2 accelerator, with greedy decoding and batch size 16 . ## 5 ANALYSIS\n\nDecoding time and memory varying by sequence length. $\\$ 3.4$ shows that RFA can potentially achieve more significant speedup and memory saving for longer sequences, which we now explore. We use a simulation conditional generation experiment on to compare RFA's sequence-to-sequence decoding speed and memory overhead against the baseline's. Here we assume the input and output sequences are of the same length. The compared models are of the same size as those described in $\\$ 4.2$ with 6-layer encoders and decoders. Other hyperparameters are summarized in Appendix B. 2 All models are tested using greedy decoding with the same batch size of 16, on a TPU v2 accelerator. From Figures 2 (a) and (b) we observe clear trends. Varying the lengths, both RFA variants achieve consistent decoding speed with nearly-constant memory overhead. In contrast, the baseline decodes slower for longer sequences, taking an increasing amount of memory. Notably, for 2,048-length sequences, RFA decodes around $12 \\times$ faster than the baseline while using less than $10 \\%$ of the memory. RFA-arccos slightly outperforms RFA-Gaussian in terms of speed and memory efficiency. This is because when using the same $D$ (as we do here), the $\\phi_{\\text {arccos }}$ is half the size of $\\phi_{\\text {Gaussian }}$. These results suggest that RFA can be particularly useful in sequence-to-sequence tasks with longer sequences, e.g., document-level machine translation (Miculicich et al. 2018. Figure 3 in Appendix C.1 compares the speed and memory consumption in unconditional decoding (e.g., sampling from a language model). The overall trends are similar to those in Figure 2\n\nNotes on decoding speed. With a lower memory overhead, RFA can use a larger batch size than the baseline. As noted by Katharopoulos et al. (2020) and Kasai et al. (2021), if we had used mini-\nbatches as large as the hardware allows, RFA could have achieved a more significant speed gain. Nonetheless, we control for batch size even though it is not the most favorable setting for RFA, since the conclusion translates better to common applications where one generates a single sequence at a time (e.g., instantaneous machine translation). For the softmax attention baseline, we follow Ott et al. (2018) and cache previously computed query/key/value representations, which significantly improves its decoding speed (over not caching). Further analysis results. RFA achieves comparable performance to softmax attention. Appendix C. 3 empirically shows that this cannot be attributed to RFA learning a good approximation to softmax: when we train with one attention but evaluate with the other, the performance is hardly better than randomly-initialized untrained models. Yet, an RFA model initialized from a pretrained softmax transformer achieves decent training loss after a moderate amount of finetuning steps (Appendix C.4). This suggests some potential applications, e.g., transferring knowledge from a pretrained transformer (e.g., GPT-3; Brown et al. 2020) to an RFA model that is more efficient to sample from. ## 6 RELATED WORK\n\nOne common motivation across the following studies, that is shared by this work and the research we have already discussed, is to scale transformers to long sequences. Note that there are plenty orthogonal choices for improving efficiency such as weight sharing (Dehghani et al. 2019), quantization (Shen et al., 2020), knowledge distillation (Sanh et al., 2020), and adapters (Houlsby et al. 2019). For a detailed overview we refer the reader to Tay et al. (2020c). Sparse attention patterns. The idea behind these methods is to limit the reception field of attention computation. It motivates earlier attempts in improving attention's efficiency, and still receives lots of interest. The sparse patterns can be set a priori (Liu et al., 2018, Qiu et al., 2020, Ho et al., 2020, You et al., 2020, inter alia) or learned from data (Sukhbaatar et al., 2019, Roy et al., 2020, inter alia). For most of these approaches, it is yet to be empirically verified that they are suitable for large-scale sequence-to-sequence learning; few of them have recorded decoding speed benefits. Compressed context. Wang et al. (2020) compress the context along the timesteps so that the effective sequence length for attention computation is reduced. Another line of work aims to store past context into a memory module with limited size (Lee et al., 2019; Ainslie et al., 2020, Rae et al., 2020, inter alia), so that accessing longer history only moderately increases the overhead. Reminiscent of RNN language models, RFA attends beyond a fixed context window through a stateful computation, without increasing time or memory overhead. ## 7 CONCLUSION\n\nWe presented random feature attention (RFA). It views the softmax attention through the lens of kernel methods, and approximates it with random feature methods. With an optional gating mechanism, RFA provides a straightforward way of learning with recency bias. RFA's time and space complexity is linear in the sequence length. We use RFA as a drop-in substitute for softmax attention in transformer models. On language modeling, machine translation, and long text classification benchmarks, RFA achieves comparable or better performance than strong baselines. In the machine translation experiment, RFA decodes twice as fast. Further time and memory efficiency improvements can be achieved for longer sequences. ## ACKNOWLEDGMENTS\n\nWe would like to thank Phil Blunsom, Chris Dyer, Nando de Freitas, Jungo Kasai, Adhiguna Kuncoro, Dianqi Li, Ofir Press, Lianhui Qin, Swabha Swayamdipta, Sam Thomson, the language team at DeepMind and the ARK group at the University of Washington for their helpful feedback. We also thank Tay Yi for helping run the Long Range Arena experiments, Richard Tanburn for the advice on implementations, and the anonymous reviewers for their thoughtful comments. This work was supported in part by NSF grant 1562364 and a Google Fellowship. Nikolaos Pappas was supported by the Swiss National Science Foundation under grant number P400P2_183911 \"UNISON.\"\n\n## REFERENCES\n\nJoshua Ainslie, Santiago Ontanon, Chris Alberti, Vaclav Cvicek, Zachary Fisher, Philip Pham, Anirudh Ravula, Sumit Sanghai, Qifan Wang, and Li Yang. ETC: Encoding long and structured inputs in transformers.",
    "rfa-8": "In Proc. of EMNLP, 2020. Maximilian Alber, Pieter-Jan Kindermans, Kristof Sch\u00fctt, Klaus-Robert M\u00fcller, and Fei Sha. An empirical study on the properties of random bases for kernel methods.",
    "rfa-9": "In Proc. of NeurIPS, 2017. Haim Avron, Vikas Sindhwani, Jiyan Yang, and Michael W. Mahoney. Quasi-Monte Carlo feature maps for shift-invariant kernels. Journal of Machine Learning Research, 17(120):1-38, 2016. Haim Avron, L. Kenneth Clarkson, and P. David and Woodruff. Faster kernel ridge regression using sketching and preconditioning.",
    "rfa-10": "SIAM J. Matrix Analysis Applications, 2017. Jimmy Ba, Geoffrey E Hinton, Volodymyr Mnih, Joel Z Leibo, and Catalin Ionescu. Using fast weights to attend to the recent past. In Proc. of NeurIPS, 2016. Alexei Baevski and Michael Auli. Adaptive input representations for neural language modeling. In Proc. of ICLR, 2019. Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. Neural machine translation by jointly learning to align and translate. In Proc. of ICLR, 2015. Iz Beltagy, Matthew E. Peters, and Arman Cohan. Longformer: The long-document transformer.",
    "rfa-11": "arXiv: $2004.05150,2020$. S. Bochner. Harmonic Analysis and the Theory of Probability. University of California Press, 1955. Ond\u0159ej Bojar, Christian Buck, Christian Federmann, Barry Haddow, Philipp Koehn, Johannes Leveling, Christof Monz, Pavel Pecina, Matt Post, Herve Saint-Amand, Radu Soricut, Lucia Specia, and Ale\u0161 Tamchyna. Findings of the 2014 workshop on statistical machine translation. In Proc. of WMT, 2014. Tom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel M. Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. Language models are few-shot learners. arXiv: 2005.14165, 2020. Mauro Cettolo, Jan Niehues, Sebastian St\u00fcker, Luisa Bentivogli, and Marcello Federico. Report on the 11th IWSLT evaluation campaign. In Proc. of IWSLT, 2014. Kehai Chen, Rui Wang, Masao Utiyama, and Eiichiro Sumita. Recurrent positional embedding for neural machine translation. In Proc. of EMNLP, 2019. Rewon Child, Scott Gray, Alec Radford, and Ilya Sutskever. Generating long sequences with sparse transformers. arXiv: 1904.10509, 2019. Kyunghyun Cho, Bart van Merri\u00ebnboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. Learning phrase representations using RNN encoder-decoder for statistical machine translation.",
    "rfa-12": "In Proc. of EMNLP, 2014. Youngmin Cho and Lawrence K. Saul. Kernel methods for deep learning. In Proc. of NeurIPS, 2009. Krzysztof Choromanski, Valerii Likhosherstov, David Dohan, Xingyou Song, Andreea Gane, Tamas Sarlos, Peter Hawkins, Jared Davis, Afroz Mohiuddin, Lukasz Kaiser, David Belanger, Lucy Colwell, and Adrian Weller. Rethinking attention with performers. In Proc. of ICLR, 2020. Djork-Arn\u00e9 Clevert, Thomas Unterthiner, and Sepp Hochreiter. Fast and accurate deep network learning by exponential linear units (ELUs).",
    "rfa-13": "In Proc. of ICLR, 2016. Zihang Dai, Zhilin Yang, Yiming Yang, Jaime Carbonell, Quoc Le, and Ruslan Salakhutdinov. Transformer-XL: Attentive language models beyond a fixed-length context.",
    "rfa-14": "In Proc. of ACL, 2019. Mostafa Dehghani, Stephan Gouws, Oriol Vinyals, Jakob Uszkoreit, and Lukasz Kaiser. Universal transformers. In Proc. of ICLR, 2019. Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. BERT: Pre-training of deep bidirectional transformers for language understanding. In Proc. of NAACL, 2019. Sergey Edunov, Myle Ott, Michael Auli, David Grangier, and Marc'Aurelio Ranzato. Classical structured prediction losses for sequence to sequence learning. In Proc. of NAACL, 2018. Yingbo Gao, Christian Herold, Weiyue Wang, and Hermann Ney. Exploring kernel functions in the softmax layer for contextual word classification. In International Workshop on Spoken Language Translation, 2019. Jie Hao, Xing Wang, Baosong Yang, Longyue Wang, Jinfeng Zhang, and Zhaopeng Tu. Modeling recurrence for transformer. In Proc. of NAACL, 2019. Geoffrey Hinton, Oriol Vinyals, and Jeffrey Dean. Distilling the knowledge in a neural network. In NeurIPs Deep Learning and Representation Learning Workshop, 2015. Jonathan Ho, Nal Kalchbrenner, Dirk Weissenborn, and Tim Salimans. Axial attention in multidimensional transformers. arXiv: 1912.12180, 2020. Sepp Hochreiter and J\u00fcrgen Schmidhuber. Long short-term memory. Neural Computation, 9(8): $1735-1780,1997$. Thomas Hofmann, Bernhard Sch\u00f6lkopf, and Alexander J. Smola. Kernel methods in machine learning. Annals of Statistics, 36(3):1171-1220, 2008. Neil Houlsby, Andrei Giurgiu, Stanislaw Jastrzebski, Bruna Morrone, Quentin De Laroussilhe, Andrea Gesmundo, Mona Attariyan, and Sylvain Gelly. Parameter-efficient transfer learning for NLP. In Proc. of ICML, 2019. Jungo Kasai, Nikolaos Pappas, Hao Peng, James Cross, and Noah A. Smith. Deep encoder, shallow decoder: Reevaluating the speed-quality tradeoff in machine translation. In Proc. of ICLR, 2021. Angelos Katharopoulos, Apoorv Vyas, Nikolaos Pappas, and Francois Fleuret. Transformers are rnns: Fast autoregressive transformers with linear attention.",
    "rfa-15": "In Proc. of ICML, 2020. Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In Proc. of ICLR, 2015. Diederik P. Kingma and Max Welling. Auto-encoding variational bayes. In Proc. of ICLR, 2014. Nikita Kitaev, Lukasz Kaiser, and Anselm Levskaya. Reformer: The efficient transformer.",
    "rfa-16": "In Proc. of ICLR, 2020. Juho Lee, Yoonho Lee, Jungtaek Kim, Adam Kosiorek, Seungjin Choi, and Yee Whye Teh. Set transformer: A framework for attention-based permutation-invariant neural networks.",
    "rfa-17": "In Proc. of ICML, 2019. Shiyang Li, Xiaoyong Jin, Yao Xuan, Xiyou Zhou, Wenhu Chen, Yu-Xiang Wang, and Xifeng Yan. Enhancing the locality and breaking the memory bottleneck of transformer on time series forecasting.",
    "rfa-18": "In Proc. of NeurIPS, 2019. Peter J. Liu, Mohammad Saleh, Etienne Pot, Ben Goodrich, Ryan Sepassi, Lukasz Kaiser, and Noam Shazeer. Generating wikipedia by summarizing long sequences.",
    "rfa-19": "In Proc. of ICLR, 2018. Andrew L. Maas, Raymond E. Daly, Peter T. Pham, Dan Huang, Andrew Y. Ng, and Christopher Potts. Learning word vectors for sentiment analysis. In Proc. of ACL, 2011. Stephen Merity, Caiming Xiong, James Bradbury, and Richard Socher. Pointer sentinel mixture models.",
    "rfa-20": "In Proc. of ICLR, 2017. Stephen Merity, Nitish Shirish Keskar, and Richard Socher. Regularizing and Optimizing LSTM Language Models. In Proc. of ICLR, 2018. Thomas Miconi, Kenneth Stanley, and Jeff Clune. Differentiable plasticity: training plastic neural networks with backpropagation.",
    "rfa-21": "In Proc. of ICML, 2018. Lesly Miculicich, Dhananjay Ram, Nikolaos Pappas, and James Henderson. Document-level neural machine translation with hierarchical attention networks. In Proc. of EMNLP, 2018. Abdelrahman Mohamed, Dmytro Okhonko, and Luke Zettlemoyer. Transformers with convolutional context for ASR.",
    "rfa-22": "arXiv: 1904.11660, 2019. Nikita Nangia and Samuel Bowman. ListOps: A diagnostic dataset for latent tree learning. In Proc. of NAACL Student Research Workshop, 2018. Junier Oliva, William Neiswanger, Barnabas Poczos, Eric Xing, Hy Trac, Shirley Ho, and Jeff Schneider. Fast function to function regression.",
    "rfa-23": "In Proc. of AISTATS, 2015. Myle Ott, Sergey Edunov, David Grangier, and Michael Auli. Scaling neural machine translation. In Proc. of WMT, 2018. Emilio Parisotto, H. Francis Song, Jack W. Rae, Razvan Pascanu, Caglar Gulcehre, Siddhant M. Jayakumar, Max Jaderberg, Raphael Lopez Kaufman, Aidan Clark, Seb Noury, Matthew M. Botvinick, Nicolas Heess, and Raia Hadsell. Stabilizing transformers for reinforcement learning. In Proc. of ICML, 2020. Niki Parmar, Ashish Vaswani, Jakob Uszkoreit, Lukasz Kaiser, Noam Shazeer, Alexander Ku, and Dustin Tran. Image transformer. In Proc. of ICML, 2018. Hao Peng, Roy Schwartz, Sam Thomson, and Noah A. Smith. Rational recurrences. In Proc. of EMNLP, 2018. Hao Peng, Roy Schwartz, Dianqi Li, and Noah A. Smith. A mixture of $h-1$ heads is better than $h$ heads. In Proc. of ACL, 2020. Matt Post. A call for clarity in reporting BLEU scores.",
    "rfa-24": "In Proc. of WMT, 2018. Jiezhong Qiu, Hao Ma, Omer Levy, Wen-tau Yih, Sinong Wang, and Jie Tang. Blockwise selfattention for long document understanding. In Findings of EMNLP, 2020. Dragomir R. Radev, Pradeep Muthukrishnan, and Vahed Qazvinian. The ACL Anthology network. In Proc. of the Workshop on Text and Citation Analysis for Scholarly Digital Libraries, 2009. Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, and Ilya Sutskever. Language models are unsupervised multitask learners, 2018.",
    "rfa-25": "Jack W. Rae, Anna Potapenko, Siddhant M. Jayakumar, Chloe Hillier, and Timothy P. Lillicrap. Compressive transformers for long-range sequence modelling. In Proc. of ICLR, 2020. Ali Rahimi and Benjamin Recht. Random features for large-scale kernel machines. In Proc. of NeurIPS, 2007. Ankit Singh Rawat, Jiecao Chen, Felix Xinnan X Yu, Ananda Theertha Suresh, and Sanjiv Kumar. Sampled softmax with random Fourier features.",
    "rfa-26": "In Proc. of NeurIPS, 2019. Aurko Roy, Mohammad Taghi Saffar, David Grangier, and Ashish Vaswani. Efficient content-based sparse attention with routing transformers. arXiv: 2003.05997, 2020. Victor Sanh, Lysandre Debut, Julien Chaumond, and Thomas Wolf. DistilBERT, a distilled version of BERT: smaller, faster, cheaper and lighter.",
    "rfa-27": "arXiv: 1910.01108, 2020. J. Schmidhuber. Learning to control fast-weight memories: An alternative to dynamic recurrent networks. Neural Computation, 4(1):131-139, 1992. J. Schmidhuber. Reducing the ratio between learning complexity and number of time varying variables in fully recurrent nets.",
    "rfa-28": "In Proc. of ICANN, 1993. Rico Sennrich, Barry Haddow, and Alexandra Birch. Neural machine translation of rare words with subword units. In Proc. of ACL, 2016. Sheng Shen, Zhen Dong, Jiayu Ye, Linjian Ma, Zhewei Yao, Amir Gholami, Michael W. Mahoney, and Kurt Keutzer. Q-BERT: Hessian based ultra low precision quantization of BERT.",
    "rfa-29": "In Proc. of AAAI, 2020. Sainbayar Sukhbaatar, Edouard Grave, Piotr Bojanowski, and Armand Joulin. Adaptive attention span in transformers.",
    "rfa-30": "In Proc. of ACL, 2019. Yitong Sun. Random Features Methods in Supervised Learning. PhD thesis, The University of Michigan, 2019. Yi Tay, Dara Bahri, Donald Metzler, Da-Cheng Juan, Zhe Zhao, and Che Zheng. Synthesizer: Rethinking self-attention in transformer models. arXiv: 2005.00743, 2020a. Yi Tay, Dara Bahri, Liu Yang, Don Metzler, and Da-Cheng Juan. Sparse sinkhorn attention. In Proc. of ICML, 2020b. Yi Tay, Mostafa Dehghani, Dara Bahri, and Donald Metzler. Efficient transformers: A survey. arXiv: 2009.06732, 2020c. Yi Tay, Mostafa Dehghani, Samira Abnar, Yikang Shen, Dara Bahri, Philip Pham, Jinfeng Rao, Liu Yang, Sebastian Ruder, and Donald Metzler. Long range arena: A benchmark for efficient transformers.",
    "rfa-31": "In Proc. of ICLR, 2021. Yao-Hung Hubert Tsai, Shaojie Bai, Makoto Yamada, Louis-Philippe Morency, and Ruslan Salakhutdinov. Transformer dissection: An unified understanding for transformer's attention via the lens of kernel.",
    "rfa-32": "In Proc. of EMNLP, 2019. Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, \u0141 ukasz Kaiser, and Illia Polosukhin. Attention is all you need.",
    "rfa-33": "In Proc. of NeurIPS, 2017. Sinong Wang, Belinda Z. Li, Madian Khabsa, Han Fang, and Hao Ma. Linformer: Self-attention with linear complexity.",
    "rfa-34": "arXiv: 2006.04768, 2020. Ronald J. Williams and David Zipser. A learning algorithm for continually running fully recurrent neural networks. Neural Computation, 1:270-280, 1989. Felix Wu, Angela Fan, Alexei Baevski, Yann Dauphin, and Michael Auli. Pay less attention with lightweight and dynamic convolutions. In Proc. of ICLR, 2019. Zhanghao Wu, Zhijian Liu, Ji Lin, Yujun Lin, and Song Han. Lite transformer with long-short range attention. In Proc. of ICLR, 2020. Weiqiu You, Simeng Sun, and Mohit Iyyer. Hard-coded Gaussian attention for neural machine translation.",
    "rfa-35": "In Proc. of ACL, 2020. Felix Xinnan X Yu, Ananda Theertha Suresh, Krzysztof M Choromanski, Daniel N Holtmann-Rice, and Sanjiv Kumar. Orthogonal random features.",
    "rfa-36": "In Proc. of NeurIPS, 2016. Manzil Zaheer, Guru Guruganesh, Avinava Dubey, Joshua Ainslie, Chris Alberti, Santiago Ontanon, Philip Pham, Anirudh Ravula, Qifan Wang, Li Yang, and Amr Ahmed. Big bird: Transformers for longer sequences. arXiv: 2007.14062, 2020. ## Appendices\n\n## A Random Feature Attention in More Detail\n\n## A. 1 Detailed Computation Procedure\n\nAlgorithms 1 and 2 describe causal and cross random feature attention's computation procedures. ```\nAlgorithm 1 Causal random feature attention. procedure RFA-CAUSAL \\(\\left(\\left\\{\\mathbf{q}_{i}\\right\\}_{i=1}^{N},\\left\\{\\mathbf{k}_{i}\\right\\}_{i=1}^{N},\\left\\{\\mathbf{v}_{i}\\right\\}_{i=1}^{N}\\right)\\)\n        \\(\\triangleright \\mathbf{S}\\) is a \\(D \\times d\\) matrix\n        \\(\\triangleright \\mathbf{z}\\) is a \\(D\\)-dimensional vector\n        \\(\\mathbf{S}, \\mathbf{z} \\leftarrow \\mathbf{0}, \\mathbf{0}\\)\n        for \\(i=\\underset{\\sim}{1}\\) to \\(N\\) do\n            \\(\\widetilde{\\mathbf{q}}_{i}, \\widetilde{\\mathbf{k}}_{i} \\leftarrow \\underset{\\boldsymbol{\\mathbf { s }}}{ }\\left(\\mathbf{q}_{i}\\right), \\phi\\left(\\mathbf{k}_{i}\\right) \\quad \\triangleright\\) Random feature maps\n            \\(\\mathbf{S} \\leftarrow \\mathbf{S}+\\widetilde{\\mathbf{k}}_{i} \\otimes \\mathbf{v}_{i}\\)\n            \\(\\mathbf{z} \\leftarrow \\mathbf{z}+\\widetilde{\\mathbf{k}}_{i}\\)\n            \\(\\mathbf{h}_{i}^{\\top} \\leftarrow \\widetilde{\\mathbf{q}}_{i}^{\\top} \\mathbf{S} /\\left(\\widetilde{\\mathbf{q}}_{i} \\cdot \\mathbf{z}\\right)\\)\n        end for\n        return \\(\\left\\{\\mathbf{h}_{i}\\right\\}_{i=1}^{N}\\)\n    end procedure\nAlgorithm 2 Cross random feature attention. ```\n\n```\n    procedure RFA-CROSS( \\(\\left.\\left\\{\\mathbf{q}_{i}\\right\\}_{i=1}^{N},\\left\\{\\mathbf{k}_{i}\\right\\}_{i=1}^{M},\\left\\{\\mathbf{v}_{i}\\right\\}_{i=1}^{M}\\right)\\)\n        \\(\\triangleright \\mathbf{S}\\) is a \\(D \\times d\\) matrix\n        \\(\\triangleright \\mathbf{z}\\) is a \\(D\\)-dimensional vector\n        \\(\\mathbf{S}, \\mathbf{z} \\leftarrow \\mathbf{0}, \\mathbf{0}\\)\n        for \\(i=1\\) to \\(M\\) do\n            \\(\\widetilde{\\mathbf{k}}_{i} \\leftarrow \\phi\\left(\\mathbf{k}_{i}\\right) \\quad \\triangleright\\) Random feature map\n            \\(\\mathbf{S} \\leftarrow \\mathbf{S}+\\widetilde{\\mathbf{k}}_{i} \\otimes \\mathbf{v}_{i}^{\\top}\\)\n            \\(\\mathbf{z} \\leftarrow \\mathbf{z}+\\widetilde{\\mathbf{k}}_{i}\\)\n        end for\n        for \\(i=1\\) to \\(N\\) do\n            \\(\\widetilde{\\mathbf{q}}_{i} \\leftarrow \\phi\\left(\\mathbf{q}_{i}\\right) \\quad \\triangleright\\) Random feature map\n            \\(\\mathbf{h}_{i}^{\\top} \\leftarrow \\widetilde{\\mathbf{q}}_{i}^{\\top} \\mathbf{S} /\\left(\\widetilde{\\mathbf{q}}_{i} \\cdot \\mathbf{z}\\right)\\)\n        end for\n        return \\(\\left\\{\\mathbf{h}_{i}\\right\\}_{i=1}^{N}\\)\n    end procedure\n```\n\n\n## A. 2 Variance of Random Fourier Features\n\nThe following result is due to Yu et al. (2016). Using the same notation as in $\\$ 2.2$. $$\n\\operatorname{Var}(\\boldsymbol{\\phi}(\\mathbf{x}) \\cdot \\boldsymbol{\\phi}(\\mathbf{y}))=\\frac{1}{2 D}\\left(1-e^{-z^{2}}\\right)^{2}\n$$\n\nwhere $z=\\|\\mathbf{x}-\\mathbf{y}\\| / \\sigma$. ## A. 3 DERIVATION OF CAUSAL RFA\n\nThis section presents a detailed derivation of causal RFA as in $\\$ 3.1$ Following Eq. 5 but changing the attended keys and values to the prefix:\n\n$$\n\\operatorname{RFA}\\left(\\mathbf{q}_{t},\\left\\{\\mathbf{k}_{i}\\right\\}_{i \\leq t},\\left\\{\\mathbf{v}_{i}\\right\\}_{i \\leq t}\\right)=\\frac{\\phi\\left(\\mathbf{q}_{t}\\right)^{\\top} \\sum_{i \\leq t} \\boldsymbol{\\phi}\\left(\\mathbf{k}_{i}\\right) \\otimes \\mathbf{v}_{i}}{\\phi\\left(\\mathbf{q}_{t}\\right) \\cdot \\sum_{j \\leq t} \\boldsymbol{\\phi}\\left(\\mathbf{k}_{j}\\right)}\n$$\n\nLet $\\mathbf{S}_{t} \\triangleq \\sum_{i \\leq t} \\phi\\left(\\mathbf{k}_{i}\\right) \\otimes \\mathbf{v}_{i}$, and $\\mathbf{z}_{t} \\triangleq \\sum_{i \\leq t} \\phi\\left(\\mathbf{k}_{i}\\right)$; both can be calculated recurrently. Assuming $\\mathbf{S}_{0}=\\mathbf{0}$ and $\\mathbf{z}_{0}=\\mathbf{0}$\n\n$$\n\\mathbf{S}_{t}=\\mathbf{S}_{t-1}+\\phi\\left(\\mathbf{k}_{t}\\right) \\otimes \\mathbf{v}_{t}, \\quad \\mathbf{z}_{t}=\\mathbf{z}_{t-1}+\\phi\\left(\\mathbf{k}_{t}\\right), \\quad t \\geq 1\n$$\n\nThis completes the derivation of causal RFA as in $\\S 3.1$\n\n## A. 4 RFA WITHOUT NORM-1 CONStRAINTS\n\n$\\$ 3.1$ assumes that the queries and keys are unit vectors. This norm-1 constraint is not a must. Here we present a RFA without imposing this constraint. Let $C(\\mathbf{x})=\\exp \\left(\\|\\mathbf{x}\\|^{2} / 2 \\sigma^{2}\\right)$. From Eq. 4 we have $\\operatorname{attn}\\left(\\mathbf{q}_{t},\\left\\{\\mathbf{k}_{i}\\right\\},\\left\\{\\mathbf{v}_{i}\\right\\}\\right)=$\n\n$$\n\\begin{aligned}\n\\sum_{i} \\frac{\\exp \\left(\\mathbf{q}_{t} \\cdot \\mathbf{k}_{i} / \\sigma^{2}\\right)}{\\sum_{j} \\exp \\left(\\mathbf{q}_{t} \\cdot \\mathbf{k}_{j} / \\sigma^{2}\\right)} \\mathbf{v}_{i}^{\\top} & \\approx \\sum_{i} \\frac{C\\left(\\mathbf{q}_{t}\\right) C\\left(\\mathbf{k}_{i}\\right) \\boldsymbol{\\phi}\\left(\\mathbf{q}_{t}\\right)^{\\top} \\boldsymbol{\\phi}\\left(\\mathbf{k}_{i}\\right) \\mathbf{v}_{i}^{\\top}}{\\sum_{j} C\\left(\\mathbf{q}_{t}\\right) C\\left(\\mathbf{k}_{j}\\right) \\boldsymbol{\\phi}\\left(\\mathbf{q}_{t}\\right) \\cdot \\boldsymbol{\\phi}\\left(\\mathbf{k}_{j}\\right)} \\\\\n& =\\frac{\\boldsymbol{\\phi}\\left(\\mathbf{q}_{t}\\right)^{\\top} \\sum_{i} C\\left(\\mathbf{k}_{i}\\right) \\boldsymbol{\\phi}\\left(\\mathbf{k}_{i}\\right) \\otimes \\mathbf{v}_{i}}{\\boldsymbol{\\phi}\\left(\\mathbf{q}_{t}\\right) \\cdot \\sum_{j} C\\left(\\mathbf{k}_{j}\\right) \\boldsymbol{\\phi}\\left(\\mathbf{k}_{j}\\right)}\n\\end{aligned}\n$$\n\nThe specific attention computation is similar to those in $\\$ 3.1$ In sum, lifting the norm-1 constraint brings an additional scalar term $C(\\cdot)$. ## A. 5 Relating Rfa-Gate to Softmax Attention\n\nDrawing inspiration from gated RNNs, 3.2 introduces a gated variant of RFA. Now we study its \"softmax counterpart.\"\n\n$$\n\\begin{aligned}\n& \\widetilde{\\mathbf{k}}_{i}=\\mathbf{k}_{i}\\left(1-g_{i}\\right) \\prod_{j=i+1}^{t} g_{j}, \\quad \\widetilde{\\mathbf{v}}_{i}=\\mathbf{v}_{i}\\left(1-g_{i}\\right) \\prod_{j=i+1}^{t} g_{j}, \\quad i=1, \\ldots, t \\\\\n& \\mathbf{h}_{t}=\\operatorname{attn}\\left(\\mathbf{q}_{t},\\left\\{\\widetilde{\\mathbf{k}}_{i}\\right\\}_{i \\leq t},\\left\\{\\widetilde{\\mathbf{v}}_{i}\\right\\}_{i \\leq t}\\right)\n\\end{aligned}\n$$\n\n$\\mathbf{h}_{t}$ is the output at timestep $t$ and is used for onward computation. At each step, all prefix keys and values are decayed by a gate value before calculating the attention. This implies that the attention computation for $\\mathbf{q}_{t+1}$ cannot start until that of $\\mathbf{q}_{t}$ is finished. Combined with the linear complexity of softmax normalization, this amounts to quadratic time in sequence length, even for language modeling training. The above model is less intuitive and more expensive in practice, without the RFA perspective. This shows that RFA brings some benefits in developing new attention models. ## A. 6 DETAILED COMPLEXITY ANALYSIS\n\nTable 4 considers a sequence-to-sequence model, and breaks down the comparisons to training (with teacher forcing; Williams \\& Zipser, 1989) and autoregressive decoding. Here we assume enough threads to fully parallelize softmax attention across timesteps when the inputs are revealed to the model in full. RFA has a lower space complexity, since it never explicitly populates the attention matrices. As for time, RFA trains in linear time, and so does the softmax attention: in teacher-forcing training a standard transformer decoder parallelizes the attention computation across time steps. The trend of the time comparison differs during decoding: when only one output token is produced at a time, RFA decodes linearly in the output length, while softmax attention decodes quadratically. |  |  | Time Complexity |  |  |  | Space Complexity |  |  |\n| :--- | :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Setting | Model | Encoder | Cross | Causal |  | Encoder | Cross | Causal |\n| Training w/ | softmax | $\\mathcal{O}(M)$ | $\\mathcal{O}(M)$ | $\\mathcal{O}(N)$ |  | $\\mathcal{O}\\left(M^{2}\\right)$ | $\\mathcal{O}(M N)$ | $\\mathcal{O}\\left(N^{2}\\right)$ |\n| teacher forcing | RFA | $\\mathcal{O}(M)$ | $\\mathcal{O}(M)$ | $\\mathcal{O}(N)$ |  | $\\mathcal{O}(M)$ | $\\mathcal{O}(M+N)$ | $\\mathcal{O}(N)$ |\n| Decoding | softmax | $\\mathcal{O}(M)$ | $\\mathcal{O}(M N)$ | $\\mathcal{O}\\left(N^{2}\\right)$ |  | $\\mathcal{O}\\left(M^{2}\\right)$ | $\\mathcal{O}(M N)$ | $\\mathcal{O}\\left(N^{2}\\right)$ |\n|  | RFA | $\\mathcal{O}(M)$ | $\\mathcal{O}(M+N)$ | $\\mathcal{O}(N)$ |  | $\\mathcal{O}(M)$ | $\\mathcal{O}(M+N)$ | $\\mathcal{O}(N)$ |\n\nTable 4: Time and space complexity comparisons between RFA and its softmax counterpart in a sequence-to-sequence attentive model, assuming an infinite amount of available threads. $M$ and $N$ denote the lengths of the source and target sequences respectively. Teacher forcing training (Williams \\& Zipser, 1989) and autoregressive decoding are assumed. Blue color indicates the cases where RFA asymptotically outperforms softmax attention.",
    "rfa-37": "| Data | Train | Dev. | Test | Vocab. |\n| :--- | :---: | :---: | :---: | ---: |\n| WikiText-103 | 103 M | 218 K | 246 K | 268 K |\n| WMT14 EN-DE | 4.5 M | 3 K | 3 K | 32 K |\n| WMT14 EN-FR | 4.5 M | 3 K | 3 K | 32 K |\n| IWSLT14 DE-EN | 160 K | 7 K | 7 K | $9 \\mathrm{~K} / 7 \\mathrm{~K}$ |\n\nTable 5: Some statistics for the datasets. WikiText-103 split sizes are in number of tokens, while others are in number of instances. ## B EXPERIMENTAL DETAILS\n\nTable 5 summarizes some statistics of the datasets used in our experiments. Our implementation is based on JAX 15\n\n| \\# Random Matrices | 1 | 50 | 100 | 200 |\n| :--- | :---: | :---: | :---: | :---: |\n| BLEU | 24.0 | 25.7 | 25.8 | 25.8 |\n\nTable 6: WMT14 EN-DE development set performance varying the number of random matrices to sample from during training. No beam search or checkpoint averaging is used. During training, we sample a different random projection matrix for each attention head. Preliminary experiments suggest this performs better than using the same random projection throughout training (Table 6. Our conjecture is that this helps keep the attention heads from \"over committing\" to any particular random projection (Peng et al., 2020). To avoid the overhead of sampling from Gaussian during training, we do this in an offline manner. I.e., before training we construct a pool of random matrices (typically 200), at each training step we draw from the pool. At test time each attention head uses the same random projection, since no accuracy benefit is observed by using different ones for different test instances. ## B. 1 LanguAGE ModeLing\n\nWe compare the models using two model size settings, summarized in Table 7. We use the fixed sinusoidal position embeddings by Vaswani et al. (2017). All models are trained for up to 150 K gradient steps using the Adam optimizer (Kingma \\& Ba, 2015). No $\\ell_{2}$-regularization is used. We apply early stopping based on development set perplexity. All models are trained using 16 TPU v3 accelerators, and tested using a single TPU v2 accelerator. [^6]| Hyperprams. | Small | Big |\n| :--- | :---: | :---: |\n| \\# Layers | 6 | 16 |\n| \\# Heads | 8 | 16 |\n| Embedding Size | 512 | 1024 |\n| Head Size | 64 | 64 |\n| FFN Size | 2048 | 4096 |\n| Batch Size | 64 | 64 |\n| Learning Rate | $\\left[1 \\times 10^{-4}, 2.5 \\times 10^{-4}, 5 \\times 10^{-4}\\right]$ |  |\n| Warmup Steps | 6000 | 6000 |\n| Gradient Clipping Norm | 0.25 | 0.25 |\n| Dropout | $[0.05,0.1]$ | $[0.2,0.25,0.3]$ |\n| Random Feature Map Size | 64 | 64 |\n\nTable 7: Hyperparameters used in the language modeling experiments. ## B. 2 Machine Translation\n\nWMT14. We use the fixed sinusoidal position embeddings by Vaswani et al. (2017). For both EN-DE and EN-FR experiments, we train the models using the Adam (with $\\beta_{1}=0.1, \\beta_{2}=0.98$, and $\\epsilon=10^{-9}$ ) optimizer for up to 350 K gradient steps. We use a batch size of 1,024 instances for EN-DE, while 4,096 for the much larger EN-FR dataset. The learning rate follows that by Vaswani et al. (2017). Early stopping is applied based on development set BLEU. No $\\ell_{2}$ regularization or gradient clipping is used. All models are trained using 16 TPU v3 accelerators, and tested using a single TPU v2 accelerator. Following standard practice, we average 10 most recent checkpoints at test time. We evaluate the models using SacreBLEU (Post, 2018), ${ }^{16}$ A beam search with beam size 4 and length penalty 0.6 is used. Other hyperparameters are summarized in Table 8 . | Hyperprams. | WMT14 | IWSLT14 |\n| :--- | :---: | :---: |\n| \\# Layers | 6 | 6 |\n| \\# Heads | 8 | 8 |\n| Embedding Size | 512 | 512 |\n| Head Size | 64 | 64 |\n| FFN Size | 2048 | 2048 |\n| Warmup Steps | 6000 | 4000 |\n| Dropout | 0.1 | 0.3 |\n| Cross Attention Feature Map | 128 | 128 |\n| Causal Attention Feature Map | 64 | 64 |\n\nTable 8: Hyperparameters used in the machine translation experiments. ## C More AnAlysis Results\n\n## C. 1 More Results on Decoding Speed and MEmory Overhead\n\nFigure 3 compares the RFA's unconditional decoding speed and memory against the softmax attention. The setting is the same as that in $\\S 5$ except that here the models do not have an encoder. This experiment aims to simulate the applications such as sampling from a language model. ## C. 2 Effect of Random Feature Size\n\nThis section studies how the size of $\\phi(\\cdot)$ affects the performance. Table 9 summarize RFAGaussian's performance on WMT14 EN-DE development set. The model and training are the same as that used in $\\$ 4.2$ except random feature size. Recall from $\\$ 2.2$ that the size of $\\phi(\\cdot)$ is $2 D$ for\n\n[^7]![](https://cdn.mathpix.com/cropped/2024_09_12_1812cf4ebe91908f3210g-18.jpg?height=492&width=1385&top_left_y=318&top_left_x=356)\n\nFigure 3: Unconditional decoding speed (left) and memory overhead (right) varying the output lengths. All models are tested on a single TPU v2 accelerator, with greedy decoding and batch size 16 . RFA-Gaussian. When the size of $\\phi(\\cdot)$ is too small ( 32 or 64 for cross attention, 32 for causal attention), training does not converge. We observe accuracy improvements by using random features sufficiently large ( 256 for cross attention and 128 for causal attention); going beyond that, the benefit is marginal. | $\\phi$ Size | 32 | 64 | 128 | 256 | 512 |\n| :--- | :---: | :---: | :---: | :---: | :---: |\n| BLEU | N/A | N/A | 24.9 | 25.8 | 26.0 |\n\n\n| $\\phi$ Size | 32 | 64 | 128 | 256 | 512 |\n| :--- | :---: | :---: | :---: | :---: | :---: |\n| BLEU | N/A | 25.3 | 25.8 | 25.8 | 25.6 |\n\n(a) Varying cross attention $\\phi$ sizes while fixing that of causal attention to be 128 . (b) Varying causal attention $\\phi$ sizes while fixing that of cross attention to be 256 . Table 9: WMT14 EN-DE development set performance of RFA-Gaussian (the size of $\\phi$ is $2 D ; 2.2$ varying the random feature sizes.",
    "rfa-38": "N/A indicates training does not converge. No beam search or checkpoint averaging is used. ## C. 3 Train and Evaluate WITH DiffERENT AtTEntion Functions\n\nRFA achieves comparable performance to its softmax counterpart. Does this imply that it learns a good approximation to the softmax attention? To answer this question, we consider:\n(i) an RFA-Gaussian model initialized from a pretrained softmax-transformer;\n(ii) a softmax-transformer initialized from a pretrained an RFA-Gaussian model. If RFA's good performance can be attributed to learning a good approximation to softmax, both, without finetunining, should perform similarly to the pretrained models. However, this is not the case on IWSLT14 DE-EN. Both pretrained models achieve more than 35.2 development set BLEU. In contrast, (i) and (ii) respectively get 2.3 and 1.1 BLEU without finetuning, hardly beating a randomly-initialized untrained model. This result aligns with the observation by Choromanski et al. (2020), and suggests that it is not the case that RFA performs well because it learns to imitate softmax attention's outputs. ## C. 4 Knowledge Transfer from Softmax Attention to RFA\n\nWe first supplement the observation in Appendix C. 3 by finetuning (i) on the same pretraining data. Figure 4 plots the learning curves. It takes RFA roughly 1,500 steps to reach similar training loss to the pretrained model. As a baseline, \"RFA Reset\" resets the multihead attention parameters (i.e., those for query, key, value, and output projections) to randomly initialized ones. Its learning curve is similar to that of (i), suggesting that the pretrained multihead attention parameters are no more useful to RFA than randomly initialized ones. To further confirm this observation, \"softmax Reset\"\n\n![](https://cdn.mathpix.com/cropped/2024_09_12_1812cf4ebe91908f3210g-19.jpg?height=421&width=638&top_left_y=321&top_left_x=749)\n\nFigure 4: Finetuning an RFA-Gaussian model with its parameters initialized from a pretrained softmax-transformer. \"Reset\" indicates resetting the multihead attention parameters to randomlyinitialized ones. The dashed line indicates the training loss of the pretrained model. resets the multihead attention parameters without changing the attention functions. It converges to the pretraining loss in less than 200 steps. Takeaway. From the above results on IWSLT14, pretrained knowledge in a softmax transformer cannot be directly transferred to an RFA model. However, from Figure 4 and a much larger-scale experiment by Choromanski et al. (2020), we do observe that RFA can recover the pretraining loss, and the computation cost of finetuning is much less than training a model from scratch. This suggests some potential applications. For example, one might be able to initialize an RFA language model from a softmax transformer pretrained on large-scale data (e.g., GPT-3; Brown et al., 2020), and finetune it at a low cost. The outcome would be an RFA model retaining most of the pretraining knowledge, but is much faster and more memory-friendly to sample from.",
    "rfa-39": "We leave such exploration to future work. [^0]:    *The majority of this work was done while these authors were at DeepMind. [^1]:    ${ }^{1} M=N$ in self-attention; they may differ, e.g., in the cross attention of a sequence-to-sequence model. [^2]:    ${ }^{2}$ This can be achieved by $\\ell_{2}$-normalizing the query and keys. See $\\$ 3.3$ for a related discussion. ${ }^{3}$ It is also sometimes called \"decoder self-attention\" or \"autoregressive attention.\"\n\n[^3]:    ${ }^{4}$ In multihead attention Vaswani et al. 2017), $\\mathbf{k}_{t}$ and $\\mathbf{v}_{t}$ are calculated from $\\mathbf{x}_{t}$ using learned affine transformations. ${ }^{5}$ This departs from Eq. 2 by lifting the isotropic assumption imposed on the Gaussian distribution: note the difference between the vector $\\boldsymbol{\\sigma}$ in Eq. 8 and the scalar $\\sigma$ in Eq. 3 We find this improves the performance in practice $(\\$ 54)$, even though the same result in Theorem 1 may not directly apply. ${ }^{6}$ Apart from replacing the sinusoid functions with ReLU, it constructs $\\mathbf{w}_{i}$ in the same way as Eq. 8\n\n[^4]:    ${ }^{7} \\mathrm{~A}$ causal masking is usually used to prevent the model from accessing future tokens in language models. ${ }^{8}$ RFA never constructs the $M \\times 2 D \\times d$ tensor $\\left[\\phi\\left(\\mathbf{k}_{i}\\right) \\otimes \\mathbf{v}_{i}\\right]$, but sequentially processes the sequence. ${ }^{9}$ This gating technique is specific to RFA variants, in the sense that it is less intuitive to apply it in BASE. [^5]:    ${ }^{10}$ All models are trained for 150 K steps; this could be part of the reason behind the suboptimal performance of $\\phi_{\\text {elu }}$ : it may need 3 times more gradient updates to reach similar performance to the softmax attention baseline (Katharopoulos et al. 2020). ${ }^{11}$ We observe that RFA Gaussian variants are more stable and easier to train than the arc-cosine ones as well as $\\phi_{\\text {elu }}$. We conjecture that this is because the outputs of the Gaussian feature maps have an $\\ell_{2}$-norm of 1 , which can help stabilize training. To see why, $\\sin ^{2}(x)+\\cos ^{2}(x)=\\cos (x-x)=1$. ${ }^{12}$ In fact, RFA trains around $15 \\%$ slower than BASE due to the additional overhead from the feature maps. ${ }^{13}$ Some transformer models use a text segment from the previous mini-batch as a prefix Baevski \\& Auli 2019; Dai et al. 2019). Unlike RFA, this gives the model access to only a limited amount of context, and significantly increases the memory overhead. [^6]:    $\\sqrt[15]{\\text { https://github.com/google/jax }}$\n\n[^7]:    ${ }^{16}$ https: / /github.com/mjpost/sacrebleu\n\n"
}