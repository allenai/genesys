{
    "acronym": "rebased",
    "title": "Linear Transformers with Learnable Kernel Functions are Better In-Context Models",
    "seed_ids": [
        "based",
        "mamba",
        "nevertrainscratch",
        "hyena",
        "s5",
        "httyh",
        "lineartransformer",
        "transformer",
        "bert",
        "gpt2"
    ],
    "s2id": "4300adeecf60f0ed1c0ccb9c4b62c0904227bca4",
    "abstract": "Advancing the frontier of subquadratic architectures for Language Models (LMs) is crucial in the rapidly evolving field of natural language processing. Current innovations, including State Space Models, were initially celebrated for surpassing Transformer performance on language modeling tasks. However, these models have revealed deficiencies in essential In-Context Learning capabilities - a domain where the Transformer traditionally shines. The Based model emerged as a hybrid solution, blending a Linear Transformer with a kernel inspired by the Taylor expansion of exponential functions, augmented by convolutional networks. Mirroring the Transformer's in-context adeptness, it became a strong contender in the field. In our work, we present a singular, elegant alteration to the Based kernel that amplifies its In-Context Learning abilities evaluated with the Multi-Query Associative Recall task and overall language modeling process, as demonstrated on the Pile dataset.",
    "authors": [
        "Yaroslav Aksenov",
        "Nikita Balagansky",
        "Sofia Maria Lo Cicero Vaina",
        "Boris Shaposhnikov",
        "Alexey Gorbatovski",
        "Daniil Gavrilov"
    ],
    "venue": "arXiv.org",
    "year": 2024,
    "tldr": "A singular, elegant alteration to the Based kernel is presented that amplifies its In-Context Learning abilities evaluated with the Multi-Query Associative Recall task and overall language modeling process, as demonstrated on the Pile dataset.",
    "citationCount": 0,
    "influentialCitationCount": 0,
    "code": "# -*- coding: utf-8 -*-\n\n\"\"\"\nhttps://github.com/corl-team/rebased/blob/main/flash_linear_attention/fla/layers/rebased_fast.py\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom einops import rearrange\n\nfrom fla.ops.linear_attn import chunk_linear_attn, fused_chunk_linear_attn\nfrom fla.ops.rebased import parallel_rebased, layer_norm_fn\n\n\n\n\n@checkpoint\ndef flatten_diag_outer_product_off1(x, y):\n    z = torch.einsum(\"...i,...j->...ij\", x, y)\n    N = z.size(-1)\n    indicies = torch.triu_indices(N, N, 1)\n    indices2 = torch.arange(0, N)\n    return z[..., indicies[0], indicies[1]], z[..., indices2, indices2]\n\nclass RebasedFeatureMap(nn.Module):\n\n    def __init__(\n        self,\n        head_dim: int,\n        use_gamma: Optional[bool] = True,\n        use_beta: Optional[bool] = True,\n        normalize: Optional[bool] = True\n    ) -> RebasedFeatureMap:\n        super().__init__()\n\n        self.head_dim = head_dim\n        self.use_gamma = use_gamma\n        self.use_beta = use_beta\n        self.normalize = normalize\n\n        self.gamma = None\n        self.beta = None\n        if use_gamma:\n            self.gamma = nn.Parameter(torch.ones(head_dim))\n        if use_beta:\n            self.beta = nn.Parameter(torch.zeros(head_dim))\n\n    def forward(self, x: torch.Tensor, flatten: Optional[bool] = True):\n        if self.use_beta and self.use_gamma and self.normalize:\n            x = layer_norm_fn(x, self.gamma, self.beta)\n        elif self.normalize:\n            x = F.layer_norm(x, (self.head_dim,), self.gamma, self.beta)\n        elif self.use_gamma and self.use_beta:\n            x = torch.addcmul(self.beta, x, self.gamma)\n        elif self.use_gamma:\n            x = x.mul(self.gamma)\n        else:\n            raise RuntimeError(f\"Not supported combination of `use_gamma`, `use_beta` and `normalize`, \"\n                               f\"which is currentlt set as (`{self.use_gamma}`, `{self.use_beta}`, `{self.normalize}`)\")\n        if not flatten:\n            return x\n        x2_1, x2_2 = flatten_diag_outer_product_off1(x, x)\n        # rebased use learnable parameters to approximate any quadratic function\n        return torch.cat([x2_2 * self.head_dim ** -0.5, x2_1 * (2 / self.head_dim) ** 0.5], dim=-1)\n\n\nclass ReBasedLinearAttention(nn.Module):\n    def __init__(\n        self,\n        hidden_size: int,\n        l_max: int = 2048,\n        feature_dim: int = 16,\n        num_key_value_heads: int = 16,\n        num_heads: int = 16,\n        use_gamma: Optional[bool] = True,\n        use_beta: Optional[bool] = True,\n        normalize: Optional[bool] = True,\n        causal: bool = True,\n        eps: float = 1e-5,\n        mode: str = \"parallel\",\n        layer_idx: Optional[int] = None,\n        **kwargs\n    ) -> ReBasedLinearAttention:\n        super().__init__()\n        self.hidden_size = hidden_size\n        self.l_max = l_max\n        self.mode = mode\n        assert self.mode in [\"fused_chunk\", \"parallel\", 'chunk']\n\n        # linear attention\n        self.feature_dim = feature_dim\n        self.num_key_value_heads = num_key_value_heads\n        self.num_heads = num_heads\n        self.head_dim = self.hidden_size // self.num_key_value_heads\n        self.use_gamma = use_gamma\n        self.use_beta = use_beta\n        self.normalize = normalize\n        self.causal = causal\n\n        self.feature_map = RebasedFeatureMap(self.feature_dim, use_gamma, use_beta, normalize)\n        self.q_proj = nn.Linear(self.hidden_size, self.feature_dim * self.num_heads, bias=False)\n        self.k_proj = nn.Linear(self.hidden_size, self.feature_dim * self.num_heads, bias=False)\n        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=False)\n        self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=False)\n        self.dropout = nn.Identity()\n        self.eps = eps\n\n        self.apply(self._initialize_weights)\n\n    def _initialize_weights(self, module: nn.Module):\n        if getattr(module, \"_is_hf_initialized\", False):\n            return\n        if isinstance(module, nn.Linear):\n            nn.init.xavier_uniform_(module.weight, gain=2 ** -2.5)\n            if module.bias is not None:\n                nn.init.zeros_(module.bias)\n        module._is_hf_initialized = True\n\n    def forward(self, hidden_states: torch.Tensor, **kwargs):\n        mode = self.mode\n        q, k, v = self.q_proj(hidden_states), self.k_proj(hidden_states), self.v_proj(hidden_states)\n        q, k, v = map(lambda x: rearrange(x, \"b l (h d) -> b h l d\", h=self.num_heads), [q, k, v])\n        q, k = self.feature_map(q, flatten=(mode != 'parallel')), self.feature_map(k, flatten=(mode != 'parallel'))\n        if mode == \"fused_chunk\":\n            o = fused_chunk_linear_attn(q, k, v, normalize=True, scale=1)\n        elif mode == 'chunk':\n            o = chunk_linear_attn(q, k, v, normalize=True, scale=1)\n        elif mode == 'parallel':\n            assert q.shape[-1] <= 128\n            o = parallel_rebased(q, k, v, self.eps, True, True)\n        o = rearrange(o, \"b h l d -> b l (h d)\")\n        o = self.o_proj(o)\n        o = self.dropout(o)\n        return o\n\n    # https://github.com/HazyResearch/zoology/blob/main/zoology/mixers/based.py#L119\n    def forward_reference(self, hidden_states: torch.Tensor, filters: torch.Tensor = None, *args, **kwargs):\n        \"\"\"\n        x (torch.Tensor): tensor of shape (b, d, l)\n        y (torch.Tensor): tensor of shape (b, d, l)\n        \"\"\"\n        # hidden_states = hidden_states.transpose(1, 2)\n        b, l, _ = hidden_states.size()\n        q, k, v = self.q_proj(hidden_states), self.k_proj(hidden_states), self.v_proj(hidden_states)\n\n        q = q.view(b, l, self.num_heads, self.feature_dim).transpose(1, 2)\n        k = k.view(b, l, self.num_key_value_heads, self.feature_dim).transpose(1, 2)\n        v = v.view(b, l, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n\n        # Linear attention\n        q, k = self.feature_map(q), self.feature_map(k)\n        q, k, v = q.unsqueeze(-2), k.unsqueeze(-2), v.unsqueeze(-1)\n\n        # Compute attention\n        if self.causal:\n            y = ((q * (k * v).cumsum(2)).sum(-1) / ((q * k.cumsum(2)).sum(-1) + self.eps))\n        else:\n            y = ((q * (k * v).sum(2, True)).sum(-1) / ((q * k.sum(2, True)).sum(-1) + self.eps))\n        y = rearrange(y, 'b h l d -> b l (h d)')\n        y = self.o_proj(y.to(hidden_states.dtype))\n        y = self.dropout(y)\n        return y.to(hidden_states.dtype)\n\n\nif __name__ == '__main__':\n    batch = 4\n    seq_len = 1024\n    hidden_size = 1024\n    dtype = torch.float32\n    x = torch.randn(batch, seq_len, hidden_size).to(dtype).cuda().requires_grad_(True)\n    dy = torch.randn(batch, seq_len, hidden_size).to(dtype).cuda()\n    model = ReBasedLinearAttention(hidden_size=hidden_size, mode='parallel').to(dtype).cuda()\n\n    y = model(x)\n    y.backward(dy, retain_graph=True)\n    x_grad, x.grad = x.grad, None\n    print(model.mode)\n    model.mode = 'fused_chunk'\n    y2 = model(x)\n    print(model.mode)\n    y2.backward(dy)\n    # assert y.allclose(y2, 0, 1e-4), breakpoint()\n    # assert x_grad.allclose(x.grad, 0, 1e-4), breakpoint()\n    print(\"Pass\")",
    "description": null,
    "url": null
}