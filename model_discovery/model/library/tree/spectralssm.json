{
    "acronym": "spectralssm",
    "title": "Spectral State Space Models",
    "seed_ids": [
        "resurrectrnn",
        "s4"
    ],
    "s2id": "7bb51177bddf2c6ca1194f36a07d6a6ba75e293c",
    "abstract": "This paper studies sequence modeling for prediction tasks with long range dependencies. We propose a new formulation for state space models (SSMs) based on learning linear dynamical systems with the spectral filtering algorithm (Hazan et al. (2017)). This gives rise to a novel sequence prediction architecture we call a spectral state space model. Spectral state space models have two primary advantages. First, they have provable robustness properties as their performance depends on neither the spectrum of the underlying dynamics nor the dimensionality of the problem. Second, these models are constructed with fixed convolutional filters that do not require learning while still outperforming SSMs in both theory and practice. The resulting models are evaluated on synthetic dynamical systems and long-range prediction tasks of various modalities. These evaluations support the theoretical benefits of spectral filtering for tasks requiring very long range memory.",
    "authors": [
        "Naman Agarwal",
        "Daniel Suo",
        "Xinyi Chen",
        "Elad Hazan"
    ],
    "venue": "arXiv.org",
    "year": 2023,
    "tldr": "A new formulation for state space models (SSMs) based on learning linear dynamical systems with the spectral filtering algorithm (Hazan et al. (2017) gives rise to a novel sequence prediction architecture the authors call a spectral state space model.",
    "citationCount": 3,
    "influentialCitationCount": 0,
    "code": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.nn.init as init\nimport math\n\nfrom convolutions import ConvolutionLayer\nfrom autoregressive import AutoRegressiveCausalInput, AutoRegressiveCausalOutput\n\nclass AR_STULayer(nn.Module):\n    def __init__(self, D_in, D_out, L, K=16, Ku=3, Ky=2, alpha=0.9):\n        super(AR_STULayer, self).__init__()\n\n        #self.bn = nn.BatchNorm1d(D_in)\n\n        # Autoregressive sum for u (input) from Eq. 6\n        self.autoregressive_u = AutoRegressiveCausalInput(D_in, D_out, Ku=Ku)\n\n        # Autoregressive sum for y (output) from Eq. 6\n        self.autoregressive_y = AutoRegressiveCausalOutput(D_out, Ky=Ky, alpha=alpha)\n\n        # Spectral component from Eq. 6\n        self.convolution_layer = ConvolutionLayer(D_in, D_out, L, K)\n\n    def forward(self, u):\n        u = u.permute(0, 2, 1) # Convert to [B, D, L]\n\n        #u = self.bn(u)\n\n        # Spectral channelization and mixing via convolution\n        y = self.convolution_layer(u)\n\n        # Causal auto-regressive process for inputs\n        y = y + self.autoregressive_u(u)\n\n        # Causal auto-regressive process for outputs\n        y = self.autoregressive_y(y)\n\n        y = y.permute(0, 2, 1) # Convert to [B, L, D]\n        return y\n    \n\n\n# Basic MLP feed-forward network like in transformers\nclass FeedForward(nn.Module):\n    def __init__(self, d_in, d_out, mult=4):\n        super(FeedForward, self).__init__()\n\n        # Default init works well for these\n        hidden_size = d_in * mult\n        self.proj_in = nn.Linear(d_in, hidden_size)\n        self.act = nn.GELU()\n        self.proj_out = nn.Linear(hidden_size, d_out)\n\n    def forward(self, x):\n        y = self.proj_in(x)\n        y = self.act(y)\n        y = self.proj_out(y)\n        return y\n\n# Causal average pooling: Output at time T is the average of prior values.\nclass CausalAveragePooling(nn.Module):\n    def __init__(self):\n        super(CausalAveragePooling, self).__init__()\n\n    def forward(self, x):\n        B, L, D = x.shape\n        cumulative_sum = x.cumsum(dim=1)\n        timesteps = torch.arange(1, L + 1, device=x.device).view(1, L, 1).expand(B, L, D)\n        causal_average = cumulative_sum / timesteps\n        return causal_average # [B, L, D]\n\nclass SpectralSSM(nn.Module):\n    def __init__(self, d_in, d_hidden, d_out, L, num_layers=1):\n        super(SpectralSSM, self).__init__()\n        self.d_in = d_in\n        self.d_hidden = d_hidden\n        self.d_out = d_out\n\n        # Fig.5: Embedding Layer\n        # Default init works well for these\n        self.proj_in = nn.Linear(d_in, d_hidden, bias=False)\n\n        # Fig.5: Dense (output) Layer [B, L, d_out]\n        # Default init works well for these\n        self.proj_out = nn.Linear(d_hidden, d_out, bias=False)\n\n        # Repeat num_layers times:\n        self.layers = nn.ModuleList()\n        for _ in range(num_layers):\n            layer = nn.Sequential(\n                AR_STULayer(d_hidden, d_hidden, L), # Fig.5: STU\n                FeedForward(d_hidden, d_hidden) # Fig.5: MLP+Non-LIN\n            )\n            self.layers.append(layer)\n\n        # Fig.5: Time Pool\n        self.time_pool = CausalAveragePooling()\n\n    def reset(self):\n        for layer in self.layers:\n            layer.reset()\n\n    def forward(self, u):\n        y = self.proj_in(u)\n\n        for layer in self.layers:\n            y = y + layer(y)\n\n        # Not sure what the proper operation is here.  The paper does not describe this, and my guess seems wrong.\n        #y = self.time_pool(y)\n\n        y = self.proj_out(y) # [B, L, d_out]\n        return y",
    "description": null,
    "url": null
}