{
    "acronym": "gqa",
    "title": "GQA: Training Generalized Multi-Query Transformer Models from Multi-Head Checkpoints",
    "seed_ids": [],
    "s2id": "5ae6fb6b5a3c7df515ff4a82ac9673bae6a8e200",
    "abstract": "Multi-query attention (MQA), which only uses a single key-value head, drastically speeds up decoder inference. However, MQA can lead to quality degradation, and moreover it may not be desirable to train a separate model just for faster inference. We (1) propose a recipe for uptraining existing multi-head language model checkpoints into models with MQA using 5% of original pre-training compute, and (2) introduce grouped-query attention (GQA), a generalization of multi-query attention which uses an intermediate (more than one, less than number of query heads) number of key-value heads. We show that uptrained GQA achieves quality close to multi-head attention with comparable speed to MQA.",
    "authors": [
        "J. Ainslie",
        "J. Lee-Thorp",
        "Michiel de Jong",
        "Yury Zemlyanskiy",
        "Federico Lebr'on",
        "Sumit K. Sanghai"
    ],
    "venue": "Conference on Empirical Methods in Natural Language Processing",
    "year": 2023,
    "tldr": "This work proposes a recipe for uptraining existing multi-head language model checkpoints into models with MQA using 5% of original pre-training compute, and introduces grouped-query attention (GQA), a generalization of multi- query attention which uses an intermediate number of query heads.",
    "citationCount": 208,
    "influentialCitationCount": 12,
    "code": "from typing import Optional, Tuple, Union\n\nimport torch\nimport torch.nn.functional as F\nfrom einops import einsum, rearrange\nfrom torch import Tensor, nn\n\n\ndef scaled_dot_product_gqa(\n    query: Tensor,\n    key: Tensor,\n    value: Tensor,\n    dropout: float = 0.0,\n    scale: Optional[float] = None,\n    mask: Optional[Tensor] = None,\n    is_causal: Optional[bool] = None,\n    need_weights: bool = False,\n    average_attn_weights: bool = False,\n    force_grouped: bool = False,\n):\n    \"\"\"Scaled dot product attention with support for grouped queries.\n\n    Einstein notation:\n    - b: batch size\n    - n / s: sequence length\n    - h: number of heads\n    - g: number of groups\n    - d: dimension of query/key/value\n\n    Args:\n        query: Query tensor of shape (b, n, h, d)\n        key: Key tensor of shape (b, s, h, d)\n        value: Value tensor of shape (b, s, h, d)\n        dropout: Dropout probability (default: 0.0)\n        scale: Scale factor for query (default: d_query ** 0.5)\n        mask: Mask tensor of shape (b, n, s) or (b, s). If 'ndim == 2', the mask is\n            applied to all 'n' rows of the attention matrix. (default: None)\n        force_grouped: If True, apply grouped-query attention even if the number of\n            heads is equal for query, key, and value. (default: False)\n\n    Returns:\n        2-tuple of:\n        - Attention output with shape (b, n, h, d)\n        - (Optional) Attention weights with shape (b, h, n, s). Only returned if\n          'need_weights' is True.\n    \"\"\"\n    if (mask is not None) and (is_causal is not None):\n        raise ValueError(\n            \"Only one of 'mask' and 'is_causal' should be provided, but got both.\"\n        )\n    elif not query.ndim == key.ndim == value.ndim == 4:\n        raise ValueError(\n            f\"Expected query, key, and value to be 4-dimensional, but got shapes \"\n            f\"{query.shape}, {key.shape}, and {value.shape}.\"\n        )\n\n    # Move sequence length dimension to axis 2.\n    # This makes the attention operations below *much* faster.\n    query = rearrange(query, \"b n h d -> b h n d\")\n    key = rearrange(key, \"b s h d -> b h s d\")\n    value = rearrange(value, \"b s h d -> b h s d\")\n\n    bq, hq, nq, dq = query.shape\n    bk, hk, nk, dk = key.shape\n    bv, hv, nv, dv = value.shape\n    if not (bq == bk == bv and dq == dk == dv):\n        raise ValueError(\n            \"Expected query, key, and value to have the same batch size (dim=0) and \"\n            f\"embedding dimension (dim=3), but got query: {query.shape}, \"\n            f\"key: {key.shape}, and value: {value.shape}.\"\n        )\n    elif (hk != hv) or (nk != nv):\n        raise ValueError(\n            \"Expected key and value to have the same size in dimensions 1 and 2, but \"\n            f\"got key: {key.shape} and value: {value.shape}.\"\n        )\n    elif hq % hk != 0:\n        raise ValueError(\n            \"Expected query heads to be a multiple of key/value heads, but got \"\n            f\"query: {query.shape} and key/value: {key.shape}.\"\n        )\n\n    if scale is None:\n        scale = query.size(-1) ** 0.5\n    query = query / scale\n\n    num_head_groups = hq // hk\n    query = rearrange(query, \"b (h g) n d -> b g h n d\", g=num_head_groups)\n    similarity = einsum(query, key, \"b g h n d, b h s d -> b g h n s\")\n\n    if is_causal:\n        # Mask out the upper triangular portion of the attention matrix. This prevents\n        # the model from attending to tokens in the future.\n        mask = torch.ones((bq, nq, nk), device=query.device, dtype=torch.bool).tril_()\n\n    if mask is not None:\n        # Expand mask to match the shape of the attention matrix.\n        # If mask is 2D, assume that it is applied to the key/value sequence dimension.\n        # Else if mask is 3D, assume that it is applied to the query/key/value sequence\n        # dimension for all attention heads.\n        #\n        # Users could also provide a 4D mask, which is applied to the query/key/value\n        # sequence dimension for each attention head (though I don't have a particular\n        # use case in mind for that).\n        if mask.ndim == 2:\n            mask = rearrange(mask, \"b s -> b () () () s\")\n        elif mask.ndim == 3:\n            mask = rearrange(mask, \"b n s -> b () () n s\")\n        # Mask similarity values by setting them to negative infinity.  This guarantees\n        # that they will not contribute to the softmax computation below.\n        similarity.masked_fill_(~mask, torch.finfo(similarity.dtype).min)\n\n    attention = F.softmax(similarity, dim=-1)\n    if dropout > 0.0:\n        attention = F.dropout(attention, p=dropout)\n\n    # Apply attention matrix to the value Tensor.\n    out = einsum(attention, value, \"b g h n s, b h s d -> b g h n d\")\n    # Move head dimension back to axis 2\n    out = rearrange(out, \"b g h n d -> b n (h g) d\")\n\n    attn_weights: Optional[Tensor] = None\n    if need_weights:\n        # Move the sequence dimensions back to positions 1, 2.  Move the head dimension\n        # to position 3.  This more closely matches the return shape of the attention\n        # output: (b, n, h, d).\n        attn_weights = rearrange(attention, \"b g h n s -> b n s (h g)\")\n        if average_attn_weights:\n            attn_weights = attn_weights.mean(dim=1)\n\n    return out, attn_weights\n\n\nclass MultiheadGQA(nn.Module):\n    \"\"\"Multi-head grouped query attention (GQA) layer.\n\n    Reference:\n        \"GQA: Training Generalized Multi-Query Transformer Models from Multi-Head Checkpoints\"\n        https://arxiv.org/pdf/2305.13245v1.pdf\n\n    GQA is a variant of multihead attention (MHA) that uses fewer write heads\n    (key / value) than query heads.  GQA can be viewed as a generalization of\n    multi-query attention (MQA), which uses a single write head. GQA and MQA give\n    significant speedups over standard MHA in decoder layers, with minimal loss in\n    accuracy. In the paper, GQA is shown to be more accurate than MQA, while still\n    having a significant speedup over MHA.\n\n    NOTE: The original authors only benchmark GQA by adapting the T5 (XL or XXL) model\n    from MHA to GQA.  As a result, they do not mention parameter initialization or\n    layer normalization strategies.  I follow the best practices laid out in the\n    MAGNETO paper, which improves Transformer performance through better parameter\n    initialization and layer norm placement.  See:\n        https://arxiv.org/pdf/2210.06423.pdf, Fig. 2\n    \"\"\"\n\n    def __init__(\n        self,\n        embed_dim: int,\n        query_heads: int,\n        kv_heads: int,\n        dropout: float = 0.0,\n        bias: bool = True,\n        layer_norm: bool = True,\n        layer_norm_eps: float = 1e-5,\n        gamma_init: float = 1.0,\n        device: Optional[Union[torch.device, str]] = None,\n        dtype: Optional[torch.dtype] = None,\n    ):\n        super().__init__()\n        self.query_heads = query_heads\n        self.kv_heads = kv_heads\n        self.dropout = dropout\n        self.layer_norm = layer_norm\n        self.gamma_init = gamma_init\n\n        if self.query_heads % self.kv_heads != 0:\n            raise ValueError(\n                f\"query_heads ({query_heads}) must be divisible by \"\n                f\"kv_heads ({kv_heads})\"\n            )\n        elif (embed_dim % self.query_heads != 0) or (embed_dim % self.kv_heads != 0):\n            raise ValueError(\n                f\"embed_dim ({embed_dim}) must be divisible by \"\n                f\"query_heads ({query_heads}) and kv_heads ({kv_heads})\"\n            )\n\n        head_dim = embed_dim // query_heads\n        if not head_dim % 8 == 0:\n            raise ValueError(\n                f\"head_dim (embed_dim / num_heads = {head_dim}) must be divisible by 8\"\n            )\n        if not head_dim <= 128:\n            raise ValueError(\n                f\"head_dim (embed_dim / num_heads = {head_dim}) must be <= 128\"\n            )\n\n        # Query projection layer is the same as in vanilla MHA.\n        self.q_proj = nn.Linear(\n            embed_dim, embed_dim, bias=bias, device=device, dtype=dtype\n        )\n        # Key/value projection layers have a smaller output dimension, so that\n        # the we have fewer key/value attention heads after reshaping.\n        kv_embed_dim = embed_dim // query_heads * kv_heads\n        self.k_proj = nn.Linear(\n            embed_dim, kv_embed_dim, bias=bias, device=device, dtype=dtype\n        )\n        self.v_proj = nn.Linear(\n            embed_dim, kv_embed_dim, bias=bias, device=device, dtype=dtype\n        )\n        self.norm: Optional[nn.LayerNorm] = None\n        if layer_norm:\n            self.norm = nn.LayerNorm(\n                embed_dim, eps=layer_norm_eps, device=device, dtype=dtype\n            )\n        # Grouped attention output will have the same embedding dimension as the\n        # key/value Tensors.  So the output projection layer needs to accept the\n        # same dimension (kv_embed_dim).\n        self.out_proj = nn.Linear(\n            embed_dim, embed_dim, bias=bias, device=device, dtype=dtype\n        )\n\n        self._reset_parameters()\n\n    def _reset_parameters(self):\n        nn.init.xavier_normal_(self.q_proj.weight)\n        if self.q_proj.bias is not None:\n            nn.init.constant_(self.q_proj.bias, 0)\n        nn.init.xavier_normal_(self.k_proj.weight)\n        if self.k_proj.bias is not None:\n            nn.init.constant_(self.k_proj.bias, 0)\n\n        # NOTE: We follow the initialization strategy from MAGNETO.  See:\n        # https://arxiv.org/pdf/2210.06423.pdf, Fig. 2\n        # Gain (self.gamma_init) should be provided as a keyword argument when\n        # initializing the larger Transformer model, since it requires knowledge\n        # of the number of encoder/decoder layers in the model.\n\n        nn.init.xavier_normal_(self.v_proj.weight, gain=self.gamma_init)\n        if self.v_proj.bias is not None:\n            nn.init.constant_(self.v_proj.bias, 0)\n        nn.init.xavier_normal_(self.out_proj.weight, gain=self.gamma_init)\n        if self.out_proj.bias is not None:\n            nn.init.constant_(self.out_proj.bias, 0)\n\n    def forward(\n        self,\n        query: Tensor,\n        key: Tensor,\n        value: Tensor,\n        need_weights: bool = False,\n        # TODO\n        # attn_mask: Optional[Tensor] = None,\n        is_causal: bool = False,\n        average_attn_weights: bool = False,\n    ) -> Tuple[Tensor, Optional[Tensor]]:\n        # Notation:\n        #   b - batch size\n        #   n - sequence length\n        #   h - number of heads\n        #   d - embedding dimension\n        #\n        # Input shape: (b, n, d)\n        q: Tensor = self.q_proj(query)\n        k: Tensor = self.k_proj(key)\n        v: Tensor = self.v_proj(value)\n\n        # Unfold 'd' dimension into 'h' separate attention heads.\n        q = rearrange(q, \"b n (h d) -> b n h d\", h=self.query_heads)\n        k = rearrange(k, \"b n (h d) -> b n h d\", h=self.kv_heads)\n        v = rearrange(v, \"b n (h d) -> b n h d\", h=self.kv_heads)\n        # Apply attention, then fold 'h' attention heads back into 'd'.\n        x, attn = scaled_dot_product_gqa(\n            query=q,\n            key=k,\n            value=v,\n            # TODO\n            # mask=attn_mask,\n            is_causal=is_causal,\n            need_weights=need_weights,\n            average_attn_weights=average_attn_weights,\n            force_grouped=False,\n        )\n        x = rearrange(x, \"b n h d -> b n (h d)\")\n\n        # NOTE: This is different from 'nn.MultiheadAttention'!  We follow the MAGNETO\n        # architecture (https://arxiv.org/pdf/2210.06423.pdf), which applies an extra\n        # layer norm before the linear output projection.  The cross-attention layer in\n        # the MAGNETO decoder does not include this layer norm, so users have the\n        # option to disable it (layer_norm=False).\n        if self.layer_norm:\n            assert self.norm is not None\n            x = self.norm(x)\n        # Linear projection on attention outputs.\n        x = self.out_proj(x)\n\n        return x, attn",
    "description": null,
    "url": null
}