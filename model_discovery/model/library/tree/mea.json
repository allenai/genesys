{
    "acronym": "mea",
    "title": "Self-attention Does Not Need $O(n^2)$ Memory",
    "seed_ids": [
        "luna",
        "linformer",
        "routingtransformer",
        "reformer"
    ],
    "s2id": "53c3940f35b8b45d55ed49056282e1961954513d",
    "abstract": "We present a very simple algorithm for attention that requires $O(1)$ memory with respect to sequence length and an extension to self-attention that requires $O(\\log n)$ memory. This is in contrast with the frequently stated belief that self-attention requires $O(n^2)$ memory. While the time complexity is still $O(n^2)$, device memory rather than compute capability is often the limiting factor on modern accelerators. Thus, reducing the memory requirements of attention allows processing of longer sequences than might otherwise be feasible. We provide a practical implementation for accelerators that requires $O(\\sqrt{n})$ memory, is numerically stable, and is within a few percent of the runtime of the standard implementation of attention. We also demonstrate how to differentiate the function while remaining memory-efficient. For sequence length 16384, the memory overhead of self-attention is reduced by 59X for inference and by 32X for differentiation.",
    "authors": [
        "M. Rabe",
        "Charles Staats"
    ],
    "venue": "",
    "year": 2021,
    "tldr": "A practical implementation for accelerators that requires $O(\\sqrt{n})$ memory, is numerically stable, and is within a few percent of the runtime of the standard implementation of attention is provided.",
    "citationCount": 94,
    "influentialCitationCount": 7,
    "code": "import torch\nfrom functools import partial\nfrom torch import nn, einsum\nfrom torch.utils.checkpoint import checkpoint\nimport torch.nn.functional as F\n\nfrom einops import rearrange\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):\n    return val if exists(val) else d\n\n# regular attention\n\ndef attention(\n    q, k, v,\n    mask = None,\n    causal = False,\n    attn_bias = None,\n    **kwargs\n):\n    scale = q.shape[-1] ** -0.5\n    q = q * scale\n\n    sim = einsum('b h i d, b h j d -> b h i j', q, k)\n\n    if exists(attn_bias):\n        sim = sim + attn_bias\n\n    mask_value = -torch.finfo(sim.dtype).max\n\n    if exists(mask):\n        if mask.ndim == 2:\n            mask = rearrange(mask, 'b j -> b 1 1 j')\n        sim = sim.masked_fill(~mask, mask_value)\n\n    if causal:\n        i, j = sim.shape[-2:]\n        mask = torch.ones(i, j, device = q.device, dtype = torch.bool).triu(j - i + 1)\n        sim = sim.masked_fill(mask, mask_value)\n\n    sim = sim - sim.amax(dim = -1, keepdim = True).detach()\n    attn = sim.softmax(dim = -1)\n\n    out = einsum('b h i j, b h j d -> b h i d', attn, v)\n    return out\n\n# memory efficient attention\n\ndef summarize_qkv_chunk(q, k, v, mask, attn_bias_chunk, causal, qk_start_indices, dropout):\n    q_start_index, k_start_index, q_chunk_size, k_chunk_size, device = *qk_start_indices, q.shape[-2], k.shape[-2], q.device\n\n    weight = einsum('b h i d, b h j d -> b h i j', q, k)\n\n    if exists(attn_bias_chunk):\n        weight = weight + attn_bias_chunk\n\n    mask_value = -torch.finfo(weight.dtype).max\n\n    if exists(mask):\n        mask = rearrange(mask, 'b j -> b 1 1 j')\n        weight = weight.masked_fill(~mask, mask_value)\n\n    if causal and q_start_index < (k_start_index + k_chunk_size - 1):\n        causal_mask = torch.ones((q_chunk_size, k_chunk_size), dtype = torch.bool, device = device).triu(q_start_index - k_start_index + 1)\n        weight = weight.masked_fill(causal_mask, mask_value)\n\n    weight_max = weight.amax(dim = -1, keepdim = True).detach()\n    weight = weight - weight_max\n\n    exp_weight = weight.exp()\n\n    exp_weight = F.dropout(exp_weight, p = dropout)\n\n    weighted_value = einsum('b h i j, b h j d -> b h i d', exp_weight, v)\n\n    return exp_weight.sum(dim = -1), weighted_value, rearrange(weight_max, '... 1 -> ...')\n\ncheckpointed_summarize_qkv_chunk = partial(checkpoint, summarize_qkv_chunk)\n\ndef memory_efficient_attention(\n    q, k, v,\n    mask = None,\n    causal = False,\n    attn_bias = None,\n    q_bucket_size = 512,\n    k_bucket_size = 1024,\n    eps = 1e-8,\n    dropout = 0.,\n    training = False\n):\n    scale = q.shape[-1] ** -0.5\n    q = q * scale\n\n    # function\n\n    needs_backwards = q.requires_grad or k.requires_grad or v.requires_grad\n    summarize_qkv_fn = checkpointed_summarize_qkv_chunk if needs_backwards else summarize_qkv_chunk\n\n    # chunk all the inputs\n\n    q_chunks = q.split(q_bucket_size, dim = -2)\n    k_chunks = k.split(k_bucket_size, dim = -2)\n    v_chunks = v.split(k_bucket_size, dim = -2)\n    mask_chunks = mask.split(k_bucket_size, dim = -1) if exists(mask) else ((None,) * len(k_chunks))\n\n    if exists(attn_bias):\n        i, j = attn_bias.shape[-2:]\n        attn_bias_chunks = attn_bias.split(q_bucket_size, dim = -2)\n        attn_bias_chunks = list(map(lambda t: t.split(k_bucket_size, dim = -1), attn_bias_chunks))\n\n    # loop through all chunks and accumulate\n\n    out = []\n    for q_index, q_chunk in enumerate(q_chunks):\n        exp_weights = []\n        weighted_values = []\n        weight_maxes = []\n\n        for k_index, (k_chunk, v_chunk, mask_chunk) in enumerate(zip(k_chunks, v_chunks, mask_chunks)):\n            q_start_index = q_index * q_bucket_size\n            k_start_index = k_index * k_bucket_size\n\n            if causal and k_start_index > (q_start_index + q_chunk.shape[-2] - 1):\n                # if chunk is to be all masked out causally, skip\n                continue\n\n            attn_bias_chunk = attn_bias_chunks[q_index][k_index] if exists(attn_bias) else None\n\n            exp_weight_chunk, weighted_value_chunk, weight_max_chunk = summarize_qkv_fn(\n                q_chunk,\n                k_chunk,\n                v_chunk,\n                mask_chunk,\n                attn_bias_chunk,\n                causal,\n                (q_start_index, k_start_index),\n                dropout if training else 0.\n            )\n\n            exp_weights.append(exp_weight_chunk)\n            weighted_values.append(weighted_value_chunk)\n            weight_maxes.append(weight_max_chunk)\n\n        weight_maxes = torch.stack(weight_maxes, dim = -1)\n\n        weighted_values = torch.stack(weighted_values, dim = -1)\n        exp_weights = torch.stack(exp_weights, dim = -1)\n\n        global_max = weight_maxes.amax(dim = -1, keepdim = True)\n        renorm_factor = (weight_maxes - global_max).exp().detach()\n\n        exp_weights = exp_weights * renorm_factor\n        weighted_values = weighted_values * rearrange(renorm_factor, '... c -> ... 1 c')\n\n        all_values = weighted_values.sum(dim = -1)\n        all_weights = exp_weights.sum(dim = -1)\n\n        normalized_values = all_values / (rearrange(all_weights, '... -> ... 1') + eps)\n        out.append(normalized_values)\n\n    return torch.cat(out, dim = -2)\n\n# main class\n\nclass Attention(nn.Module):\n    def __init__(\n        self,\n        *,\n        dim,\n        heads = 8,\n        dim_head = 64,\n        dropout = 0.,\n        causal = False,\n        memory_efficient = False,\n        q_bucket_size = 512,\n        k_bucket_size = 1024\n    ):\n        super().__init__()\n        self.heads = heads\n        self.causal = causal\n        self.dropout = dropout\n        inner_dim = heads * dim_head\n\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, inner_dim * 2, bias = False)\n        self.to_out = nn.Linear(inner_dim, dim, bias = False)\n\n        # memory efficient attention related parameters\n        # can be overriden on forward\n        self.memory_efficient = memory_efficient\n        self.q_bucket_size = q_bucket_size\n        self.k_bucket_size = k_bucket_size\n\n    def forward(\n        self,\n        x,\n        context = None,\n        mask = None,\n        attn_bias = None,\n        memory_efficient = None,\n        q_bucket_size = None,\n        k_bucket_size = None,\n    ):\n        memory_efficient = default(memory_efficient, self.memory_efficient)\n        q_bucket_size = default(q_bucket_size, self.q_bucket_size)\n        k_bucket_size = default(k_bucket_size, self.k_bucket_size)\n\n        h = self.heads\n        context = default(context, x)\n\n        q = self.to_q(x)\n        k, v = self.to_kv(context).chunk(2, dim = -1)\n\n        q, k, v = map(lambda t: rearrange(t, 'b n (h d) -> b h n d', h = h), (q, k, v))\n\n        attn_fn = attention if not memory_efficient else memory_efficient_attention\n\n        out = attn_fn(q, k, v, mask = mask, attn_bias = attn_bias, causal = self.causal, q_bucket_size = q_bucket_size, \n                    k_bucket_size = k_bucket_size, dropout = self.dropout, training = self.training)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)",
    "description": null,
    "url": null
}