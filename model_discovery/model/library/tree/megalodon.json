{
    "acronym": "megalodon",
    "title": "MEGALODON: Efficient LLM Pretraining and Inference with Unlimited Context Length",
    "seed_ids": [
        "ring",
        "yarn",
        "rwkv4",
        "megabyte",
        "mega",
        "brt",
        "flash",
        "s4",
        "roformer",
        "compressivetransformer",
        "transformerxl"
    ],
    "s2id": "e9484cf633985ccef70b0ce46866ce232a81ca4b",
    "abstract": "The quadratic complexity and weak length extrapolation of Transformers limits their ability to scale to long sequences, and while sub-quadratic solutions like linear attention and state space models exist, they empirically underperform Transformers in pretraining efficiency and downstream task accuracy. We introduce Megalodon, a neural architecture for efficient sequence modeling with unlimited context length. Megalodon inherits the architecture of Mega (exponential moving average with gated attention), and further introduces multiple technical components to improve its capability and stability, including complex exponential moving average (CEMA), timestep normalization layer, normalized attention mechanism and pre-norm with two-hop residual configuration. In a controlled head-to-head comparison with Llama2, Megalodon achieves better efficiency than Transformer in the scale of 7 billion parameters and 2 trillion training tokens. Megalodon reaches a training loss of 1.70, landing mid-way between Llama2-7B (1.75) and 13B (1.67). Code: https://github.com/XuezheMax/megalodon",
    "authors": [
        "Xuezhe Ma",
        "Xiaomeng Yang",
        "Wenhan Xiong",
        "Beidi Chen",
        "Lili Yu",
        "Hao Zhang",
        "Jonathan May",
        "Luke Zettlemoyer",
        "Omer Levy",
        "Chunting Zhou"
    ],
    "venue": "arXiv.org",
    "year": 2024,
    "tldr": "In a controlled head-to-head comparison with Llama2, Megalodon achieves better efficiency than Transformer in the scale of 7 billion parameters and 2 trillion training tokens.",
    "citationCount": 8,
    "influentialCitationCount": 0,
    "code": "from typing import Optional, Tuple, List\nimport math\nimport torch\nfrom torch import Tensor\nfrom torch import nn\n\nfrom megalodon.config import ModelConf\n\nimport torch.nn.functional as F\n\nfrom .layer_norm import FusedLayerNorm\nfrom megalodon.utils import get_init_fn\nfrom torch.nn import Parameter\n\nfrom .rotary_positional_embedding import apply_rotary_emb\nfrom .layer_norm import FusedRMSNorm\nfrom .timestep_norm import TimestepNorm\nfrom .complex_exponential_moving_average import MultiHeadComplexEMA\nfrom megalodon.distributed import (\n    get_model_parallel_world_size,\n    get_chunk_parallel_rank,\n)\nfrom megalodon.distributed.utils import divide_and_check_no_remainder\nfrom .model_parallel import (\n    ColumnParallelLinear,\n    RowParallelLinear,\n    gather_from_model_parallel_region,\n)\nfrom .chunk_parallel import (\n    should_send_to_next,\n    should_recv_from_prev,\n    send_to_next_chunk_parallel_region,\n    recv_from_prev_chunk_parallel_region,\n)\n\nfrom .fused_ops import swift_efficient_attention, memory_efficient_dropout\n\n_c2r = torch.view_as_real\n_r2c = torch.view_as_complex\n\n\ndef get_efficient_attention_function(attn_name: str):\n    return {\n        \"swift\": swift_efficient_attention,\n        \"fused\": swift_efficient_attention\n    }[attn_name]\n\n\nclass _InnerAttention(nn.Module):\n    \"\"\"\n    Inner attention\n    \"\"\"\n\n    def __init__(\n        self,\n        z_head_dim: int,\n        v_head_dim: int,\n        n_heads: int,\n        chunk_size: int,\n        dropout: float,\n        efficient_attn: Optional[str],\n    ):\n        super().__init__()\n        self.z_head_dim = z_head_dim\n        self.v_head_dim = v_head_dim\n        self.n_heads = n_heads\n        self.chunk_size = chunk_size\n        self.dropout = dropout\n        self.efficient_attn = efficient_attn\n\n        # efficient attention\n        if self.efficient_attn is not None:\n            self.attn_fn = get_efficient_attention_function(self.efficient_attn)\n            assert self.attn_fn is not None\n        else:\n            self.attn_fn = None\n\n    def forward(\n        self,\n        xq: Tensor,\n        xk: Tensor,\n        xv: Tensor,\n        mask: Optional[Tensor],\n        freqs_cis: Optional[Tensor],\n        cache: Optional[Tuple[Tensor, Tensor, int]] = None,\n    ):\n        bs, slen, _ = xq.shape\n        xq = xq.view(bs, slen, self.n_heads, self.z_head_dim)\n        xk = xk.view(bs, slen, self.n_heads, self.z_head_dim)\n        xv = xv.view(bs, slen, self.n_heads, self.v_head_dim)\n\n        # shorter than a chunk, apply rope before cat cache_kv\n        if slen <= self.chunk_size:\n            xq, xk = apply_rotary_emb(xq, xk, freqs_cis=freqs_cis, backward=False)\n\n        new_cache = None\n        clen = slen\n        if cache is not None:\n            cache_k, cache_v, count = cache\n            xk = torch.cat([cache_k, xk], dim=1)\n            xv = torch.cat([cache_v, xv], dim=1)\n\n            clen = count + slen\n            new_count = clen % self.chunk_size\n            cache_k = xk.detach()[:, (clen - new_count):]\n            cache_v = xv.detach()[:, (clen - new_count):]\n            new_cache = (cache_k, cache_v, new_count)\n\n        if self.chunk_size < slen:\n            nc = slen // self.chunk_size\n            xq = xq.view(bs * nc, self.chunk_size, self.n_heads, self.z_head_dim)\n\n        if self.chunk_size < clen:\n            nc = clen // self.chunk_size\n            xk = xk.view(bs * nc, self.chunk_size, self.n_heads, self.z_head_dim)\n            xv = xv.view(bs * nc, self.chunk_size, self.n_heads, self.v_head_dim)\n\n        # seq length > chunk, apply rope after chunk split\n        if slen > self.chunk_size:\n            xq, xk = apply_rotary_emb(xq, xk, freqs_cis=freqs_cis, backward=False)\n\n        if self.efficient_attn is None:\n            # B*K x H x C x S\n            xq = xq.transpose(1, 2)\n            xk = xk.transpose(1, 2)\n            xv = xv.transpose(1, 2)\n            assert mask is not None\n            # B*K x H x C x C\n            scores = torch.matmul(xq, xk.transpose(2, 3))\n            scores = scores + mask\n            scores = F.softmax(scores, dim=-1, dtype=torch.float32).to(xq)\n            scores = memory_efficient_dropout(scores, self.dropout, self.training)\n            # B*K x H x C x S -> B*k x C x H x S\n            output = torch.matmul(scores, xv)\n            output = output.transpose(1, 2).contiguous()\n        else:\n            assert mask is None\n            if slen == 1 and cache is not None:\n                use_causal_mask = False\n            else:\n                use_causal_mask = True\n            output = self.attn_fn(xq, xk, xv, 1.0, self.dropout, use_causal_mask, self.training)\n\n        output = output.view(bs, slen, -1)\n        return output, new_cache\n\n    def extra_repr(self) -> str:\n        return 'heads={}, z_head_dim={}, v_head_dim={}, chunk={}'.format(self.n_heads, self.z_head_dim, self.v_head_dim, self.chunk_size)\n\n\nclass MovingAverageGatedAttention(nn.Module):\n    \"\"\"Exponential Moving Average Gated Attention.\n    See \"\" for more details.\n    \"\"\"\n\n    def __init__(\n        self,\n        mdim: int,\n        zdim: int,\n        hdim: int,\n        ndim: int,\n        num_heads: int,\n        dropout: float = 0.0,\n        attention_dropout: float = 0.0,\n        hidden_dropout: float = 0.0,\n        chunk_size: int = 2048,\n        efficient_attn: Optional[str] = None,\n        norm_num_groups: Optional[int] = None,\n        norm_affine: bool = True,\n        norm_eps: float = 1e-5,\n        init_mode: str = 'he',\n    ):\n        super().__init__()\n\n        self.mdim = mdim\n        self.hdim = hdim\n        self.zdim = zdim\n        self.ndim = ndim\n        self.num_heads = num_heads\n        self.init_mode = init_mode\n        assert zdim % num_heads == 0 and hdim % num_heads == 0\n        self.z_head_dim = zdim // num_heads\n        self.v_head_dim = hdim // num_heads\n\n        # Divide the weight matrix along the last dimension.\n        model_parallel_world_size = get_model_parallel_world_size()\n        self.local_heads = divide_and_check_no_remainder(num_heads, model_parallel_world_size)\n        self.local_mdim = divide_and_check_no_remainder(mdim, model_parallel_world_size)\n\n        self.chunk_size = chunk_size\n        self.efficient_attn = efficient_attn\n        self.dropout = dropout\n        self.attention_dropout = attention_dropout\n        self.hidden_dropout = hidden_dropout\n\n        self.timenorm = TimestepNorm(mdim, norm_num_groups, eps=norm_eps)\n        self.cema = MultiHeadComplexEMA(mdim, ndim)\n        self.rmsnorm = FusedRMSNorm(mdim, elementwise_affine=norm_affine, eps=norm_eps)\n        self.znorm = FusedRMSNorm(self.z_head_dim, elementwise_affine=False, eps=norm_eps)\n\n        init_fn = get_init_fn(init_mode)\n        self.wv = ColumnParallelLinear(\n            mdim,\n            hdim,\n            bias=True,\n            input_is_parallel=True,\n            gather_output=False,\n            init_method=init_fn\n        )\n        self.wz = ColumnParallelLinear(\n            mdim,\n            zdim,\n            bias=True,\n            input_is_parallel=False,\n            gather_output=False,\n            init_method=init_fn\n        )\n        self.wr = ColumnParallelLinear(\n            mdim,\n            hdim,\n            bias=True,\n            input_is_parallel=False,\n            gather_output=False,\n            init_method=init_fn\n        )\n        self.wh1 = ColumnParallelLinear(\n            mdim,\n            mdim,\n            bias=True,\n            input_is_parallel=False,\n            gather_output=False,\n            init_method=init_fn\n        )\n        self.wh2 = RowParallelLinear(\n            hdim,\n            mdim,\n            bias=False,\n            input_is_parallel=True,\n            parallel_output=True,\n            init_method=init_fn\n        )\n        self.inner_attention = _InnerAttention(\n            self.z_head_dim,\n            self.v_head_dim,\n            self.local_heads,\n            self.chunk_size,\n            self.attention_dropout,\n            efficient_attn\n        )\n        self.gamma = Parameter(torch.zeros(2, self.z_head_dim * self.local_heads))\n        self.beta = Parameter(torch.zeros(2, self.z_head_dim * self.local_heads))\n\n    def _create_empty_prev_tensors(self, x):\n        bsz, seq_len, _ = x.size()\n        chunk_rank = get_chunk_parallel_rank()\n        n_groups = self.timenorm.groups_per_partition\n        ndim = self.cema.ndim\n        dim = self.local_mdim\n        prev_count = torch.full((bsz,), seq_len * chunk_rank, dtype=torch.int64, device=x.device)\n        prev_tensor = torch.empty((bsz, n_groups * 2 + dim * ndim * 2), dtype=torch.float32, device=x.device, requires_grad=self.training)\n        return prev_count, prev_tensor\n\n    def _pack_prev_tensors(self, prev_mean, prev_var, hx):\n        # B x D x N x 2 -> B x (D*N*2)\n        h = _c2r(hx).flatten(1)\n        # B x (G*2+D*N*2)\n        prev_tensor = torch.cat([prev_mean, prev_var, h], dim=-1)\n        return prev_tensor\n\n    def _unpack_prev_tensors(self, x, prev_tensor):\n        bsz = x.size(0)\n        n_groups = self.timenorm.groups_per_partition\n        ndim = self.cema.ndim\n        dim = self.local_mdim\n        prev_mean, prev_var, hx = torch.split(prev_tensor, [n_groups, n_groups, 2 * dim * ndim], dim=-1)\n        prev_mean = prev_mean.to(x)\n        prev_var = prev_var.to(x)\n        hx = _r2c(hx.view(bsz, dim, ndim, 2))\n        return prev_mean, prev_var, hx\n\n    def forward(\n        self,\n        x: Tensor,\n        freqs_cis: Tensor,\n        mask: Optional[Tensor] = None,\n        cache: Optional[Tuple[Tuple[Tensor, Tensor, int], Tuple[Tensor, Tensor, Tensor], Tensor]] = None,\n    ):\n        bsz, seq_len, _ = x.size()\n        residual = x\n\n        if cache is not None:\n            cache_attn, cache_norm, hx = cache\n            prev_count, prev_mean, prev_var = cache_norm\n        elif should_recv_from_prev():\n            prev_count, prev_tensor = self._create_empty_prev_tensors(x)\n            prev_tensor = recv_from_prev_chunk_parallel_region(prev_tensor)\n            prev_mean, prev_var, hx = self._unpack_prev_tensors(x, prev_tensor)\n            cache_attn, cache_norm = None, None\n        else:\n            prev_count, prev_mean, prev_var = None, None, None\n            cache_attn, cache_norm, hx = None, None, None\n\n        # B x L x D\n        out_tsn, prev_count, prev_mean, prev_var = self.timenorm(x, prev_count, prev_mean, prev_var)\n        # B x D x L\n        compute_h = cache_attn is not None or should_send_to_next()\n        out_cema, hx = self.cema(out_tsn.transpose(1, 2), hx, compute_last_state=compute_h)\n\n        if cache is not None:\n            cache_norm = (prev_count.detach(), prev_mean.detach(), prev_var.detach())\n            hx = None if hx is None else hx.detach()\n        elif should_send_to_next():\n            prev_tensor = self._pack_prev_tensors(prev_mean, prev_var, hx)\n            prev_tensor = send_to_next_chunk_parallel_region(prev_tensor)\n            # TODO: more elegent solution to force call bwd of prev_tensor\n            out_cema = out_cema + prev_tensor.to(out_cema).mean() * 0\n\n        out_cema = gather_from_model_parallel_region(out_cema, dim=1)\n        # B x L x D\n        out_cema = out_cema.transpose(1, 2)\n        mx = self.rmsnorm(out_cema)\n        mx = memory_efficient_dropout(mx, self.hidden_dropout, self.training)\n\n        # B x L x S\n        z = self.wz(mx)\n        # B x L x S -> B x L x H x S/H\n        z = z.view(bsz, seq_len, self.local_heads, self.z_head_dim)\n        # B x L x H x S/H -> B x L x S\n        z = self.znorm(z).view(bsz, seq_len, -1)\n        # B x L x S -> B x L x 1 x S -> B x L x 2 x S\n        gamma = (self.gamma + 1.0) / math.sqrt(self.z_head_dim)\n        z = z.unsqueeze(2) * gamma + self.beta\n        # B x L x 2 x S -> B x L x S\n        q, k = torch.unbind(z, dim=2)\n\n        # B x L x E\n        v = F.silu(self.wv(out_tsn))\n        r = F.silu(self.wr(mx))\n\n        # B x L x E\n        attn, cache_attn = self.inner_attention(q, k, v, mask, freqs_cis, cache_attn)\n        attn = memory_efficient_dropout(attn * r, self.hidden_dropout, self.training)\n\n        # B x L x E -> B x L x D\n        h = self.wh1(mx) + self.wh2(attn)\n        h = memory_efficient_dropout(h, self.dropout, self.training)\n\n        # B x L x D\n        out = h + residual\n\n        if cache is not None:\n            cache = (cache_attn, cache_norm, hx)\n\n        return out, cache\n\n    def extra_repr(self) -> str:\n        return 'edim={}, zdim={}, hdim={}, heads={}, chunk={}, eff_attn={}, init={}'.format(self.mdim, self.zdim, self.hdim,\n                                                                                            self.num_heads, self.chunk_size,\n                                                                                            self.efficient_attn, self.init_mode)\n\nclass NormalizedFeedForwardNetwork(nn.Module):\n    def __init__(\n        self,\n        model_dim,\n        ffn_hidden_dim,\n        dropout=0.0,\n        hidden_dropout=0.0,\n        swiglu=False,\n        norm_affine=True,\n        norm_eps=1e-5,\n        rescale=None,\n        init_mode='bert',\n    ):\n        super().__init__()\n\n        self.model_dim = model_dim\n        self.hidden_dim = ffn_hidden_dim\n        self.dropout = dropout\n        self.hidden_dropout = hidden_dropout\n        self.swiglu = swiglu\n        self.rescale_init = rescale\n        self.init_mode = init_mode\n\n        self.norm = FusedLayerNorm(model_dim, elementwise_affine=norm_affine, eps=norm_eps)\n\n        # layers\n        self.fc1 = ColumnParallelLinear(\n            model_dim,\n            ffn_hidden_dim,\n            bias=False,\n            input_is_parallel=False,\n            gather_output=False,\n            init_method=get_init_fn(init_mode),\n        )\n        self.fc2 = RowParallelLinear(\n            ffn_hidden_dim,\n            model_dim,\n            bias=False,\n            input_is_parallel=True,\n            parallel_output=True,\n            init_method=get_init_fn(init_mode),\n        )\n        self.fc3 = ColumnParallelLinear(\n            model_dim,\n            ffn_hidden_dim,\n            bias=False,\n            input_is_parallel=False,\n            gather_output=False,\n            init_method=get_init_fn(init_mode),\n        ) if self.swiglu else None\n\n        if rescale is None:\n            self.register_parameter('alpha', None)\n        else:\n            assert rescale > 0., 'Layer scale init value should be positive.'\n            self.alpha = nn.Parameter(torch.full((model_dim,), rescale))\n\n    def rescale(self, x: torch.Tensor) -> torch.Tensor:\n        return x if self.alpha is None else (self.alpha * x)\n\n    def forward(self, x, residual):\n        # B x L x D\n        x_ = gather_from_model_parallel_region(x)\n        x = self.norm(x_)\n\n        # fc1 & fc3\n        if self.swiglu:\n            hidden = F.silu(self.fc1(x)) * self.fc3(x)\n            hidden = memory_efficient_dropout(hidden, self.hidden_dropout, self.training)\n        else:\n            hidden = F.silu(self.fc1(x))\n            hidden = memory_efficient_dropout(hidden, self.hidden_dropout, self.training)\n\n        # fc2\n        x = self.fc2(hidden)\n        x = memory_efficient_dropout(x, self.dropout, self.training)\n        # residual\n        out = self.rescale(x) + residual\n\n        return out\n\n    def extra_repr(self) -> str:\n        return 'dim={}, hdim={}, swiglu={}, init={}, rescale={}'.format(self.model_dim, self.hidden_dim, self.swiglu,\n                                                                        self.init_mode, self.rescale_init)\n\nclass MegaBlock(nn.Module):\n    def __init__(self, cfg: ModelConf, layer_id: int):\n        super().__init__()\n\n        self.layer_id = layer_id\n\n        self.mega = MovingAverageGatedAttention(\n            mdim=cfg.model_dim,\n            zdim=cfg.z_dim,\n            hdim=cfg.value_dim,\n            num_heads=cfg.num_heads,\n            ndim=cfg.cema_ndim,\n            chunk_size=cfg.chunk_size,\n            efficient_attn=cfg.efficient_attn,\n            dropout=cfg.dropout,\n            attention_dropout=cfg.attention_dropout,\n            hidden_dropout=cfg.hidden_dropout,\n            norm_num_groups=cfg.norm_num_groups,\n            norm_affine=cfg.norm_affine,\n            norm_eps=cfg.norm_eps,\n            init_mode=cfg.init_mode\n        )\n\n        rescale = 0.1 * (0.5 ** layer_id) if cfg.rescale_nffn else None\n        self.nffn = NormalizedFeedForwardNetwork(\n            model_dim=cfg.model_dim,\n            ffn_hidden_dim=cfg.ffn_hidden_dim,\n            swiglu=cfg.swiglu,\n            dropout=cfg.dropout,\n            hidden_dropout=cfg.hidden_dropout,\n            norm_affine=cfg.norm_affine,\n            norm_eps=cfg.norm_eps,\n            rescale=rescale,\n            init_mode=cfg.init_mode\n        )\n\n    def forward(\n        self,\n        x: Tensor,\n        freqs_cis: Tensor,\n        mask: Optional[Tensor] = None,\n        cache: Optional[Tuple[Tuple[Tensor, Tensor, int], Tuple[Tensor, Tensor, Tensor], Tensor]] = None,\n    ):\n        y, cache = self.mega(x, freqs_cis, mask, cache)\n        out = self.nffn(y, x)\n        return out, cache\n",
    "description": null,
    "url": null
}