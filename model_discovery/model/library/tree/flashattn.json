{
    "acronym": "flashattn",
    "title": "FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness",
    "seed_ids": [
        "mea",
        "scatterbrain",
        "performer",
        "bigbird",
        "lineartransformer",
        "linformer",
        "longformer",
        "routingtransformer",
        "reformer",
        "neurallegal",
        "sparsetransformer",
        "butterfly",
        "transformer",
        "gpt2",
        "bert"
    ],
    "s2id": "87c5b281fa43e6f27191b20a8dd694eda1126336",
    "abstract": "Transformers are slow and memory-hungry on long sequences, since the time and memory complexity of self-attention are quadratic in sequence length. Approximate attention methods have attempted to address this problem by trading off model quality to reduce the compute complexity, but often do not achieve wall-clock speedup. We argue that a missing principle is making attention algorithms IO-aware -- accounting for reads and writes between levels of GPU memory. We propose FlashAttention, an IO-aware exact attention algorithm that uses tiling to reduce the number of memory reads/writes between GPU high bandwidth memory (HBM) and GPU on-chip SRAM. We analyze the IO complexity of FlashAttention, showing that it requires fewer HBM accesses than standard attention, and is optimal for a range of SRAM sizes. We also extend FlashAttention to block-sparse attention, yielding an approximate attention algorithm that is faster than any existing approximate attention method. FlashAttention trains Transformers faster than existing baselines: 15% end-to-end wall-clock speedup on BERT-large (seq. length 512) compared to the MLPerf 1.1 training speed record, 3$\\times$ speedup on GPT-2 (seq. length 1K), and 2.4$\\times$ speedup on long-range arena (seq. length 1K-4K). FlashAttention and block-sparse FlashAttention enable longer context in Transformers, yielding higher quality models (0.7 better perplexity on GPT-2 and 6.4 points of lift on long-document classification) and entirely new capabilities: the first Transformers to achieve better-than-chance performance on the Path-X challenge (seq. length 16K, 61.4% accuracy) and Path-256 (seq. length 64K, 63.1% accuracy).",
    "authors": [
        "Tri Dao",
        "Daniel Y. Fu",
        "Stefano Ermon",
        "A. Rudra",
        "Christopher R'e"
    ],
    "venue": "Neural Information Processing Systems",
    "year": 2022,
    "tldr": "This work proposes FlashAttention, an IO-aware exact attention algorithm that uses tiling to reduce the number of memory reads/writes between GPU high bandwidth memory (HBM) and GPU on-chip SRAM, and is optimal for a range of SRAM sizes.",
    "citationCount": 1034,
    "influentialCitationCount": 98,
    "code": "import math\nimport torch\nfrom functools import partial\nfrom torch import nn, einsum\nfrom torch.autograd.function import Function\n\nfrom einops import rearrange\n\n# constants\n\nEPSILON = 1e-10\n\n# helper functions\n\ndef exists(val):\n    return val is not None\n\ndef default(val, d):\n    return val if exists(val) else d\n\n# flash attention forwards and backwards\n\n# flash attention v1 - https://arxiv.org/abs/2205.14135\n# flash attention v2 - https://tridao.me/publications/flash2/flash2.pdf\n\nclass FlashAttentionFunction(Function):\n    @staticmethod\n    @torch.no_grad()\n    def forward(ctx, q, k, v, mask, causal, q_bucket_size, k_bucket_size):\n        \"\"\" Algorithm 1 in the v2 paper \"\"\"\n\n        device = q.device\n        max_neg_value = -torch.finfo(q.dtype).max\n        qk_len_diff = max(k.shape[-2] - q.shape[-2], 0)\n\n        o = torch.zeros_like(q)\n        all_row_sums = torch.zeros((*q.shape[:-1], 1), device = device)\n        all_row_maxes = torch.full((*q.shape[:-1], 1), max_neg_value, device = device)\n\n        scale = (q.shape[-1] ** -0.5)\n\n        num_row_tiles = math.ceil(q.shape[-2] / q_bucket_size)\n        num_col_tiles = math.ceil(k.shape[-2] / k_bucket_size)\n\n        if exists(mask) and mask.ndim == 2:\n            mask = rearrange(mask, 'b n -> b 1 1 n')\n\n        if not exists(mask):\n            col_masks = (None,) * num_col_tiles\n            mask = (col_masks,) * num_row_tiles \n        else:\n            mask = ((mask,) * num_row_tiles) if mask.shape[-2] == 1 else mask.split(q_bucket_size, dim = -2)\n            mask = tuple(((row_mask,) * num_col_tiles) if row_mask.shape[-1] == 1 else row_mask.split(k_bucket_size, dim = -1) for row_mask in mask)\n\n        row_splits = zip(\n            q.split(q_bucket_size, dim = -2),\n            o.split(q_bucket_size, dim = -2),\n            mask,\n            all_row_sums.split(q_bucket_size, dim = -2),\n            all_row_maxes.split(q_bucket_size, dim = -2),\n        )\n\n        for ind, (qc, oc, row_mask, row_sums, row_maxes) in enumerate(row_splits):\n            q_start_index = ind * q_bucket_size - qk_len_diff\n\n            col_splits = zip(\n                k.split(k_bucket_size, dim = -2),\n                v.split(k_bucket_size, dim = -2),\n                row_mask\n            )\n\n            for k_ind, (kc, vc, col_mask) in enumerate(col_splits):\n                k_start_index = k_ind * k_bucket_size\n\n                attn_weights = einsum('... i d, ... j d -> ... i j', qc, kc) * scale\n\n                if exists(col_mask):\n                    attn_weights.masked_fill_(~col_mask, max_neg_value)\n\n                if causal and q_start_index < (k_start_index + k_bucket_size - 1):\n                    causal_mask = torch.ones((qc.shape[-2], kc.shape[-2]), dtype = torch.bool, device = device).triu(q_start_index - k_start_index + 1)\n                    attn_weights.masked_fill_(causal_mask, max_neg_value)\n\n                block_row_maxes = attn_weights.amax(dim = -1, keepdims = True)\n                new_row_maxes = torch.maximum(block_row_maxes, row_maxes)\n\n                exp_weights = torch.exp(attn_weights - new_row_maxes)\n\n                if exists(col_mask):\n                    exp_weights.masked_fill_(~col_mask, 0.)\n\n                block_row_sums = exp_weights.sum(dim = -1, keepdims = True).clamp(min = EPSILON)\n\n                exp_values = einsum('... i j, ... j d -> ... i d', exp_weights, vc)\n\n                exp_row_max_diff = torch.exp(row_maxes - new_row_maxes)\n\n                new_row_sums = exp_row_max_diff * row_sums + block_row_sums\n\n                oc.mul_(exp_row_max_diff).add_(exp_values)\n\n                row_maxes.copy_(new_row_maxes)\n                row_sums.copy_(new_row_sums)\n\n            oc.div_(row_sums)\n\n        lse = all_row_sums.log() + all_row_maxes\n\n        ctx.args = (causal, scale, mask, q_bucket_size, k_bucket_size)\n        ctx.save_for_backward(q, k, v, o, lse)\n\n        return o\n\n    @staticmethod\n    @torch.no_grad()\n    def backward(ctx, do):\n        \"\"\" Algorithm 2 in the v2 paper \"\"\"\n\n        causal, scale, mask, q_bucket_size, k_bucket_size = ctx.args\n        q, k, v, o, lse = ctx.saved_tensors\n\n        device = q.device\n\n        max_neg_value = -torch.finfo(q.dtype).max\n        qk_len_diff = max(k.shape[-2] - q.shape[-2], 0)\n\n        dq = torch.zeros_like(q)\n        dk = torch.zeros_like(k)\n        dv = torch.zeros_like(v)\n\n        row_splits = zip(\n            q.split(q_bucket_size, dim = -2),\n            o.split(q_bucket_size, dim = -2),\n            do.split(q_bucket_size, dim = -2),\n            mask,\n            lse.split(q_bucket_size, dim = -2),\n            dq.split(q_bucket_size, dim = -2)\n        )\n\n        for ind, (qc, oc, doc, row_mask, lsec, dqc) in enumerate(row_splits):\n            q_start_index = ind * q_bucket_size - qk_len_diff\n\n            col_splits = zip(\n                k.split(k_bucket_size, dim = -2),\n                v.split(k_bucket_size, dim = -2),\n                dk.split(k_bucket_size, dim = -2),\n                dv.split(k_bucket_size, dim = -2),\n                row_mask\n            )\n\n            for k_ind, (kc, vc, dkc, dvc, col_mask) in enumerate(col_splits):\n                k_start_index = k_ind * k_bucket_size\n\n                attn_weights = einsum('... i d, ... j d -> ... i j', qc, kc) * scale\n\n                if causal and q_start_index < (k_start_index + k_bucket_size - 1):\n                    causal_mask = torch.ones((qc.shape[-2], kc.shape[-2]), dtype = torch.bool, device = device).triu(q_start_index - k_start_index + 1)\n                    attn_weights.masked_fill_(causal_mask, max_neg_value)\n\n                p = torch.exp(attn_weights - lsec)\n\n                if exists(col_mask):\n                    p.masked_fill_(~col_mask, 0.)\n\n                dv_chunk = einsum('... i j, ... i d -> ... j d', p, doc)\n                dp = einsum('... i d, ... j d -> ... i j', doc, vc)\n\n                D = (doc * oc).sum(dim = -1, keepdims = True)\n                ds = p * scale * (dp - D)\n\n                dq_chunk = einsum('... i j, ... j d -> ... i d', ds, kc)\n                dk_chunk = einsum('... i j, ... i d -> ... j d', ds, qc)\n\n                dqc.add_(dq_chunk)\n                dkc.add_(dk_chunk)\n                dvc.add_(dv_chunk)\n\n        return dq, dk, dv, None, None, None, None\n\n# main class\n\n# just flash attention in plain pytorch\n# it will be way slower than implementing it in CUDA\n# for tinkering and educational purposes\n\nclass FlashAttention(nn.Module):\n    def __init__(\n        self,\n        *,\n        dim,\n        heads = 8,\n        dim_head = 64,\n        causal = False,\n        q_bucket_size = 512,\n        k_bucket_size = 1024\n    ):\n        super().__init__()\n        self.heads = heads\n        self.causal = causal\n\n        inner_dim = heads * dim_head\n\n        self.to_q = nn.Linear(dim, inner_dim, bias = False)\n        self.to_kv = nn.Linear(dim, inner_dim * 2, bias = False)\n        self.to_out = nn.Linear(inner_dim, dim, bias = False)\n\n        # memory efficient attention related parameters\n        # can be overriden on forward\n        self.q_bucket_size = q_bucket_size\n        self.k_bucket_size = k_bucket_size\n\n    def forward(\n        self,\n        x,\n        context = None,\n        mask = None,\n        q_bucket_size = None,\n        k_bucket_size = None,\n    ):\n        q_bucket_size = default(q_bucket_size, self.q_bucket_size)\n        k_bucket_size = default(k_bucket_size, self.k_bucket_size)\n\n        h = self.heads\n        context = default(context, x)\n\n        q = self.to_q(x)\n        k, v = self.to_kv(context).chunk(2, dim = -1)\n\n        q, k, v = map(lambda t: rearrange(t, 'b n (h d) -> b h n d', h = h), (q, k, v))\n\n        out = FlashAttentionFunction.apply(q, k, v, mask, self.causal, q_bucket_size, k_bucket_size)\n\n        out = rearrange(out, 'b h n d -> b n (h d)')\n        return self.to_out(out)",
    "description": null,
    "url": null
}