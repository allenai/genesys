{
    "acronym": "compresscontext",
    "title": "Adapting Language Models to Compress Contexts",
    "seed_ids": [
        "rmt",
        "gpt3",
        "transformerxl"
    ],
    "s2id": "2f7364d8e5cf94315bf8905f57de9c5543e9a4bf",
    "abstract": "Transformer-based language models (LMs) are powerful and widely-applicable tools, but their usefulness is constrained by a finite context window and the expensive computational cost of processing long text documents. We propose to adapt pre-trained LMs into AutoCompressors. These models are capable of compressing long contexts into compact summary vectors, which are then accessible to the model as soft prompts. Summary vectors are trained with an unsupervised objective, whereby long documents are processed in segments and summary vectors from all previous segments are used in language modeling. We fine-tune OPT models on sequences of up to 30,720 tokens and show that AutoCompressors can utilize long contexts to improve perplexity. We evaluate AutoCompressors on in-context learning by compressing task demonstrations. We find that summary vectors are good substitutes for plain-text demonstrations, increasing accuracy while reducing inference cost. Finally, we explore the benefits of pre-computing summary vectors for large corpora by applying summary vectors to retrieval-augmented language modeling. Overall, AutoCompressors emerge as a simple and inexpensive solution for extending the context window of LMs while speeding up inference over long contexts.",
    "authors": [
        "Alexis Chevalier",
        "Alexander Wettig",
        "Anirudh Ajith",
        "Danqi Chen"
    ],
    "venue": "Conference on Empirical Methods in Natural Language Processing",
    "year": 2023,
    "tldr": "AutoCompressors emerge as a simple and inexpensive solution for extending the context window of LMs while speeding up inference over long contexts and the benefits of pre-computing summary vectors for large corpora are explored.",
    "citationCount": 75,
    "influentialCitationCount": 11,
    "code": "import logging\nimport os\nfrom typing import Optional, Union, List, Tuple, Dict\nfrom dataclasses import dataclass\n\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom transformers import OPTForCausalLM\nfrom modeling_flash_llama import LlamaForCausalLM\n\nfrom transformers.modeling_outputs import CausalLMOutputWithPast\n\nimport os\n\nlogger = logging.getLogger(__name__)\n\nPastKVType = Optional[Tuple[Tuple[torch.FloatTensor]]]\n\n@dataclass\nclass SummaryConfig:\n    \"\"\"Keep track of token constitution of current input sequence\"\"\"\n    softprompt_length: int = 0\n    past_key_values_softprompt_length: int = 0\n    summary_length: int = 0\n\n    def reset(self):\n        self.softprompt_length = 0\n        self.past_key_values_softprompt_length = 0\n        self.summary_length = 0\n\n\n@dataclass\nclass CausalACOutputWithPast(CausalLMOutputWithPast):\n    softprompt: Optional[torch.FloatTensor]= None\n\n\nclass AutoCompressorMixin:\n    \"\"\"Mixin class to turn a AutoModelForCausalLM into an AutoCompressor.\"\"\"\n\n    def setup_autocompressor(self, config):\n        \"\"\"Call this function in the subclass __init__ to initialize the autocompressor. Override for custom behaviour\"\"\"\n        assert hasattr(self.config, 'summary_length'), \"Compressor requires a summary_length config parameter\"\n\n        self.summary_config = SummaryConfig()\n\n        if config.summary_length > 0:\n            self.embed_summary = nn.Embedding(config.summary_length, self.get_input_embeddings().embedding_dim)\n\n            input_embeds = self.get_input_embeddings()\n            self.embed_summary.weight.data[:,:] = (\n                input_embeds.weight[config.eos_token_id]\n            )\n\n    def forward_segment(\n        self,\n        softprompt: torch.FloatTensor,\n        segment_embeds: torch.FloatTensor,\n        summary_token_embeds: torch.FloatTensor,\n        segment_attention_mask: torch.LongTensor,\n        past_key_values: PastKVType,\n        output_hidden_states: bool,\n        use_cache: bool,\n        output_attentions: bool,\n        segment_gradient_checkpointing: bool,\n        past_key_values_softprompt_length: int\n    ):\n\n        bsz = segment_embeds.size(0)\n        summary_length = summary_token_embeds.size(1)\n        if past_key_values_softprompt_length > 0: # Softprompt should already be in past_key_values\n            softprompt_length = 0\n            segment_embeds = torch.cat([segment_embeds, summary_token_embeds], dim=1)\n\n            device, attn_dtype = segment_embeds.device, segment_attention_mask.dtype\n            segment_attention_mask = torch.cat([\n                torch.ones(bsz, past_key_values_softprompt_length, device=device, dtype=attn_dtype),\n                segment_attention_mask,\n                torch.ones(bsz, summary_length, device=device, dtype=attn_dtype)\n            ], dim=1)\n        else:\n            softprompt_length = softprompt.size(1)\n            segment_embeds = torch.cat([softprompt, segment_embeds, summary_token_embeds], dim=1)\n\n            device, attn_dtype = segment_embeds.device, segment_attention_mask.dtype\n            segment_attention_mask = torch.cat([\n                torch.ones(bsz, softprompt_length, device=device, dtype=attn_dtype),\n                segment_attention_mask,\n                torch.ones(bsz, summary_length, device=device, dtype=attn_dtype)\n            ], dim=1)\n        \n        def decoder(segment_embeds,\n                    segment_attention_mask,\n                    segment_past_key_values,\n                    softprompt_length,\n                    past_key_values_softprompt_length,\n                    summary_length):\n            self.summary_config.softprompt_length = softprompt_length\n            self.summary_config.past_key_values_softprompt_length = past_key_values_softprompt_length\n            self.summary_config.summary_length = summary_length\n\n            return self.model(\n                inputs_embeds=segment_embeds,\n                attention_mask=segment_attention_mask,\n                past_key_values=segment_past_key_values,\n                use_cache=use_cache,\n                output_attentions=output_attentions,\n                output_hidden_states=output_hidden_states,\n                return_dict=True,)\n\n        if segment_gradient_checkpointing:\n            outputs = torch.utils.checkpoint.checkpoint(\n                decoder, segment_embeds, segment_attention_mask, past_key_values,\n                softprompt_length, past_key_values_softprompt_length, summary_length,\n                use_reentrant=False)\n        else:\n            outputs = decoder(\n                segment_embeds, segment_attention_mask, past_key_values,\n                softprompt_length, past_key_values_softprompt_length, summary_length)\n\n        total_length = outputs.last_hidden_state.size(1)\n        segment_last_hiddens = (\n            outputs.last_hidden_state[:, softprompt_length:total_length - summary_length]\n        )\n        new_softprompt = outputs.last_hidden_state[:, total_length - summary_length:]\n\n        return outputs, segment_last_hiddens, new_softprompt\n\n    def get_past_key_values_len(self, past_key_values):\n        return 0 if past_key_values is None else past_key_values[0][0].size(2)\n\n    def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        head_mask: Optional[torch.Tensor] = None,\n        past_key_values: Union[PastKVType, Dict] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n        segment_lengths: Optional[Union[List[int], int]] = None,\n        softprompt: Optional[torch.FloatTensor] = None,\n        output_softprompt: Optional[bool] = None,\n    ) -> Union[Tuple, CausalLMOutputWithPast]:\n        # We formulate the past_key_values as a tuple where the second entry is the softprompt already in the past key values\n        if past_key_values is not None and isinstance(past_key_values, dict):\n            # Replace softprompt in direct argument with the softprompt in past_key_values\n            past_key_values, softprompt = past_key_values[\"past_key_values\"], past_key_values[\"softprompt\"]\n            past_key_values_softprompt_length = softprompt.size(1)\n        else:\n            past_key_values_softprompt_length = 0\n\n        past_key_values_length = self.get_past_key_values_len(past_key_values) - past_key_values_softprompt_length\n\n        if head_mask is not None:\n            raise ValueError(\"Compressor does not support head_mask\")\n        if inputs_embeds is not None and input_ids is not None:\n            raise ValueError(\"Compressor does not support both input_ids and input_embeds\")\n\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if inputs_embeds is None and input_ids is not None:\n            inputs_embeds = self.get_input_embeddings()(input_ids)\n\n        if self.config.summary_length > 0:\n            summary_token_ids = torch.arange(self.config.summary_length, dtype=torch.long, device=inputs_embeds.device).unsqueeze(0).expand(inputs_embeds.size(0), -1)\n            summary_token_embeds = self.embed_summary(summary_token_ids).to(inputs_embeds.dtype)\n        else:\n            summary_token_embeds = inputs_embeds[:,:0]\n\n        # If no past_key_values are given, we will process the sequence in multiple segments\n        if past_key_values is None:\n            segment_lengths = segment_lengths if segment_lengths is not None else input_ids.size(1)\n\n            if attention_mask is None:\n                attention_mask = torch.ones(\n                    inputs_embeds.size(0), inputs_embeds.size(1), dtype=torch.long, device=inputs_embeds.device\n                )\n\n            inputs_embeds_list = torch.split(inputs_embeds, segment_lengths, dim=1)\n            attention_mask_list = torch.split(attention_mask, segment_lengths, dim=1)\n            summary_token_embeds_list = (\n                (summary_token_embeds,) * (len(inputs_embeds_list) - 1) +\n                (summary_token_embeds if output_softprompt else summary_token_embeds[:,:0,:],)\n            )\n        # With past_key_values we will process the input in a single pass (for generation), except when generting summary vectors\n        else:\n            if attention_mask is None:\n                attention_mask = torch.ones(\n                    inputs_embeds.size(0), inputs_embeds.size(1) + past_key_values_length, dtype=torch.long, device=inputs_embeds.device\n                )\n\n            if use_cache and past_key_values_length + inputs_embeds.size(1) == segment_lengths:\n                output_softprompt = True\n\n                # If we use cache and output softprompt, we need to add a dummy segment to the end to get the past key values of the softprompt\n                inputs_embeds_list = (inputs_embeds, inputs_embeds[:,:0,:])\n                attention_mask_list = (attention_mask, attention_mask[:,:0])\n                summary_token_embeds_list = (summary_token_embeds, summary_token_embeds[:,:0,:])\n            else:\n                inputs_embeds_list = (inputs_embeds,)\n                attention_mask_list = (attention_mask,)\n                summary_token_embeds_list = (summary_token_embeds if output_softprompt else summary_token_embeds[:,:0,:],)\n\n        last_hidden_state_list = []\n        output_attentions_list = []\n        output_hidden_states_list = []\n\n        if softprompt is None:\n            softprompt = inputs_embeds[:,:0,:]\n\n        for step, summary_token_embeds in enumerate(summary_token_embeds_list):\n            is_last_step = step == len(inputs_embeds_list) - 1\n            segment_gradient_checkpointing = (\n                getattr(self.config, \"segment_gradient_checkpointing\", False) and\n                self.training and not is_last_step\n            )\n\n            outputs, segment_hidden_states, new_softprompt = self.forward_segment(\n                softprompt.to(inputs_embeds.dtype), inputs_embeds_list[step], summary_token_embeds, attention_mask_list[step],\n                past_key_values, output_hidden_states, use_cache, output_attentions,\n                segment_gradient_checkpointing, past_key_values_softprompt_length)\n\n            last_hidden_state_list.append(segment_hidden_states)\n\n            if self.config.accumulate_summary:\n                softprompt = torch.cat([softprompt, new_softprompt], dim=1)\n            elif new_softprompt.size(1) > 0:\n                softprompt = new_softprompt\n\n            output_attentions_list.append(outputs.attentions)\n            output_hidden_states_list.append(outputs.hidden_states)\n\n            # No past key values after first step\n            past_key_values = None\n            past_key_values_softprompt_length = 0\n\n        # Output past values of last segment\n        past_key_values = outputs.past_key_values\n\n        # Reset placeholder positions\n        self.summary_config.reset()\n\n        last_hiddens = torch.cat(last_hidden_state_list, dim=1)\n        logits = self.lm_head(last_hiddens).contiguous()\n\n        loss = None\n        if labels is not None:\n            # Shift so that tokens < n predict n\n            shift_logits = logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            loss = F.cross_entropy(shift_logits.view(-1, self.config.vocab_size), shift_labels.view(-1))\n\n        output = CausalACOutputWithPast(\n            loss=loss,\n            logits=logits,\n            past_key_values={\"past_key_values\": past_key_values, \"softprompt\": softprompt},\n            hidden_states=output_hidden_states_list if output_hidden_states_list[0] is not None else None,\n            attentions=output_attentions_list if output_attentions_list[0] is not None else None,\n            softprompt=softprompt,\n        )\n\n        if return_dict:\n            return output\n        else:\n            return tuple(output.values())\n\n    def prepare_inputs_for_generation(\n        self, input_ids, past_key_values=None, attention_mask=None, inputs_embeds=None, **kwargs\n    ):\n        model_inputs = super().prepare_inputs_for_generation(input_ids, past_key_values, attention_mask, inputs_embeds, **kwargs)\n        model_inputs[\"softprompt\"] = kwargs.get(\"softprompt\", None)\n        model_inputs[\"segment_lengths\"] = kwargs.get(\"segment_lengths\", None)\n        return model_inputs\n\n\nclass OPTLearnedPositionalEmbeddingWithPadding(nn.Embedding):\n    \"\"\"Overwrite the default OPTLearnedPositionalEmbedding to disable position on summary tokens\"\"\"\n\n    def __init__(self, num_embeddings: int, embedding_dim: int, summary_config: Optional[SummaryConfig] = None):\n        # OPT is set up so that if padding_idx is specified then offset the embedding ids by 2\n        # and adjust num_embeddings appropriately. Other models don't have this hack\n        super().__init__(num_embeddings + 2, embedding_dim, padding_idx=1)\n\n        self.summary_config = summary_config if summary_config is not None else SummaryConfig()\n\n    def forward(self, attention_mask: torch.LongTensor, past_key_values_length: int = 0):\n        attention_mask = attention_mask.long()\n        bsz = attention_mask.size(0)\n\n        left_placeholder = torch.ones(bsz, self.summary_config.softprompt_length, dtype=torch.long, device=attention_mask.device) # <pad> -> zero vector\n        right_placeholder = torch.ones(bsz, self.summary_config.summary_length, dtype=torch.long, device=attention_mask.device) # <pad> -> zero vector\n\n        total_softprompt_length = self.summary_config.softprompt_length + self.summary_config.past_key_values_softprompt_length\n        attention_mask = attention_mask[:, total_softprompt_length : attention_mask.size(1)-self.summary_config.summary_length]\n\n        positions = attention_mask.cumsum(dim=1) * attention_mask + 1\n\n        # cut positions if `past_key_values_length` is > 0\n        positions = positions[:, past_key_values_length - self.summary_config.past_key_values_softprompt_length :]\n        positions = torch.cat([left_placeholder, positions, right_placeholder], dim=1)\n\n        return super().forward(positions)\n\n\nclass OPTAutoCompressorModel(AutoCompressorMixin, OPTForCausalLM):\n    def __init__(self, config):\n        super().__init__(config)\n\n        self.setup_autocompressor(config)\n\n        # Custom positional embeddings\n        self.model.decoder.embed_positions = OPTLearnedPositionalEmbeddingWithPadding(\n            config.max_position_embeddings, config.hidden_size, summary_config=self.summary_config\n        )\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n\n# For backwards compatibility\nAutoCompressorModel = OPTAutoCompressorModel\n\n\nclass LlamaAutoCompressorModel(AutoCompressorMixin, LlamaForCausalLM):\n    def __init__(self, config):\n        super().__init__(config)\n\n        self.setup_autocompressor(config)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_past_key_values_len(self, past_key_values):\n        # modeling_flash_llama has slightly different layout of past key vlaues\n        return 0 if past_key_values is None else past_key_values[0][1]",
    "description": null,
    "url": null
}