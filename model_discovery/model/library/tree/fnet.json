{
    "acronym": "fnet",
    "title": "Fnet: Mixing tokens with fourier transforms",
    "seed_ids": [
        "longt5",
        "rfa",
        "bigbird",
        "lineartransformer",
        "linformer",
        "synthesizer",
        "etc",
        "longformer",
        "sinkhorn",
        "transformer",
        "bert"
    ],
    "s2id": "1f133158a8973fb33fea188f20517cd7e69bfe7f",
    "abstract": "We show that Transformer encoder architectures can be sped up, with limited accuracy costs, by replacing the self-attention sublayers with simple linear transformations that \u201cmix\u201d input tokens. Most surprisingly, we find that replacing the self-attention sublayer in a Transformer encoder with a standard, unparameterized Fourier Transform achieves 92-97% of the accuracy of BERT counterparts on the GLUE benchmark, but trains 80% faster on GPUs and 70% faster on TPUs at standard 512 input lengths. At longer input lengths, our FNet model is significantly faster: when compared to the \u201cefficient Transformers\u201d on the Long Range Arena benchmark, FNet matches the accuracy of the most accurate models, while outpacing the fastest models across all sequence lengths on GPUs (and across relatively shorter lengths on TPUs). Finally, FNet has a light memory footprint and is particularly efficient at smaller model sizes; for a fixed speed and accuracy budget, small FNet models outperform Transformer counterparts.",
    "authors": [
        "J. Lee-Thorp",
        "J. Ainslie",
        "Ilya Eckstein",
        "Santiago Onta\u00f1\u00f3n"
    ],
    "venue": "North American Chapter of the Association for Computational Linguistics",
    "year": 2021,
    "tldr": "The FNet model is significantly faster: when compared to the \u201cefficient Transformers\u201d on the Long Range Arena benchmark, FNet matches the accuracy of the most accurate models, while outpacing the fastest models across all sequence lengths on GPUs (and across relatively shorter lengths on TPUs).",
    "citationCount": 400,
    "influentialCitationCount": 56,
    "code": "import re\nimport torch\nimport torch.utils.checkpoint\nfrom scipy import linalg\nfrom torch import nn\n\n\nclass FNetEmbeddings(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n        self.word_embeddings = nn.Embedding(config['vocab_size'], config['embedding_size'],\n                                            padding_idx=config['pad_token_id'])\n        self.position_embeddings = nn.Embedding(config['max_position_embeddings'], config['embedding_size'])\n        self.token_type_embeddings = nn.Embedding(config['type_vocab_size'], config['embedding_size'])\n\n        self.layer_norm = nn.LayerNorm(config['embedding_size'], eps=config['layer_norm_eps'])\n        self.hidden_mapping = nn.Linear(config['embedding_size'], config['hidden_size'])\n        self.dropout = nn.Dropout(config['dropout_rate'])\n\n        self.register_buffer(\n            'position_ids',\n            torch.arange(config['max_position_embeddings']).expand((1, -1)),\n            persistent=False\n        )\n\n    def forward(self, input_ids, type_ids):\n        input_shape = input_ids.size()\n        seq_length = input_shape[1]\n\n        position_ids = self.position_ids[:, :seq_length]\n\n        word_embeddings = self.word_embeddings(input_ids)\n        token_type_embeddings = self.token_type_embeddings(type_ids)\n        position_embeddings = self.position_embeddings(position_ids)\n\n        embeddings = word_embeddings + position_embeddings + token_type_embeddings\n\n        embeddings = self.layer_norm(embeddings)\n        embeddings = self.hidden_mapping(embeddings)\n        embeddings = self.dropout(embeddings)\n\n        return embeddings\n\n\nclass FourierMMLayer(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n\n        self.dft_mat_seq = torch.tensor(linalg.dft(config['max_position_embeddings']))\n        self.dft_mat_hidden = torch.tensor(linalg.dft(config['hidden_size']))\n\n    def forward(self, hidden_states):\n        hidden_states_complex = hidden_states.type(torch.complex128)\n        return torch.einsum(\n            \"...ij,...jk,...ni->...nk\",\n            hidden_states_complex,\n            self.dft_mat_hidden,\n            self.dft_mat_seq\n        ).real.type(torch.float32)\n\n\nclass FourierFFTLayer(nn.Module):\n    def __init__(self):\n        super().__init__()\n\n    @torch.cuda.amp.autocast(enabled=False)\n    def forward(self, hidden_states):\n        return torch.fft.fft(torch.fft.fft(hidden_states.float(), dim=-1), dim=-2).real\n\n\nclass FNetLayer(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n        self.fft = FourierMMLayer(config) if config['fourier'] == 'matmul' else FourierFFTLayer()\n        self.mixing_layer_norm = nn.LayerNorm(config['hidden_size'], eps=config['layer_norm_eps'])\n        self.feed_forward = nn.Linear(config['hidden_size'], config['intermediate_size'])\n        self.output_dense = nn.Linear(config['intermediate_size'], config['hidden_size'])\n        self.output_layer_norm = nn.LayerNorm(config['hidden_size'], eps=config['layer_norm_eps'])\n        self.dropout = nn.Dropout(config['dropout_rate'])\n        self.activation = nn.GELU()\n\n    def forward(self, hidden_states):\n        fft_output = self.fft(hidden_states)\n        fft_output = self.mixing_layer_norm(fft_output + hidden_states)\n        intermediate_output = self.feed_forward(fft_output)\n        intermediate_output = self.activation(intermediate_output)\n        output = self.output_dense(intermediate_output)\n        output = self.dropout(output)\n        output = self.output_layer_norm(output + fft_output)\n        return output\n\n\nclass FNetEncoder(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n        self.config = config\n        self.layer = nn.ModuleList([FNetLayer(config) for _ in range(config['num_hidden_layers'])])\n\n    def forward(self, hidden_states):\n        for i, layer_module in enumerate(self.layer):\n            hidden_states = layer_module(hidden_states)\n\n        return hidden_states\n\n\nclass FNetPooler(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n        self.dense = nn.Linear(config['hidden_size'], config['hidden_size'])\n        self.activation = nn.Tanh()\n\n    def forward(self, hidden_states):\n        # We \"pool\" the model by simply taking the hidden state corresponding\n        # to the first token.\n        first_token_tensor = hidden_states[:, 0]\n        pooled_output = self.dense(first_token_tensor)\n        pooled_output = self.activation(pooled_output)\n        return pooled_output\n\n\nclass FNet(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n        self.config = config\n\n        self.embeddings = FNetEmbeddings(config)\n        self.encoder = FNetEncoder(config)\n        self.pooler = FNetPooler(config)\n\n    def forward(self, input_ids, type_ids):\n        embedding_output = self.embeddings(input_ids, type_ids)\n        sequence_output = self.encoder(embedding_output)\n        pooled_output = self.pooler(sequence_output)\n\n        return sequence_output, pooled_output\n\n\nclass FNetForPreTraining(nn.Module):\n    def __init__(self, config):\n        super(FNetForPreTraining, self).__init__()\n        self.encoder = FNet(config)\n\n        self.embedding_size = config['embedding_size']\n        self.vocab_size = config['vocab_size']\n        self.hidden_size = config['hidden_size']\n        self.num_layers = config['num_hidden_layers']\n\n        self.mlm_intermediate = nn.Linear(self.hidden_size, self.embedding_size)\n        self.activation = nn.GELU()\n        self.mlm_layer_norm = nn.LayerNorm(self.embedding_size)\n        self.mlm_output = nn.Linear(self.embedding_size, self.vocab_size)\n\n        self.nsp_output = nn.Linear(self.hidden_size, 2)\n\n    def _mlm(self, x):\n        x = self.mlm_intermediate(x)\n        x = self.activation(x)\n        x = self.mlm_layer_norm(x)\n        x = self.mlm_output(x)\n        return x\n\n    def forward(self, input_ids, type_ids, mlm_positions=None):\n        sequence_output, pooled_output = self.encoder(input_ids, type_ids)\n\n        if mlm_positions is not None:\n            mlm_input = sequence_output.take_along_dim(mlm_positions.unsqueeze(-1), dim=1)\n        else:\n            mlm_input = sequence_output\n\n        mlm_logits = self._mlm(mlm_input)\n        nsp_logits = self.nsp_output(pooled_output)\n        return {\"mlm_logits\": mlm_logits, \"nsp_logits\": nsp_logits}\n\n\ndef get_config_from_statedict(state_dict,\n                              fourier_type=\"fft\",\n                              pad_token_id=0,\n                              layer_norm_eps=1e-12,\n                              dropout_rate=0.1):\n    is_pretraining_checkpoint = 'mlm_output.weight' in state_dict.keys()\n    \n    def prepare(key):\n        if is_pretraining_checkpoint: \n            return f\"encoder.{key}\"\n        return key\n\n    regex = re.compile(prepare(r'encoder.layer.\\d+.feed_forward.weight'))\n    num_layers = len([key for key in state_dict.keys() if regex.search(key)])\n\n    return {\n        \"num_hidden_layers\": num_layers,\n        \"vocab_size\": state_dict[prepare('embeddings.word_embeddings.weight')].shape[0],\n        \"embedding_size\": state_dict[prepare('embeddings.word_embeddings.weight')].shape[1],\n        \"hidden_size\": state_dict[prepare('encoder.layer.0.output_dense.weight')].shape[0],\n        \"intermediate_size\": state_dict[prepare('encoder.layer.0.feed_forward.weight')].shape[0],\n        \"max_position_embeddings\": state_dict[prepare('embeddings.position_embeddings.weight')].shape[0],\n        \"type_vocab_size\": state_dict[prepare('embeddings.token_type_embeddings.weight')].shape[0],\n        # the following parameters can not be inferred from the state dict and must be given manually\n        \"fourier\": fourier_type,\n        \"pad_token_id\": pad_token_id,\n        \"layer_norm_eps\": layer_norm_eps,\n        \"dropout_rate\": dropout_rate,\n    }",
    "description": null,
    "url": null
}