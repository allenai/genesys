{
    "acronym": "lasp",
    "title": "Linear Attention Sequence Parallelism",
    "seed_ids": [
        "gla",
        "hgrn",
        "rfa",
        "performer"
    ],
    "s2id": "660d80773f55c5dc889de3ce93b71672133a91bc",
    "abstract": "Sequence Parallel (SP) serves as a prevalent strategy to handle long sequences that exceed the memory limit of a single GPU. However, existing SP methods do not take advantage of linear attention features, resulting in sub-optimal parallelism efficiency and usability for linear attention-based language models. In this paper, we introduce Linear Attention Sequence Parallel (LASP), an efficient SP method tailored to linear attention-based language models. Specifically, we design an efficient point-to-point communication mechanism to leverage the right-product kernel trick of linear attention, which sharply decreases the communication overhead of SP. We also enhance the practical efficiency of LASP by performing kernel fusion and intermediate state caching, making the implementation of LASP hardware-friendly on GPU clusters. Furthermore, we meticulously ensure the compatibility of sequence-level LASP with all types of batch-level data parallel methods, which is vital for distributed training on large clusters with long sequences and large batches. We conduct extensive experiments on two linear attention-based models with varying sequence lengths and GPU cluster sizes. LASP scales sequence length up to 4096K using 128 A100 80G GPUs on 1B models, which is 8 times longer than existing SP methods while being significantly faster. The code is available at https://github.com/OpenNLPLab/LASP.",
    "authors": [
        "Weigao Sun",
        "Zhen Qin",
        "Dong Li",
        "Xuyang Shen",
        "Yu Qiao",
        "Yiran Zhong"
    ],
    "venue": "arXiv.org",
    "year": 2024,
    "tldr": "This paper designs an efficient point-to-point communication mechanism to leverage the right-product kernel trick of linear attention, which sharply decreases the communication overhead of SP and enhances the practical efficiency of LASP by performing kernel fusion and intermediate state caching.",
    "citationCount": 0,
    "influentialCitationCount": 0,
    "code": "import torch\nimport torch.distributed as dist\nimport triton\nimport triton.language as tl\n\nfrom .utils import (\n    get_seq_parallel_receive_rank,\n    get_seq_parallel_send_rank,\n    get_sequence_parallel_group,\n    get_sequence_parallel_rank,\n    get_sequence_parallel_world_size,\n)\n\n\n@triton.jit\ndef _fwd_kernel(\n    Q,\n    K,\n    V,\n    Out,\n    S,\n    KV,\n    b: tl.constexpr,\n    h: tl.constexpr,\n    n: tl.constexpr,\n    d: tl.constexpr,\n    e: tl.constexpr,\n    BLOCK: tl.constexpr,\n    NUM_BLOCK: tl.constexpr,\n    BLOCK_MODEL: tl.constexpr,\n):\n    off_bh = tl.program_id(0)\n    off_h = off_bh % h\n    off_e = tl.program_id(1)\n    # get the (b, h) location\n    qk_offset = off_bh * n * d\n    v_offset = off_bh * n * e\n    o_offset = off_bh * n * e\n    kv_offset = off_bh * d * e\n\n    e_offset = off_e * BLOCK_MODEL\n\n    # tl.device_print(\"aaa\", BLOCK_MODEL)\n\n    Q_block_ptr = (\n        Q + qk_offset + tl.arange(0, BLOCK)[:, None] * d + tl.arange(0, d)[None, :]\n    )\n    K_trans_block_ptr = (\n        K + qk_offset + tl.arange(0, BLOCK)[None, :] * d + tl.arange(0, d)[:, None]\n    )\n    V_block_ptr = (\n        V\n        + v_offset\n        + e_offset\n        + tl.arange(0, BLOCK)[:, None] * e\n        + tl.arange(0, BLOCK_MODEL)[None, :]\n    )\n    O_block_ptr = (\n        Out\n        + o_offset\n        + e_offset\n        + tl.arange(0, BLOCK)[:, None] * e\n        + tl.arange(0, BLOCK_MODEL)[None, :]\n    )\n    KV_block_ptr = (\n        KV\n        + kv_offset\n        + e_offset\n        + tl.arange(0, d)[:, None] * e\n        + tl.arange(0, BLOCK_MODEL)[None, :]\n    )\n\n    S_block_ptr = S + off_h\n    s = tl.load(S_block_ptr)\n\n    array = tl.arange(0, BLOCK).to(tl.float32)\n    q_decay = tl.exp(-s.to(tl.float32) * array[:, None])\n    k_trans_decay = tl.exp(-s.to(tl.float32) * (BLOCK - array[None, :]))\n    block_decay = tl.exp(-s.to(tl.float32) * BLOCK)\n\n    index = array[:, None] - array[None, :]\n    s_index = s * index\n    s_index = tl.where(index >= 0, -s_index, float(\"-inf\"))\n    diag_decay = tl.exp(s_index)\n\n    kv = tl.zeros([d, BLOCK_MODEL], dtype=tl.float32)\n    for i in range(NUM_BLOCK):\n        q = tl.load(Q_block_ptr).to(tl.float32)\n        k_trans = tl.load(K_trans_block_ptr).to(tl.float32)\n        v = tl.load(V_block_ptr).to(tl.float32)\n\n        qkv_none_diag = tl.dot(q, kv) * q_decay\n        qk = tl.dot(q, k_trans) * diag_decay\n        qkv_diag = tl.dot(qk, v)\n\n        qkv = qkv_none_diag + qkv_diag\n\n        tl.store(O_block_ptr, qkv.to(O_block_ptr.dtype.element_ty))\n        kv = block_decay * kv + tl.dot(k_trans * k_trans_decay, v)\n\n        Q_block_ptr += BLOCK * d\n        K_trans_block_ptr += BLOCK * d\n        V_block_ptr += BLOCK * e\n        O_block_ptr += BLOCK * e\n\n    tl.store(KV_block_ptr, kv.to(KV_block_ptr.dtype.element_ty))\n\n\n@triton.jit\ndef _bwd_diag_kernel(\n    Q,\n    K,\n    V,\n    S,\n    DO,\n    DQ,\n    DK,\n    DV,\n    b: tl.constexpr,\n    h: tl.constexpr,\n    n: tl.constexpr,\n    d: tl.constexpr,\n    e: tl.constexpr,\n    BLOCK: tl.constexpr,\n    NUM_BLOCK: tl.constexpr,\n    CBLOCK: tl.constexpr,\n    NUM_CBLOCK: tl.constexpr,\n):\n    off_bh = tl.program_id(0)\n    off_block = tl.program_id(1)\n    off_h = off_bh % h\n\n    #####\n    qk_offset = off_bh * n * d\n    v_offset = off_bh * n * e\n    o_offset = off_bh * n * e\n\n    block_offset = off_block * BLOCK\n    qk_block_offset = block_offset * d\n    v_block_offset = block_offset * e\n    o_block_offset = block_offset * e\n\n    Q_trans_block_ptr = (\n        Q\n        + qk_offset\n        + qk_block_offset\n        + tl.arange(0, BLOCK)[None, :] * d\n        + tl.arange(0, d)[:, None]\n    )\n    K_block_ptr = (\n        K\n        + qk_offset\n        + qk_block_offset\n        + tl.arange(0, BLOCK)[:, None] * d\n        + tl.arange(0, d)[None, :]\n    )\n    V_trans_block_ptr = (\n        V\n        + v_offset\n        + v_block_offset\n        + tl.arange(0, BLOCK)[None, :] * e\n        + tl.arange(0, e)[:, None]\n    )\n\n    DQ_block_ptr = (\n        DQ\n        + qk_offset\n        + qk_block_offset\n        + tl.arange(0, BLOCK)[:, None] * d\n        + tl.arange(0, d)[None, :]\n    )\n    DK_trans_block_ptr = (\n        DK\n        + qk_offset\n        + qk_block_offset\n        + tl.arange(0, BLOCK)[None, :] * d\n        + tl.arange(0, d)[:, None]\n    )\n    DV_block_ptr = (\n        DV\n        + v_offset\n        + v_block_offset\n        + tl.arange(0, BLOCK)[:, None] * e\n        + tl.arange(0, e)[None, :]\n    )\n    DO_block_ptr = (\n        DO\n        + o_offset\n        + o_block_offset\n        + tl.arange(0, BLOCK)[:, None] * e\n        + tl.arange(0, e)[None, :]\n    )\n\n    S_block_ptr = S + off_h\n    s = tl.load(S_block_ptr)\n    array = tl.arange(0, BLOCK).to(tl.float32)\n    # diag\n    index = array[:, None] - array[None, :]\n    s_index = s * index\n    s_index = tl.where(index >= 0, -s_index, float(\"-inf\"))\n    diag_decay = tl.exp(s_index)\n    diag_decay_trans = tl.trans(diag_decay)\n\n    k = tl.load(K_block_ptr).to(tl.float32)\n    v_trans = tl.load(V_trans_block_ptr).to(tl.float32)\n    do = tl.load(DO_block_ptr).to(tl.float32)\n    q_trans = tl.load(Q_trans_block_ptr).to(tl.float32)\n    # diag\n    dqk = tl.dot(do, v_trans) * diag_decay\n    dq_diag = tl.dot(dqk, k)\n\n    dq = dq_diag\n\n    dk_diag_trans = tl.dot(q_trans, dqk)\n\n    qk_trans = tl.dot(k, q_trans) * diag_decay_trans\n    dv_diag = tl.dot(qk_trans, do)\n\n    dk_trans = dk_diag_trans\n    dv = dv_diag\n\n    tl.store(DQ_block_ptr, dq.to(DQ_block_ptr.dtype.element_ty))\n    tl.store(DK_trans_block_ptr, dk_trans.to(DK_trans_block_ptr.dtype.element_ty))\n    tl.store(DV_block_ptr, dv.to(DV_block_ptr.dtype.element_ty))\n\n\n##### all split\n@triton.jit\ndef _bwd_none_diag_kernel(\n    Q,\n    K,\n    V,\n    S,\n    DO,\n    DQ,\n    DK,\n    DV,\n    DKV,\n    b: tl.constexpr,\n    h: tl.constexpr,\n    n: tl.constexpr,\n    d: tl.constexpr,\n    e: tl.constexpr,\n    BLOCK: tl.constexpr,\n    NUM_BLOCK: tl.constexpr,\n    CBLOCK: tl.constexpr,\n    NUM_CBLOCK: tl.constexpr,\n):\n    off_bh = tl.program_id(0)\n    off_block = tl.program_id(1)\n    off_h = off_bh % h\n\n    qk_offset = off_bh * n * d\n    v_offset = off_bh * n * e\n    o_offset = off_bh * n * e\n    kv_offset = off_bh * d * e\n\n    block_offset = off_block * BLOCK\n    qk_block_offset = block_offset * d\n    v_block_offset = block_offset * e\n    o_block_offset = block_offset * e\n\n    qk_offset = off_bh * n * d\n    v_offset = off_bh * n * e\n    o_offset = off_bh * n * e\n\n    block_offset = off_block * BLOCK\n    qk_block_offset = block_offset * d\n    v_block_offset = block_offset * e\n    o_block_offset = block_offset * e\n\n    S_block_ptr = S + off_h\n    s = tl.load(S_block_ptr)\n    block_decay = tl.exp(-s.to(tl.float32) * BLOCK)\n\n    DQ_block_ptr = (\n        DQ\n        + qk_offset\n        + qk_block_offset\n        + tl.arange(0, CBLOCK)[:, None] * d\n        + tl.arange(0, d)[None, :]\n    )\n    K_block_ptr = (\n        K\n        + qk_offset\n        + qk_block_offset\n        + tl.arange(0, CBLOCK)[:, None] * d\n        + tl.arange(0, d)[None, :]\n    )\n    V_trans_block_ptr = (\n        V\n        + v_offset\n        + v_block_offset\n        + tl.arange(0, CBLOCK)[None, :] * e\n        + tl.arange(0, e)[:, None]\n    )\n    DO_block_ptr = (\n        DO\n        + o_offset\n        + o_block_offset\n        + tl.arange(0, CBLOCK)[:, None] * e\n        + tl.arange(0, e)[None, :]\n    )\n\n    DKV_block_ptr = (\n        DKV + kv_offset + tl.arange(0, d)[:, None] * e + tl.arange(0, e)[None, :]\n    )\n\n    # compute block array\n    c_array = tl.arange(0, CBLOCK)\n\n    kv_trans = tl.zeros([e, d], dtype=tl.float32)\n    for i in range(NUM_BLOCK):\n        for j in range(NUM_CBLOCK):\n            q_decay = tl.exp(-s.to(tl.float32) * (j * CBLOCK + c_array[:, None]))\n            do = tl.load(DO_block_ptr).to(tl.float32)\n            dq_none_diag = tl.dot(do, kv_trans) * q_decay\n            dq = dq_none_diag + tl.load(DQ_block_ptr)\n            tl.store(DQ_block_ptr, dq.to(DQ_block_ptr.dtype.element_ty))\n\n            DQ_block_ptr += CBLOCK * d\n            DO_block_ptr += CBLOCK * e\n\n        kv_trans_current = tl.zeros([e, d], dtype=tl.float32)\n        for j in range(NUM_CBLOCK):\n            v_trans = tl.load(V_trans_block_ptr).to(tl.float32)\n            k = tl.load(K_block_ptr).to(tl.float32)\n            k_decay = tl.exp(\n                -s.to(tl.float32) * (BLOCK - (j * CBLOCK + c_array[:, None]))\n            )\n            kv_trans_current += tl.dot(v_trans, k * k_decay)\n\n            K_block_ptr += CBLOCK * d\n            V_trans_block_ptr += CBLOCK * e\n\n        kv_trans = block_decay * kv_trans + kv_trans_current\n\n    Q_trans_block_ptr = (\n        Q\n        + qk_offset\n        + qk_block_offset\n        + n * d\n        + tl.arange(0, CBLOCK)[None, :] * d\n        + tl.arange(0, d)[:, None]\n    )\n    K_block_ptr = (\n        K\n        + qk_offset\n        + qk_block_offset\n        + n * d\n        + tl.arange(0, CBLOCK)[:, None] * d\n        + tl.arange(0, d)[None, :]\n    )\n    V_trans_block_ptr = (\n        V\n        + v_offset\n        + v_block_offset\n        + n * e\n        + tl.arange(0, CBLOCK)[None, :] * e\n        + tl.arange(0, e)[:, None]\n    )\n\n    DK_trans_block_ptr = (\n        DK\n        + qk_offset\n        + qk_block_offset\n        + n * d\n        + tl.arange(0, CBLOCK)[None, :] * d\n        + tl.arange(0, d)[:, None]\n    )\n    DV_block_ptr = (\n        DV\n        + v_offset\n        + v_block_offset\n        + n * e\n        + tl.arange(0, CBLOCK)[:, None] * e\n        + tl.arange(0, e)[None, :]\n    )\n    DO_block_ptr = (\n        DO\n        + o_offset\n        + o_block_offset\n        + n * e\n        + tl.arange(0, CBLOCK)[:, None] * e\n        + tl.arange(0, e)[None, :]\n    )\n\n    dkv = tl.zeros([d, e], dtype=tl.float32)\n    for i in range(NUM_BLOCK - 1, -1, -1):\n        for j in range(NUM_CBLOCK - 1, -1, -1):\n            K_block_ptr -= CBLOCK * d\n            V_trans_block_ptr -= CBLOCK * e\n            DK_trans_block_ptr -= CBLOCK * d\n            DV_block_ptr -= CBLOCK * e\n\n            k = tl.load(K_block_ptr).to(tl.float32)\n            v_trans = tl.load(V_trans_block_ptr).to(tl.float32)\n\n            k_decay_trans = tl.exp(\n                -s.to(tl.float32) * (BLOCK - (j * CBLOCK + c_array[None, :]))\n            )\n            k_decay = tl.exp(\n                -s.to(tl.float32) * (BLOCK - (j * CBLOCK + c_array[:, None]))\n            )\n            dk_none_diag_trans = tl.dot(dkv, v_trans) * k_decay_trans\n            dv_none_diag = tl.dot(k, dkv) * k_decay\n\n            dk_trans = dk_none_diag_trans + tl.load(DK_trans_block_ptr)\n            dv = dv_none_diag + tl.load(DV_block_ptr)\n\n            tl.store(\n                DK_trans_block_ptr, dk_trans.to(DK_trans_block_ptr.dtype.element_ty)\n            )\n            tl.store(DV_block_ptr, dv.to(DV_block_ptr.dtype.element_ty))\n\n        dkv_current = tl.zeros([d, e], dtype=tl.float32)\n        for j in range(NUM_CBLOCK - 1, -1, -1):\n            DO_block_ptr -= CBLOCK * e\n            Q_trans_block_ptr -= CBLOCK * d\n            do = tl.load(DO_block_ptr).to(tl.float32)\n            q_trans = tl.load(Q_trans_block_ptr).to(tl.float32)\n            q_decay_trans = tl.exp(-s.to(tl.float32) * (j * CBLOCK + c_array[None, :]))\n            dkv_current += tl.dot(q_trans * q_decay_trans, do)\n\n        dkv = block_decay * dkv + dkv_current\n    tl.store(DKV_block_ptr, dkv.to(DKV_block_ptr.dtype.element_ty))\n\n\ndef lasp_forward(q, k, v, s, kv):\n    q = q.contiguous()\n    k = k.contiguous()\n    v = v.contiguous()\n    s = s.contiguous()\n    kv = kv.contiguous()\n\n    # shape constraints\n    b, h, n, d = q.shape\n    e = v.shape[-1]\n    # right\n    o = torch.empty((b, h, n, e), dtype=q.dtype, device=q.device)\n\n    BLOCK = 64\n    NUM_BLOCK = q.shape[2] // BLOCK\n\n    BLOCK_MODEL = 32\n\n    grid = (b * h, e // BLOCK_MODEL)\n\n    with torch.cuda.device(q.device.index):\n        _fwd_kernel[grid](\n            q,\n            k,\n            v,\n            o,\n            s,\n            kv,\n            b,\n            h,\n            n,\n            d,\n            e,\n            BLOCK=BLOCK,\n            NUM_BLOCK=NUM_BLOCK,\n            BLOCK_MODEL=BLOCK_MODEL,\n        )\n\n    return o\n\n\ndef lasp_backward(q, k, v, s, do):\n    q = q.contiguous()\n    k = k.contiguous()\n    v = v.contiguous()\n    s = s.contiguous()\n\n    do = do.contiguous()\n    dq = torch.empty_like(q)\n    dk = torch.empty_like(k)\n    dv = torch.empty_like(v)\n\n    b, h, n, d = q.shape\n    e = v.shape[-1]\n    BLOCK = 32\n    NUM_BLOCK = triton.cdiv(n, BLOCK)\n\n    CBLOCK = 16\n\n    assert BLOCK % CBLOCK == 0\n    NUM_CBLOCK = BLOCK // CBLOCK\n\n    dkv = torch.empty((b, h, d, e), dtype=q.dtype, device=q.device)\n\n    with torch.cuda.device(q.device.index):\n        grid = (b * h, NUM_BLOCK)\n        _bwd_diag_kernel[grid](\n            q,\n            k,\n            v,\n            s,\n            do,\n            dq,\n            dk,\n            dv,\n            b,\n            h,\n            n,\n            d,\n            e,\n            BLOCK=BLOCK,\n            NUM_BLOCK=NUM_BLOCK,\n            CBLOCK=CBLOCK,\n            NUM_CBLOCK=NUM_CBLOCK,\n        )\n\n        grid = (b * h,)\n\n        _bwd_none_diag_kernel[grid](\n            q,\n            k,\n            v,\n            s,\n            do,\n            dq,\n            dk,\n            dv,\n            dkv,\n            b,\n            h,\n            n,\n            d,\n            e,\n            BLOCK=BLOCK,\n            NUM_BLOCK=NUM_BLOCK,\n            CBLOCK=CBLOCK,\n            NUM_CBLOCK=NUM_CBLOCK,\n        )\n\n    return dq, dk, dv, None, dkv\n\n\nclass LaspNaive(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx, q, k, v, s):\n        b, h, n, d = q.shape\n        e = v.shape[-1]\n        array = torch.arange(n).to(q)\n        q_decay = torch.exp(-s[None, :].to(torch.float32) * array.reshape(1, 1, -1, 1))\n        block_decay = torch.exp(-s[None, :].to(torch.float32) * n)\n\n        KV = torch.zeros(b, h, d, e).to(torch.float32).to(q.device)\n        group = get_sequence_parallel_group()\n        current_idx = get_sequence_parallel_rank()\n        send_idx = get_seq_parallel_send_rank()\n        recv_idx = get_seq_parallel_receive_rank()\n\n        if current_idx > 0:\n            dist.recv(KV, src=send_idx, group=group)\n\n        kv = torch.empty(b, h, d, e).to(q)\n        o = lasp_forward(q, k, v, s, kv).to(torch.float32) + torch.matmul(\n            q * q_decay, KV\n        )\n\n        ctx.save_for_backward(q, k, v, s, KV)\n        KV = block_decay * KV + kv\n\n        if current_idx < get_sequence_parallel_world_size() - 1:\n            dist.send(KV, dst=recv_idx, group=group)\n\n        ctx.group = group\n        ctx.current_idx = current_idx\n        ctx.send_idx = send_idx\n        ctx.recv_idx = recv_idx\n\n        o = o.to(q.dtype)\n\n        return o\n\n    @staticmethod\n    def backward(ctx, do):\n        q, k, v, s, KV = ctx.saved_tensors\n        group = ctx.group\n\n        current_idx = ctx.current_idx\n        send_idx = ctx.recv_idx\n        recv_idx = ctx.send_idx\n\n        b, h, n, d = q.shape\n        e = v.shape[-1]\n\n        array = torch.arange(n).to(do)\n\n        q_decay = torch.exp(-s[None, :].to(torch.float32) * array.reshape(-1, 1))\n        k_decay = torch.exp(-s[None, :].to(torch.float32) * (n - array.reshape(-1, 1)))\n        block_decay = torch.exp(-s[None, :].to(torch.float32) * n)\n\n        DKV = torch.zeros(b, h, d, e).to(torch.float32).to(do.device)\n\n        if current_idx < get_sequence_parallel_world_size() - 1:\n            dist.recv(DKV, src=send_idx, group=group)\n\n        dq, dk, dv, _, dkv = lasp_backward(q, k, v, s, do)\n\n        dq = (\n            dq.to(torch.float32)\n            + torch.matmul(do.to(KV.dtype), KV.transpose(-1, -2)) * q_decay\n        )\n        dk = (\n            dk.to(torch.float32)\n            + torch.matmul(v.to(DKV.dtype), DKV.transpose(-1, -2)) * k_decay\n        )\n        dv = dv.to(torch.float32) + torch.matmul((k * k_decay).to(DKV.dtype), DKV)\n\n        DKV = block_decay * DKV + dkv.to(DKV.dtype)\n        if current_idx > 0:\n            dist.send(DKV, dst=recv_idx, group=group)\n\n        dq = dq.to(q.dtype)\n        dk = dk.to(q.dtype)\n        dv = dv.to(q.dtype)\n\n        return dq, dk, dv, None\n\n\nlasp_naive_ = LaspNaive.apply\n\n\ndef lasp_naive(q, k, v, ed):\n    d = q.shape[-1]\n    e = v.shape[-1]\n    if d >= 128:\n        m = 128\n    else:\n        m = 64\n    arr = [m * i for i in range(d // m + 1)]\n    if arr[-1] != d:\n        arr.append(d)\n    n = len(arr)\n    output = 0\n    for i in range(n - 1):\n        s = arr[i]\n        e = arr[i + 1]\n        q1 = q[..., s:e]\n        k1 = k[..., s:e]\n        o = lasp_naive_(q1, k1, v, ed)\n        output = output + o\n\n    return output",
    "description": null,
    "url": null
}