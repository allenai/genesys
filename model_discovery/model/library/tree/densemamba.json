{
    "acronym": "densemamba",
    "title": "DenseMamba: State Space Models with Dense Hidden Connection for Efficient Large Language Models",
    "seed_ids": [
        "gla",
        "mamba",
        "retnet",
        "longnet",
        "gssm",
        "s4",
        "hippo",
        "gpt3",
        "transformer"
    ],
    "s2id": "7351898febca53d01453283c9b1a541b662e1ed3",
    "abstract": "Large language models (LLMs) face a daunting challenge due to the excessive computational and memory requirements of the commonly used Transformer architecture. While state space model (SSM) is a new type of foundational network architecture offering lower computational complexity, their performance has yet to fully rival that of Transformers. This paper introduces DenseSSM, a novel approach to enhance the flow of hidden information between layers in SSMs. By selectively integrating shallowlayer hidden states into deeper layers, DenseSSM retains fine-grained information crucial for the final output. Dense connections enhanced DenseSSM still maintains the training parallelizability and inference efficiency. The proposed method can be widely applicable to various SSM types like RetNet and Mamba. With similar model size, DenseSSM achieves significant improvements, exemplified by DenseRetNet outperforming the original RetNet with up to 5% accuracy improvement on public benchmarks. code is avalaible at https://github.com/WailordHe/DenseSSM",
    "authors": [
        "Wei He",
        "Kai Han",
        "Yehui Tang",
        "Chengcheng Wang",
        "Yujie Yang",
        "Tianyu Guo",
        "Yunhe Wang"
    ],
    "venue": "arXiv.org",
    "year": 2024,
    "tldr": "DenseSSM is introduced, a novel approach to enhance the flow of hidden information between layers in SSMs by selectively integrating shallowlayer hidden states into deeper layers, and retains fine-grained information crucial for the final output.",
    "citationCount": 14,
    "influentialCitationCount": 1,
    "code": "# coding=utf-8\n# Copyright 2022 EleutherAI and the HuggingFace Inc. team. All rights reserved.\n#\n# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n# and OPT implementations in this library. It has been modified from its\n# original forms to accommodate minor architectural differences compared\n# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\" Pytorch DenseGAU RetNet model.\"\"\"\nfrom typing import List, Optional, Tuple, Union\nimport math\nimport torch\nimport torch.utils.checkpoint\nimport torch.nn.functional as F\nfrom torch import nn\nfrom transformers.modeling_outputs import BaseModelOutputWithPast\nfrom transformers.utils import add_start_docstrings, add_start_docstrings_to_model_forward, logging\nfrom transformers.models.llama.configuration_llama import LlamaConfig\n\nfrom llama.utils import _make_causal_mask, LlamaRMSNorm, LLAMA_START_DOCSTRING, LLAMA_INPUTS_DOCSTRING\nfrom modules import LlamaPreTrainedModel, LlamaDecoderLayer\n\nlogger = logging.get_logger(__name__)\n\n_CONFIG_FOR_DOC = \"LlamaConfig\"\n\n\n# Copied from transformers.models.bart.modeling_bart._expand_mask\ndef _expand_mask(mask: torch.Tensor, dtype: torch.dtype, tgt_len: Optional[int] = None):\n    \"\"\"\n    Expands attention_mask from `[bsz, seq_len]` to `[bsz, 1, tgt_seq_len, src_seq_len]`.\n    \"\"\"\n    bsz, src_len = mask.size()\n    tgt_len = tgt_len if tgt_len is not None else src_len\n\n    expanded_mask = mask[:, None, None, :].expand(bsz, 1, tgt_len, src_len).to(dtype)\n\n    inverted_mask = 1.0 - expanded_mask\n\n    return inverted_mask.masked_fill(inverted_mask.to(torch.bool), torch.finfo(dtype).min)\n\n# added for retention\n# Copied from https://github.com/microsoft/torchscale/blob/main/torchscale/component/multiscale_retention.py\ndef rotate_every_two(x):\n    x1 = x[:, :, :, ::2]\n    x2 = x[:, :, :, 1::2]\n    x = torch.stack((-x2, x1), dim=-1)\n    return x.flatten(-2)  # in einsum notation: rearrange(x, '... d j -> ... (d j)')\\\ndef theta_shift(x, sin, cos):\n    return (x * cos) + (rotate_every_two(x) * sin)\n\n\n#Parameter efficient HiddenProjection\nclass HiddenProjection(nn.Module):\n    def __init__(self, input_dim, mid_reduction_ratio=16, final_reduction_ratio=4):\n        super(HiddenProjection, self).__init__()\n        self.fc1 = nn.Linear(input_dim, input_dim // mid_reduction_ratio, bias=False)\n        self.fc2 = nn.Linear(input_dim // mid_reduction_ratio, int(input_dim // final_reduction_ratio), bias=False)\n\n    def forward(self, x):\n        fc1_output = F.silu(self.fc1(x))\n        fc2_output = self.fc2(fc1_output)\n        return fc2_output\n\n# Copied and modified from transformers.models.bart.modeling_bart._expand_mask\n\nclass MultiScaleGauRetention(nn.Module):\n    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n\n    def __init__(self, config: LlamaConfig):\n        super().__init__()\n        self.config = config\n        self.hidden_size = config.hidden_size\n        self.query_key_dim = config.query_key_dim\n        self.num_heads = config.num_attention_heads\n        self.factor = config.v_factor\n        self.head_dim = config.hidden_size * self.factor // self.num_heads\n        self.max_position_embeddings = config.max_position_embeddings\n        self.q_proj = nn.Linear(self.hidden_size, self.query_key_dim, bias=False)\n        self.k_proj = nn.Linear(self.hidden_size, self.query_key_dim, bias=False)\n        self.key_dim = self.query_key_dim // self.num_heads\n        self.scaling = self.key_dim ** -0.5\n        self.expansion_dim = int(config.hidden_size * self.factor)\n        self.group_norm = LlamaRMSNorm(self.expansion_dim // config.num_attention_heads, eps=config.rms_norm_eps)\n        self.to_hidden = nn.Sequential(\n            nn.Linear(config.hidden_size, self.expansion_dim * 2, bias=False),\n            nn.SiLU()\n        )\n        self.to_out = nn.Sequential(\n            nn.Linear(self.expansion_dim, config.hidden_size, bias=False),\n            nn.Dropout(0)\n        )\n        self.config = config\n        self.k_select = HiddenProjection(self.hidden_size, 32, 2)\n        self.v_select = HiddenProjection(self.hidden_size, 32, 0.5)\n        self.k_norm = LlamaRMSNorm(self.query_key_dim, eps=config.rms_norm_eps)\n        self.v_norm = LlamaRMSNorm(self.expansion_dim, eps=config.rms_norm_eps)\n        if config.deepnorm:\n            self.alpha = math.pow(2.0 * config.num_hidden_layers, 0.25)\n        else:\n            self.alpha = 1.0\n        self.dropout_module = torch.nn.Dropout(config.dropout)\n        self.reset_parameters()\n\n    #\n    def reset_parameters(self):\n        nn.init.xavier_uniform_(self.q_proj.weight, gain=2 ** -2.5)\n        nn.init.xavier_uniform_(self.k_proj.weight, gain=2 ** -2.5)\n        nn.init.xavier_uniform_(self.k_select.fc1.weight, gain=2 ** -2.5)\n        nn.init.xavier_uniform_(self.k_select.fc2.weight, gain=2 ** -2.5)\n        nn.init.xavier_uniform_(self.v_select.fc1.weight, gain=2 ** -2.5)\n        nn.init.xavier_uniform_(self.v_select.fc2.weight, gain=2 ** -2.5)\n        for module in self.to_out.modules():\n            if isinstance(module, nn.Linear):\n                nn.init.xavier_uniform_(module.weight, gain=2 ** -1)\n        for module in self.to_hidden.modules():\n            if isinstance(module, nn.Linear):\n                nn.init.xavier_uniform_(module.weight, gain=2 ** -2.5)\n\n    def forward(\n            self,\n            forward_impl: 'parallel',\n            hidden_states: torch.Tensor,\n            rel_pos,\n            attention_mask: Optional[torch.Tensor] = None,\n            position_ids: Optional[torch.LongTensor] = None,\n            past_key_value: Optional[Tuple[torch.Tensor]] = None,\n            output_attentions: bool = False,\n            k_features=None,  # dense\n            v_features=None,  # dense\n            dense=False,\n            dense_layers=0,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        bsz, tgt_len, _ = hidden_states.size()\n        (sin, cos), inner_mask = rel_pos\n        x = hidden_states\n        q = F.silu(self.q_proj(x))\n        k = F.silu(self.k_proj(x))\n        v, gate = self.to_hidden(x).chunk(2, dim=-1)\n\n        k *= self.scaling\n        k_curr = k\n        v_curr = v\n\n        if dense:\n            k_gate = self.k_select(hidden_states.clone())\n            for i, k_past in enumerate(k_features):\n                k = k.clone() + F.silu(k_gate) * k_past\n            k = self.k_norm(k)\n\n            v_gate = self.v_select(hidden_states.clone())\n            for i, v_past in enumerate(v_features):\n                v = v.clone() + F.silu(v_gate) * v_past\n            v = self.v_norm(v)\n\n        q = q.view(bsz, tgt_len, self.num_heads, self.key_dim).transpose(1, 2)\n        k = k.view(bsz, tgt_len, self.num_heads, self.key_dim).transpose(1, 2)\n        qr = theta_shift(q, sin, cos)\n        kr = theta_shift(k, sin, cos)\n\n        if forward_impl == 'parallel':\n            output = self.parallel_forward(qr, kr, v, inner_mask)\n        elif forward_impl == 'recurrent':\n            output, past_key_value = self.recurrent_forward(qr, kr, v, inner_mask, past_key_value=past_key_value)\n\n        output = self.group_norm(output)\n        output = output.reshape(bsz, tgt_len, self.expansion_dim) * gate  # gate\n        output = self.to_out(output)\n        output = self.dropout_module(output)\n\n        return output, past_key_value, k_curr, v_curr\n\n    def _shape(self, tensor: torch.Tensor, seq_len: int, bsz: int):\n        return tensor.view(bsz, seq_len, self.num_heads, self.head_dim).transpose(1, 2).contiguous()\n\n    # retntion parallel forward\n    def recurrent_forward(\n            self,\n            qr, kr, v,\n            decay,\n            past_key_value,\n    ):\n        bsz = v.size(0)\n\n        v = v.view(bsz, self.num_heads, self.head_dim, 1)\n        kv = kr * v\n        if \"prev_key_value\" in past_key_value:\n            prev_kv = past_key_value[\"prev_key_value\"]\n            prev_scale = past_key_value[\"scale\"]\n            scale = prev_scale * decay + 1\n            kv = prev_kv * (prev_scale.sqrt() * decay / scale.sqrt()).view(self.num_heads, 1,\n                                                                           1) + kv / scale.sqrt().view(self.num_heads,\n                                                                                                       1, 1)\n        else:\n            scale = torch.ones_like(decay)\n\n        past_key_value[\"prev_key_value\"] = kv\n        past_key_value[\"scale\"] = scale\n\n        output = torch.sum(qr * kv, dim=3)\n        return output, past_key_value\n\n    def parallel_forward(self, qr, kr, v, mask):\n        bsz, tgt_len, embed_dim = v.size()\n\n        vr = v.view(bsz, tgt_len, self.num_heads, self.expansion_dim // self.num_heads).transpose(1, 2)\n\n        qk_mat = qr @ kr.transpose(-1, -2)  # bsz * m * tgt_len * tgt_len\n        qk_mat = qk_mat * mask\n        # invariant after normalization\n        qk_mat = qk_mat / qk_mat.detach().abs().sum(dim=-1, keepdim=True).clamp(min=1, max=5e4)\n\n        output = torch.matmul(qk_mat, vr)\n        output = output.transpose(1, 2)\n        return output\n\n\nclass RetNetRelPos(nn.Module):\n    def __init__(self, decoder_embed_dim, decoder_retention_heads, query_key_dim):\n        super().__init__()\n        angle = 1.0 / (10000 ** torch.linspace(0, 1, (query_key_dim // decoder_retention_heads) // 2))\n        angle = angle.unsqueeze(-1).repeat(1, 2).flatten()\n        decay = torch.log(1 - 2 ** (-5 - torch.arange(decoder_retention_heads, dtype=torch.float)))\n        self.register_buffer(\"angle\", angle)\n        self.register_buffer(\"decay\", decay)\n\n    def forward(self, slen, activate_recurrent=False):\n        if activate_recurrent:\n            sin = torch.sin(self.angle * (slen - 1))\n            cos = torch.cos(self.angle * (slen - 1))\n            retention_rel_pos = ((sin, cos), self.decay.exp())\n        else:\n            index = torch.arange(slen).to(self.decay)\n            sin = torch.sin(index[:, None] * self.angle[None, :])\n            cos = torch.cos(index[:, None] * self.angle[None, :])\n            mask = torch.tril(torch.ones(slen, slen).to(self.decay))\n            mask = torch.masked_fill(index[:, None] - index[None, :], ~mask.bool(), float(\"inf\"))\n            mask = torch.exp(mask * self.decay[:, None, None])\n            mask = torch.nan_to_num(mask)\n            mask = mask / mask.sum(dim=-1, keepdim=True).sqrt()\n            retention_rel_pos = ((sin, cos), mask)\n\n        return retention_rel_pos\n\n\n@add_start_docstrings(\n    \"The bare LLaMA Model outputting raw hidden-states without any specific head on top.\",\n    LLAMA_START_DOCSTRING,\n)\nclass DenseGAURetNetModel(LlamaPreTrainedModel):\n    \"\"\"\n    Transformer decoder consisting of *config.num_hidden_layers* layers. Each layer is a [`LlamaDecoderLayer`]\n\n    Args:\n        config: LlamaConfig\n    \"\"\"\n\n    def __init__(self, config: LlamaConfig):\n        super().__init__(config)\n        self.padding_idx = config.pad_token_id\n        self.vocab_size = config.vocab_size\n\n        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n        self.layers = nn.ModuleList([LlamaDecoderLayer(config) for _ in range(config.num_hidden_layers)])\n        self.norm = LlamaRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n\n        self.gradient_checkpointing = False\n        # Initialize weights and apply final processing\n        self.post_init()\n        self.retnet_rel_pos = RetNetRelPos(config.hidden_size, config.num_attention_heads,\n                                           config.query_key_dim)\n\n        if config.deepnorm:\n            init_scale = math.pow(8.0 * config.num_hidden_layers, 0.25)\n            for name, p in self.named_parameters():\n\n                if (\n                        \"fc1\" in name\n                        or \"fc2\" in name\n                        or \"gate_proj\" in name\n                        or \"down_proj\" in name\n                        or \"up_proj\" in name\n                        or \"out_proj\" in name\n                        or \"v_proj\" in name\n                        or \"to_hidden\" in name\n                        or \"to_output\" in name\n\n                ):\n                    p.data.div_(init_scale)\n\n    def get_input_embeddings(self):\n        return self.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.embed_tokens = value\n\n    # Copied from transformers.models.bart.modeling_bart.BartDecoder._prepare_decoder_attention_mask\n    def _prepare_decoder_attention_mask(self, attention_mask, input_shape, inputs_embeds, past_key_values_length):\n        # create causal mask\n        # [bsz, seq_len] -> [bsz, 1, tgt_seq_len, src_seq_len]\n        combined_attention_mask = None\n        if input_shape[-1] > 1:\n            combined_attention_mask = _make_causal_mask(\n                input_shape,\n                inputs_embeds.dtype,\n                device=inputs_embeds.device,\n                past_key_values_length=past_key_values_length,\n            )\n\n        if attention_mask is not None:\n            # [bsz, seq_len] -> [bsz, 1, tgt_seq_len, src_seq_len]\n            expanded_attn_mask = _expand_mask(attention_mask, inputs_embeds.dtype, tgt_len=input_shape[-1]).to(\n                inputs_embeds.device\n            )\n            combined_attention_mask = (\n                expanded_attn_mask if combined_attention_mask is None else expanded_attn_mask + combined_attention_mask\n            )\n\n        return combined_attention_mask\n\n    def is_first_step(self, incremental_state):\n        if incremental_state is None:\n            return False\n        return incremental_state.get(\"is_first_step\", False)\n\n    @add_start_docstrings_to_model_forward(LLAMA_INPUTS_DOCSTRING)\n    def forward(\n            self,\n            forward_impl: Optional[str] = 'parallel',\n            input_ids: torch.LongTensor = None,\n            attention_mask: Optional[torch.Tensor] = None,\n            position_ids: Optional[torch.LongTensor] = None,\n            past_key_values: Optional[List[torch.FloatTensor]] = None,\n            inputs_embeds: Optional[torch.FloatTensor] = None,\n            use_cache: Optional[bool] = None,\n            output_attentions: Optional[bool] = None,\n            output_hidden_states: Optional[bool] = None,\n            return_dict: Optional[bool] = None,\n            sequence_offset=0,\n    ) -> Union[Tuple, BaseModelOutputWithPast]:\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        # retrieve input_ids and inputs_embeds\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both decoder_input_ids and decoder_inputs_embeds at the same time\")\n        elif input_ids is not None:\n            batch_size, seq_length = input_ids.shape\n        elif inputs_embeds is not None:\n            batch_size, seq_length, _ = inputs_embeds.shape\n        else:\n            raise ValueError(\"You have to specify either decoder_input_ids or decoder_inputs_embeds\")\n\n        seq_length_with_past = seq_length\n        past_key_values_length = 0\n\n        if position_ids is None:\n            device = input_ids.device if input_ids is not None else inputs_embeds.device\n            position_ids = torch.arange(\n                past_key_values_length, seq_length + past_key_values_length, dtype=torch.long, device=device\n            )\n            position_ids = position_ids.unsqueeze(0).view(-1, seq_length)\n        else:\n            position_ids = position_ids.view(-1, seq_length).long()\n\n        if inputs_embeds is None:\n            inputs_embeds = self.embed_tokens(input_ids)\n        # embed positions\n        if attention_mask is None:\n            attention_mask = torch.ones(\n                (batch_size, seq_length_with_past), dtype=torch.bool, device=inputs_embeds.device\n            )\n        attention_mask = self._prepare_decoder_attention_mask(\n            attention_mask, (batch_size, seq_length), inputs_embeds, past_key_values_length\n        )\n\n        hidden_states = inputs_embeds\n\n        if self.gradient_checkpointing and self.training:\n            if use_cache:\n                logger.warning_once(\n                    \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n                )\n                use_cache = False\n\n        # decoder layer\n        all_hidden_states = () if output_hidden_states else None\n        all_self_attns = () if output_attentions else None\n        next_decoder_cache = [] if use_cache else None\n\n        #\n        k_features = []\n        v_features = []\n        dense_layers = 0\n        for idx, decoder_layer in enumerate(self.layers):\n            if output_hidden_states:\n                all_hidden_states += (hidden_states,)\n            past_key_value = past_key_values[idx] if past_key_values is not None and len(\n                past_key_values) != 0 else {}\n\n            slen = input_ids.size(1)\n            if forward_impl == 'recurrent':\n                slen = sequence_offset\n            rel_pos = self.retnet_rel_pos(slen, forward_impl == 'recurrent',)\n\n            if self.gradient_checkpointing and self.training:\n\n                def create_custom_forward(module):\n                    def custom_forward(*inputs):\n                        return module(*inputs, output_attentions, None)\n\n                    return custom_forward\n\n                hidden_states = layer_outputslayer_outputs = torch.utils.checkpoint.checkpoint(\n                    create_custom_forward(decoder_layer),\n                    hidden_states,\n                    attention_mask,\n                    position_ids,\n                    None,\n                )\n            else:\n                dense = False\n                if idx >= 1:\n                    dense = True\n\n                layer_outputs, past_key_value, k_curr, v_curr = decoder_layer(\n                    hidden_states,\n                    rel_pos,\n                    forward_impl=forward_impl,\n                    attention_mask=attention_mask,\n                    position_ids=position_ids,\n                    past_key_value=past_key_value,\n                    output_attentions=output_attentions,\n                    k_features=k_features,\n                    v_features=v_features,\n                    dense=dense,\n                    dense_layers=dense_layers,\n                )\n                dense_layers += 1\n                k_features.append(k_curr)\n                v_features.append(v_curr)\n                if len(k_features) > self.config.dense_block_layers:\n                    k_features.pop(0)\n                if len(v_features) > self.config.dense_block_layers:\n                    v_features.pop(0)\n\n            hidden_states = layer_outputs  # used to be 3 ele,tmp  1\n\n\n            if use_cache:\n                next_decoder_cache.append(past_key_value)\n\n            if output_attentions:\n                all_self_attns += (layer_outputs[1],)\n\n        hidden_states = self.norm(hidden_states)\n\n        # add hidden states from the last decoder layer\n        if output_hidden_states:\n            all_hidden_states += (hidden_states,)\n\n        next_cache = next_decoder_cache if use_cache else None\n        if not return_dict:\n            return tuple(v for v in [hidden_states, next_cache, all_hidden_states, all_self_attns] if v is not None)\n        return BaseModelOutputWithPast(\n            last_hidden_state=hidden_states,\n            past_key_values=next_cache,\n            hidden_states=all_hidden_states,\n            attentions=all_self_attns,\n        )\n\n\n\n",
    "description": null,
    "url": null
}