{
    "acronym": "ssmlayernonlin",
    "title": "State-space models with layer-wise nonlinearity are universal approximators with exponential decaying memory",
    "seed_ids": [
        "resurrectrnn",
        "hyena"
    ],
    "s2id": "b3caabbae4b7c3b842086b21940ce9d5b25d476f",
    "abstract": "State-space models have gained popularity in sequence modelling due to their simple and efficient network structures. However, the absence of nonlinear activation along the temporal direction limits the model's capacity. In this paper, we prove that stacking state-space models with layer-wise nonlinear activation is sufficient to approximate any continuous sequence-to-sequence relationship. Our findings demonstrate that the addition of layer-wise nonlinear activation enhances the model's capacity to learn complex sequence patterns. Meanwhile, it can be seen both theoretically and empirically that the state-space models do not fundamentally resolve the issue of exponential decaying memory. Theoretical results are justified by numerical verifications.",
    "authors": [
        "Shida Wang",
        "Beichen Xue"
    ],
    "venue": "Neural Information Processing Systems",
    "year": 2023,
    "tldr": "It is proved that stacking state-space models with layer-wise nonlinear activation is sufficient to approximate any continuous sequence-to-sequence relationship.",
    "citationCount": 14,
    "influentialCitationCount": 2,
    "code": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass CustomLinearLayer(nn.Module):\n    def __init__(\n        self,\n        size,\n        dtype,\n        training: bool = True,\n    ):\n        super().__init__()\n        self.size = size\n        self.weight = nn.Parameter(torch.randn(size, dtype=dtype))\n        self.training = training\n\n        if self.training:\n            self.activation = F.relu\n        else:\n            self.activation = torch.nn.Identity()\n\n    def forward(self, x):\n        # Create a diagonal matrix\n        weight = self.activation(self.weight)\n\n        return x * weight\n\n    def stability_margin(self):\n        \"\"\"Return the stability margin of the weight matrix.\n\n        Positive means stable, the larger the better. Negative means unstable.\n        \"\"\"\n\n        if self.training:\n            # Mask for positive weights\n            positive_weights_mask = self.weight > 0\n\n            # Evaluate the smallest positive value in the weight\n            smallest_positive = self.weight[positive_weights_mask].min()\n        else:\n            smallest_positive = self.weight.min()\n\n        return smallest_positive\n\n    def perturb_weight_initialization(self):\n        self.weight.data = F.relu(self.weight.data)\n\n\nclass CustomOrthogonalLayer(nn.Module):\n    def __init__(\n        self,\n        size,\n        dtype,\n    ):\n        super().__init__()\n        self.size = size\n\n        matrix = torch.randn((size, size), dtype=dtype)\n        q, _ = torch.linalg.qr(matrix)\n        self.weight = nn.Parameter(q)  # Now orthogonal\n\n    def forward(self, x, transpose=False):\n        if transpose:\n            return F.linear(x, self.weight.t())\n        else:\n            return F.linear(x, self.weight)\n\n\nclass MLP(nn.Module):\n    \"\"\"_summary_\n\n    Args:\n        d -> hidden_dim -> hidden_dim -> d\n    \"\"\"\n\n    def __init__(self, input_dim, hidden_dim=None, activation=\"linear\"):\n        super().__init__()\n\n        if hidden_dim is None:\n            hidden_dim = input_dim\n\n        if activation == \"linear\":\n            self.activation = torch.nn.Identity()\n        elif activation == \"tanh\":\n            self.activation = torch.tanh\n        elif activation == \"hardtanh\":\n            self.activation = torch.nn.functional.hardtanh\n\n        self.linear1 = nn.Linear(input_dim, hidden_dim, dtype=torch.float64)\n        self.linear2 = nn.Linear(hidden_dim, input_dim, dtype=torch.float64)\n\n    def forward(self, x):\n        x = self.linear1(x)\n        x = self.activation(x)\n        x = self.linear2(x)\n\n        return x\n\n\nclass SimpleSSM(nn.Module):\n    def __init__(\n        self,\n        rec1_size: int = 128,\n        activation: str = \"linear\",\n        dt: float = 1.0,\n        return_sequences: bool = True,\n        training: bool = True,\n    ):\n        super().__init__()\n\n        if activation == \"linear\":\n            self.activation = torch.nn.Identity()\n        elif activation == \"tanh\":\n            self.activation = torch.tanh\n        elif activation == \"hardtanh\":\n            self.activation = torch.nn.functional.hardtanh\n\n        self.W = CustomLinearLayer(rec1_size, dtype=torch.float64, training=training)\n        self.P = CustomOrthogonalLayer(rec1_size, dtype=torch.float64)\n\n        self.g = MLP(input_dim=rec1_size, activation=activation)\n        self.f = MLP(input_dim=rec1_size, activation=activation)\n\n        self.rec1_size = rec1_size\n        self.dt = dt\n        self.return_sequences = return_sequences\n\n    def forward(self, x):\n        batch_size, input_length, rec1_size = x.size()\n        assert rec1_size == self.rec1_size\n\n        # g\n        x = self.g(x)\n\n        hidden = []\n        hidden.append(torch.zeros(1, 1, self.rec1_size, dtype=x.dtype, device=x.device))\n\n        # Residual RNN\n        # Expect W1 to be positive definite to ensure stability\n        for i in range(input_length):\n            h_next = hidden[i] + self.dt * self.activation(\n                x[:, i : i + 1, :]\n                - self.P(self.W(self.P(hidden[i], transpose=False)), transpose=True)\n            )\n            hidden.append(h_next)\n        hidden = torch.cat(hidden[1:], dim=1)\n\n        # f\n        hidden = self.f(hidden)\n\n        # returned sequence or not\n        if self.return_sequences:\n            return hidden\n        else:\n            return hidden[:, -1, :]\n\n    def stability_margin(self):\n        \"\"\"Return the stability margin of the model.\"\"\"\n        return self.W.stability_margin()\n\n    def perturb_weight_initialization(self):\n        \"\"\"Perturb the weight initialization to make the model unstable.\"\"\"\n        self.W.perturb_weight_initialization()\n\n\nif __name__ == \"__main__\":\n    d = 6\n\n    # CustomLinearLayer\n    train_linear_model = CustomLinearLayer(d, dtype=torch.float64, training=True)\n    test_linear_model = CustomLinearLayer(d, dtype=torch.float64, training=False)\n\n    # Shape check\n    inputs = torch.randn(1, 100, d, dtype=torch.float64)\n    outputs = train_linear_model(inputs)\n    assert outputs.shape == (1, 100, d)\n\n    # Stability margin check\n    print(\"Stability margin\", train_linear_model.stability_margin(), \"expected > 0\")\n    print(\"Stability margin\", test_linear_model.stability_margin())\n\n    # SimpleDiagonalRNN\n    train_model = SimpleSSM(d, training=True)\n    test_model = SimpleSSM(d, training=False)\n\n    # Shape check\n    inputs = torch.randn(1, 100, d, dtype=torch.float64)\n    outputs = test_model(inputs)\n    assert outputs.shape == (1, 100, d)\n\n    # Stability margin check\n    print(\"Stability margin\", train_model.stability_margin(), \"expected > 0\")\n    print(\"Stability margin\", test_model.stability_margin())\n\n    print(\n        \"P's L2 norm\",\n        torch.linalg.norm(train_model.P.weight, ord=2),\n        \"expected approximately 1\",\n    )\n\n    # Stability margin check, inside the model should be the same as the train_model\n    # print(\"Stability margin\", train_model.W.stability_margin(), \"expected > 0\")\n    # print(\"Stability margin\", test_model.W.stability_margin())\n\n    print(\"Test passed.\")",
    "description": null,
    "url": null
}