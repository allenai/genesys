{
    "acronym": "tnn",
    "title": "Toeplitz Neural Network for Sequence Modeling",
    "seed_ids": [
        "flash",
        "cosformer",
        "metaformer",
        "s4",
        "alibi",
        "lstransformer",
        "gmlp",
        "fnet",
        "lineartransformer",
        "transformer"
    ],
    "s2id": "f35f5aedc30e2c5ded210d9c91ba6e84bd029425",
    "abstract": "Sequence modeling has important applications in natural language processing and computer vision. Recently, the transformer-based models have shown strong performance on various sequence modeling tasks, which rely on attention to capture pairwise token relations, and position embedding to inject positional information. While showing good performance, the transformer models are inefficient to scale to long input sequences, mainly due to the quadratic space-time complexity of attention. To overcome this inefficiency, we propose to model sequences with a relative position encoded Toeplitz matrix and use a Toeplitz matrix-vector production trick to reduce the space-time complexity of the sequence modeling to log linear. A lightweight sub-network called relative position encoder is proposed to generate relative position coefficients with a fixed budget of parameters, enabling the proposed Toeplitz neural network to deal with varying sequence lengths. In addition, despite being trained on 512-token sequences, our model can extrapolate input sequence length up to 14K tokens in inference with consistent performance. Extensive experiments on autoregressive and bidirectional language modeling, image modeling, and the challenging Long-Range Arena benchmark show that our method achieves better performance than its competitors in most downstream tasks while being significantly faster. The code is available at https://github.com/OpenNLPLab/Tnn.",
    "authors": [
        "Zhen Qin",
        "Xiaodong Han",
        "Weixuan Sun",
        "Bowen He",
        "Dong Li",
        "Dongxu Li",
        "Yuchao Dai",
        "Lingpeng Kong",
        "Yiran Zhong"
    ],
    "venue": "International Conference on Learning Representations",
    "year": 2023,
    "tldr": "A lightweight sub-network called relative position encoder is proposed to generate relative position coefficients with a fixed budget of parameters, enabling the proposed Toeplitz neural network to deal with varying sequence lengths.",
    "citationCount": 26,
    "influentialCitationCount": 2,
    "code": "# https://alinush.github.io/2020/03/19/multiplying-a-vector-by-a-toeplitz-matrix.html\n# https://stackoverflow.com/questions/69809789/is-there-any-way-to-create-a-tensor-with-a-specific-pattern-in-pytorch\n# https://github.com/cheerss/CrossFormer/blob/main/models/crossformer.py\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom einops import rearrange, repeat\n\nfrom .rpe import Rpe\n\nfrom .helpers import get_activation_fn, get_norm_fn, print_params\n\n\n\nclass GLU(nn.Module):\n    def __init__(self, d1, d2, act_fun, fina_act=\"None\", dropout=0.0, bias=True):\n        super().__init__()\n        # get local varables\n        params = locals()\n        # print params\n        print_params(**params)\n        \n        self.l1 = nn.Linear(d1, d2, bias=bias)\n        self.l2 = nn.Linear(d1, d2, bias=bias)\n        self.l3 = nn.Linear(d2, d1, bias=bias)\n        self.act_fun = get_activation_fn(act_fun)\n        self.p = dropout\n        if self.p > 0.0:\n            self.dropout = nn.Dropout(p=dropout)\n        self.fina_act = get_activation_fn(fina_act)\n\n    def forward(self, x):\n        o1 = self.l1(x)\n        weight = self.act_fun(o1)\n        if self.p > 0.0:\n            weight = self.dropout(weight)\n        o2 = self.l2(x)\n        output = weight * o2\n        output = self.l3(output)\n        output = self.fina_act(output)\n\n        return output\n    \nclass Tno(nn.Module):\n    def __init__(\n        self, \n        h, \n        dim, \n        rpe_dim, \n        causal=False, \n        use_decay=False, \n        use_multi_decay=False, \n        residual=False, \n        act=\"relu\", \n        par_type=1, \n        gamma=0.999,\n        bias=True,\n        act_type=\"none\",\n        layers=3,\n        norm_type=\"simplermsnorm\",\n    ):\n        super().__init__()\n        # get local varables\n        params = locals()\n        # print params\n        print_params(**params)\n        \n        self.h = h\n        self.dim = dim\n        self.causal = causal\n        self.par_type = par_type\n        self.zero_value = 0\n        self.use_decay = use_decay\n        if self.use_decay:\n            self.gamma = nn.Parameter(torch.ones(h, 1, dim) * gamma, requires_grad=False)\n        self.use_multi_decay = use_multi_decay\n        if self.use_multi_decay:\n            self.lambda_ = gamma\n            self.gamma = nn.Parameter(torch.randn(h, 1, dim))\n\n        self.rpe = Rpe(\n            dim=rpe_dim, \n            outdim=h * dim, \n            residual=residual,\n            act=act,\n            bias=bias, \n            layers=layers,\n            norm_type=norm_type,\n        )\n        \n        if self.causal:\n            self.forward = self.forward_causal\n        else:\n            self.forward = self.forward_non_causal\n            \n        self.act_fun = get_activation_fn(act_type)\n\n    def get_pos(self, n):\n        if self.par_type == 1:\n            index = torch.arange(1, 1 + n).reshape(n, -1) * 1.0\n        elif self.par_type == 2:\n            index = torch.arange(1, 1 + n).reshape(n, -1) * 1.0 / n\n        elif self.par_type == 3:\n            index = torch.exp(torch.arange(1, 1 + n).reshape(n, -1) * 1.0 / n)\n        \n        return index\n        \n    def get_zero(self):\n        index = torch.zeros(1).reshape(1, -1) * 1.0\n        if self.par_type == 3:\n            index = torch.exp(index)\n            \n        return index\n\n    def get_neg(self, n):\n        if self.causal:\n            index = torch.ones(self.h * n * self.dim).reshape(self.h, n, self.dim) * self.zero_value\n        else:\n            if self.par_type == 1:\n                index = -torch.arange(1, 1 + n).flip(0).reshape(n, -1) * 1.0\n            elif self.par_type == 2:\n                index = -torch.arange(1, 1 + n).flip(0).reshape(n, -1) * 1.0 / n\n\n        return index\n    \n    def rpe_transform(self, x):\n        # n, 1 -> n, (d * h)\n        res = self.rpe(x)\n        # n, (d * h) -> h, n, d\n        res = rearrange(res, 'n (h d) -> h n d', h=self.h)\n\n        return res\n    \n    def forward_causal(self, x, dim=-2, normalize=False):\n        # x: b, h, n, d\n        n = x.shape[dim]\n        # a0, a1, ... , a(n-1), a0, a(-(n-1)), ... , a(-1)\n        ##### coef\n        # 1, d, 1 -> h, 1, d\n        zero = self.rpe_transform(self.get_zero().to(x))\n        pos = self.rpe_transform(self.get_pos(n - 1).to(x))\n\n        if self.use_decay or self.use_multi_decay:\n            coef = torch.arange(1, n).reshape(1, -1, 1).to(x)\n            if self.use_decay:\n                gamma = self.gamma\n            else:\n                gamma = torch.sigmoid(self.gamma)\n                gamma = self.lambda_ + (1 - self.lambda_) * gamma\n            gamma = gamma ** coef\n            pos = gamma * pos\n        a = torch.cat([zero, pos, zero], dim=1)\n        a = self.act_fun(a)\n\n        # x: b, h, n, d\n        # a: h, l, d\n        output = self.compute(x, a, dim, n)\n\n        if normalize:\n            size = list(x.shape[:-1]) + [1]\n            ones = torch.ones(size).to(x)\n            denorm = self.compute(ones, a, dim, n)\n            output = output / denorm\n\n        return output\n        \n    def forward_non_causal(self, x, dim=-2, normalize=False):\n        # x: b, h, n, d\n        n = x.shape[dim]\n        # a0, a1, ... , a(n-1), a0, a(-(n-1)), ... , a(-1)\n        ##### coef\n        # 1, d, 1 -> h, 1, d\n        zero = self.rpe_transform(self.get_zero().to(x))\n        pos = self.rpe_transform(self.get_pos(n - 1).to(x))\n        neg_index = self.get_neg(n - 1).to(x)\n        if self.causal:\n            neg = neg_index\n        else:\n            neg = self.rpe_transform(neg_index)\n\n        if self.use_decay or self.use_multi_decay:\n            coef = torch.arange(1, n).reshape(1, -1, 1).to(x)\n            if self.use_decay:\n                gamma = self.gamma\n            else:\n                gamma = torch.sigmoid(self.gamma)\n                gamma = self.lambda_ + (1 - self.lambda_) * gamma\n            gamma = gamma ** coef\n            pos = gamma * pos\n            neg = torch.flip(gamma, dims=[1]) * neg\n        a = torch.cat([zero, pos, zero, neg], dim=1)\n        a = self.act_fun(a)\n        # x: b, h, n, d\n        # a: h, l, d\n        output = self.compute(x, a, dim, n)\n\n        if normalize:\n            size = list(x.shape[:-1]) + [1]\n            ones = torch.ones(size).to(x)\n            denorm = self.compute(ones, a, dim, n)\n            output = output / denorm\n\n        return output\n    \n    def compute(self, x, a, dim, n):\n        # x: b, h, n, d\n        # a: h, n, d\n        y = torch.fft.rfft(x, 2 * n, dim=dim)\n        v = torch.fft.rfft(a, 2 * n, dim=dim).unsqueeze(0)\n        u = v * y\n        output = torch.fft.irfft(u, 2 * n, dim=dim)[:, :, :n, :]\n\n        return output\n\n    def toeplizt_matrix(self, x, dim):\n        assert dim == -2\n        # shape of x: b, h, n, d\n        n = x.shape[dim]\n        # c: first col, r: first row\n        # 1, d, 1 -> h, 1, d\n        zero = self.rpe_transform(self.get_zero().to(x))\n        pos = self.rpe_transform(self.get_pos(n - 1).to(x))\n        neg_index = self.get_neg(n - 1).to(x)\n        if self.causal:\n            neg = neg_index\n        else:\n            neg = self.rpe_transform(neg_index)\n                \n        if self.use_decay or self.use_multi_decay:\n            coef = torch.arange(1, n).reshape(1, -1, 1)\n            if self.use_decay:\n                gamma = self.gamma\n            else:\n                gamma = torch.sigmoid(self.gamma)\n                gamma = self.lambda_ + (1 - self.lambda_) * gamma\n            gamma = gamma ** coef\n            pos = gamma * pos\n            neg = torch.flip(gamma, dims=[1]) * neg\n        zero = self.act_fun(zero)\n        pos = self.act_fun(pos)\n        if not self.causal:\n            neg = self.act_fun(neg)\n        c = torch.cat([zero, pos], dim=-2)\n        r = torch.cat([zero, neg.flip(1)], dim=-2)\n        vals = torch.cat([r, c[:, 1:].flip(1)], dim=-2)\n        n = c.shape[-2]\n        shape = self.h, n, n\n        i, j = torch.ones(n, n).nonzero().T\n        T = vals[:, j - i].reshape(self.h, n, n, -1)\n\n        res = torch.einsum('h n m d, b h m d -> b h n d', T, x)\n        return res\n\nclass Gtu(nn.Module):\n    def __init__(\n        self,\n        embed_dim,\n        num_heads,\n        bias=True,\n        act_fun=\"silu\",\n        causal=False,\n        expand_ratio=3,\n        resi_param=False,\n        use_norm=False,\n        norm_type=\"simplermsnorm\",\n        use_decay=False,\n        use_multi_decay=False,\n        rpe_layers=3,\n        rpe_embedding=512,\n        rpe_act=\"relu\",\n        normalize=False,\n        par_type=1,\n        residual=False,\n        gamma=0.99,\n        act_type=\"none\",\n    ):\n        super().__init__()\n        self.embed_dim = embed_dim\n        self.expand_ratio = expand_ratio\n        self.resi_param = resi_param\n        self.num_heads = num_heads\n        self.normalize = normalize\n        \n        if self.resi_param:\n            self.d = nn.Parameter(torch.randn(embed_dim))\n\n        d1 = int(self.expand_ratio * embed_dim)\n        d1 = (d1 // self.num_heads) * self.num_heads\n        self.head_dim = d1 // num_heads\n        # linear projection\n        self.v_proj = nn.Linear(embed_dim, d1, bias=bias)\n        self.u_proj = nn.Linear(embed_dim, d1, bias=bias)\n        self.o = nn.Linear(d1, embed_dim, bias=bias)\n        self.act = get_activation_fn(act_fun)\n        # tno\n        self.toep = Tno(\n            h=num_heads, \n            dim=self.head_dim,\n            rpe_dim=rpe_embedding, \n            causal=causal, \n            use_decay=use_decay, \n            use_multi_decay=use_multi_decay,\n            residual=residual,\n            act=rpe_act,\n            par_type=par_type,\n            gamma=gamma,\n            bias=bias,\n            act_type=act_type,\n            layers=rpe_layers,\n            norm_type=norm_type,\n        )\n        # norm\n        self.norm_type = norm_type\n        self.use_norm = use_norm\n        if self.use_norm:\n            self.norm = get_norm_fn(self.norm_type)(d1)\n    \n    def forward(self, x):\n        # x: b, h, w, d\n        num_heads = self.num_heads\n\n        if self.resi_param:\n            shortcut = shortcut * self.d\n        u = self.act(self.u_proj(x))\n        v = self.act(self.v_proj(x))\n        # reshape\n        v = rearrange(v, 'b n (h d) -> b h n d', h=num_heads)\n        output = self.toep(v, dim=-2, normalize=self.normalize)\n        output = rearrange(output, 'b h n d -> b n (h d)')\n        output = u * output\n        if self.use_norm:\n            output = self.norm(output)\n            \n        output = self.o(output)\n        \n        return output\n\nclass TnnLayer(nn.Module):\n    def __init__(\n        self, \n        dim, \n        num_heads,\n        rpe_embedding,\n        glu_dim,\n        # model params\n        prenorm=True,\n        norm_type=\"simplermsnorm\",\n        # gtu params\n        causal=False,\n        gtu_act=\"silu\",\n        expand_ratio=3,\n        use_decay=False,\n        gamma=0.999,\n        # rpe params\n        rpe_act=\"relu\",\n        rpe_layers=3,\n        # glu params\n        glu_act=\"silu\",\n    ):\n        super().__init__()\n        self.token_mixer = Gtu(\n            # gtu params\n            embed_dim=dim,\n            num_heads=num_heads,\n            act_fun=gtu_act,\n            norm_type=norm_type,\n            causal=causal,\n            expand_ratio=expand_ratio,\n            use_decay=use_decay,\n            gamma=gamma,\n            # rpe params\n            rpe_embedding=rpe_embedding,\n            rpe_act=rpe_act,\n            rpe_layers=rpe_layers,\n        )\n\n        self.token_norm = get_norm_fn(norm_type)(dim)\n        self.feature_norm = get_norm_fn(norm_type)(dim)\n        \n        self.feature_mixer = GLU(\n            d1=dim, \n            d2=glu_dim,\n            act_fun=glu_act,\n        )\n        \n        if prenorm:\n            self.forward = self.forward_prenorm\n        else:\n            self.forward = self.forward_postnorm\n\n    def forward_postnorm(self, x):\n        x = x + self.token_norm(self.token_mixer(x))\n        x = x + self.feature_norm(self.feature_mixer(x))\n\n        return x\n    \n    def forward_prenorm(self, x):\n        x = x + self.token_mixer(self.token_norm(x))\n        x = x + self.feature_mixer(self.feature_norm(x))\n\n        return x",
    "description": null,
    "url": null
}