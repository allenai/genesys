{
    "31M": {
        "31M": "import torch\nimport torch.nn as nn\nfrom model_discovery.model.utils.modules import GABBase\n\n\nclass GAB(GABBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, device=None, dtype\n        =None, **kwargs):\n        factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc)\n        self.root = GPT2(embed_dim=embed_dim, block_loc=block_loc,\n            kwarg_all=kwargs, **factory_kwargs, **kwargs)\n\n    def _forward(self, X, **Z):\n        X, Z = self.root(X, **Z)\n        return X, Z\n\n\nimport torch.nn.functional as F\nfrom model_discovery.model.utils.modules import GAUBase, gau_test, UnitDecl\n\n\nclass GPT2(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.mha = HierarchicalAdaptiveAttention(embed_dim=self.embed_dim,\n            block_loc=self.block_loc, kwarg_all=self.kwarg_all, **self.\n            factory_kwargs, **self.kwarg_all)\n        self.mlp = GatedMLP(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm1 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm2 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        X1, Z = self.norm1(X, **Z)\n        X2, Z = self.mha(X1, **Z)\n        X = X + X2\n        X3, Z = self.norm2(X, **Z)\n        X4, Z = self.mlp(X3, **Z)\n        X = X + X4\n        return X, Z\n\n\nimport torch.nn.functional as F\nimport math\nfrom einops import rearrange\n\n\nclass HierarchicalAdaptiveAttention(GAUBase):\n    \"\"\"\n    Hierarchical Adaptive Multi-Head Attention (HA-MHA)\n\n    This module implements a hierarchical adaptive multi-head attention mechanism that\n    captures multi-scale dependencies in the input sequence. It organizes attention heads\n    into hierarchical groups, each responsible for capturing dependencies at different scales\n    (e.g., local, medium, global). An adaptive gating mechanism dynamically allocates attention\n    resources based on the input context, allowing the model to focus on the most relevant\n    information at each scale.\n\n    **Main Features:**\n    - **Hierarchical Structure**: Attention heads are grouped into multiple scales to capture\n      dependencies at different levels.\n    - **Multi-Scale Linear Attention**: Reduces computational complexity from O(N^2) to O(N)\n      within each hierarchical group using linear attention mechanisms.\n    - **Adaptive Gating Mechanism**: Dynamically scales the contribution of each hierarchical group\n      based on the input context using a gating function.\n    - **Dynamic Composition**: Composes attention outputs from all hierarchical groups adaptively.\n    - **Rotary Positional Embeddings**: Incorporates positional information using rotary embeddings.\n\n    Args:\n        embed_dim (int): Total embedding dimension.\n        block_loc (tuple): Location of the block within the network.\n        kwarg_all (dict): Additional keyword arguments.\n        device (torch.device, optional): The device to use.\n        dtype (torch.dtype, optional): The data type to use.\n        num_heads (int): Total number of attention heads.\n        num_scales (int): Number of hierarchical scales.\n        dropout (float): Dropout probability.\n        rotary_emb_base (float): Base for rotary positional embeddings.\n        **kwargs: Additional keyword arguments.\n\n    Attributes:\n        head_dim (int): Dimension of each attention head.\n        query_projs (nn.ModuleList): List of query projections for each scale.\n        key_projs (nn.ModuleList): List of key projections for each scale.\n        value_projs (nn.ModuleList): List of value projections for each scale.\n        gate_proj (nn.Linear): Linear layer for adaptive gating.\n        out_proj (nn.Linear): Output projection layer.\n        rotary_emb (RotaryPositionalEmbeddings): Positional embedding module.\n\n    Shape:\n        - Input: X of shape (batch_size, seq_len, embed_dim)\n        - Output: Y of shape (batch_size, seq_len, embed_dim)\n\n    Examples:\n        >>> attn = HierarchicalAdaptiveAttention(embed_dim=512, block_loc=(0, 1), kwarg_all={}, num_heads=8, num_scales=2)\n        >>> X = torch.randn(2, 10, 512)\n        >>> Y, Z = attn(X)\n        >>> Y.shape\n        torch.Size([2, 10, 512])\n\n    References:\n        - Paper: \"HieraNorm-AttnGPT: Hierarchical Adaptive Multi-Head Attention with Dynamic Layer Normalization\"\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, num_heads: int=8, num_scales: int=2,\n        dropout: float=0.1, rotary_emb_base: float=10000.0, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        assert embed_dim % (num_heads * num_scales\n            ) == 0, 'embed_dim must be divisible by num_heads * num_scales'\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.num_scales = num_scales\n        self.head_dim = embed_dim // (num_heads * num_scales)\n        self.dropout = dropout\n        self.query_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.key_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.value_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.gate_proj = nn.Linear(embed_dim, num_scales, bias=False, **\n            self.factory_kwargs)\n        self.out_proj = nn.Linear(num_heads * self.head_dim * num_scales,\n            embed_dim, **self.factory_kwargs)\n        self.dropout_layer = nn.Dropout(p=self.dropout)\n        kwarg_all['rotary_emb_dim'] = self.head_dim\n        self.rotary_emb = RotaryPositionalEmbeddings(embed_dim=self.\n            embed_dim, block_loc=self.block_loc, kwarg_all=self.kwarg_all,\n            **self.factory_kwargs, **self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        B, L, D = X.size()\n        assert D == self.embed_dim, f'Expected input embedding dimension: {self.embed_dim}, got: {D}'\n        gate_scores = torch.sigmoid(self.gate_proj(X))\n        attn_outputs = []\n        for scale in range(self.num_scales):\n            Q = self.query_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            K = self.key_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            V = self.value_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            Z['input_emb'] = Q\n            _, Z = self.rotary_emb(X, **Z)\n            Q = Z['output_emb']\n            Z['input_emb'] = K\n            _, Z = self.rotary_emb(X, **Z)\n            K = Z['output_emb']\n            scaling_factor = 1.0 / math.sqrt(self.head_dim)\n            Q = Q * scaling_factor\n            K = F.softmax(K, dim=-1)\n            V = V\n            KV = torch.einsum('bhld,bhld->bhld', K, V)\n            attn_output = torch.einsum('bhld,bhld->bhld', Q, KV)\n            attn_output = self.dropout_layer(attn_output)\n            attn_outputs.append(attn_output)\n        attn_output = torch.cat(attn_outputs, dim=-1)\n        attn_output = attn_output.transpose(1, 2).reshape(B, L, -1)\n        gate_scores = gate_scores.unsqueeze(-1)\n        gate_scores = gate_scores.expand(-1, -1, -1, self.num_heads * self.\n            head_dim)\n        attn_output = attn_output.view(B, L, self.num_scales, self.\n            num_heads * self.head_dim)\n        attn_output = attn_output * gate_scores\n        attn_output = attn_output.reshape(B, L, -1)\n        Y = self.out_proj(attn_output)\n        return Y, Z\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\nfrom typing import Optional\n\n\nclass RotaryPositionalEmbeddings(GAUBase):\n    \"\"\"\n    This class implements Rotary Positional Embeddings (RoPE)\n    proposed in https://arxiv.org/abs/2104.09864.\n\n    Reference implementation (used for correctness verfication)\n    can be found here:\n    https://github.com/meta-llama/llama/blob/main/llama/model.py#L80\n\n    In this implementation we cache the embeddings for each position upto\n    ``max_seq_len`` by computing this during init.\n\n    Args:\n        dim (int): Embedding dimension. This is usually set to the dim of each\n            head in the attention module computed as ````embed_dim`` // ``num_heads````\n        max_seq_len (int): Maximum expected sequence length for the\n            model, if exceeded the cached freqs will be recomputed\n        base (int): The base for the geometric progression used to compute\n            the rotation angles\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, rotary_emb_base: int=10000, rotary_emb_dim:\n        int=None, max_seq_len: int=4096, **kwargs) ->None:\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.dim = rotary_emb_dim\n        self.base = rotary_emb_base\n        self.max_seq_len = max_seq_len\n        self._rope_init()\n\n    def reset_parameters(self):\n        self._rope_init()\n\n    def _rope_init(self):\n        theta = 1.0 / self.base ** (torch.arange(0, self.dim, 2, **self.\n            factory_kwargs)[:self.dim // 2].float() / self.dim)\n        self.register_buffer('theta', theta, persistent=False)\n        self.build_rope_cache(self.max_seq_len)\n\n    def build_rope_cache(self, max_seq_len: int=4096) ->None:\n        seq_idx = torch.arange(max_seq_len, dtype=self.theta.dtype, device=\n            self.theta.device)\n        idx_theta = torch.einsum('i, j -> ij', seq_idx, self.theta).float()\n        cache = torch.stack([torch.cos(idx_theta), torch.sin(idx_theta)],\n            dim=-1)\n        self.register_buffer('cache', cache, persistent=False)\n\n    def _forward(self, X: Tensor, input_emb: Tensor, input_pos: Optional[\n        Tensor]=None) ->Tensor:\n        \"\"\"\n        Args:\n            x (Tensor): input tensor with shape\n                [b, s, n_h, h_d]\n            input_pos (Optional[Tensor]): Optional tensor which contains the position ids\n                of each token. During training, this is used to indicate the positions\n                of each token relative to its sample when packed, shape [b, s].\n                During inference, this indicates the position of the current token.\n                If none, assume the index of the token is its position id. Default is None.\n\n        Returns:\n            Tensor: output tensor with RoPE applied\n\n        Notation used for tensor shapes:\n            - b: batch size\n            - s: sequence length\n            - n_h: num heads\n            - h_d: head dim\n\n        TODO: The implementation below can be made more efficient\n        for inference.\n        \"\"\"\n        seq_len = input_emb.size(1)\n        rope_cache = self.cache[:seq_len] if input_pos is None else self.cache[\n            input_pos]\n        xshaped = input_emb.float().reshape(*input_emb.shape[:-1], -1, 2)\n        rope_cache = rope_cache.view(-1, xshaped.size(1), 1, xshaped.size(3), 2\n            )\n        x_out = torch.stack([xshaped[..., 0] * rope_cache[..., 0] - xshaped\n            [..., 1] * rope_cache[..., 1], xshaped[..., 1] * rope_cache[...,\n            0] + xshaped[..., 0] * rope_cache[..., 1]], -1)\n        x_out = x_out.flatten(3)\n        output_emb = x_out.type_as(input_emb)\n        return X, {'output_emb': output_emb}\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\n\n\nclass RMSNorm(GAUBase):\n    \"\"\"\n    Root Mean Square Layer Normalization (RMSNorm).\n\n    This layer applies a variant of layer normalization that uses only the root mean square\n    statistics, without centering. It's computationally more efficient than standard\n    layer normalization and has been shown to be effective in various NLP tasks.\n\n    Args:\n        embed_dim (int): The size of the input feature dimension.\n        block_loc (tuple): The location of this block in the model architecture.\n        kwarg_all (dict): Additional keyword arguments passed to the parent class.\n        device (torch.device, optional): The device on which to allocate the module's parameters.\n        dtype (torch.dtype, optional): The dtype of the module's parameters.\n        eps (float, optional): A small constant added to the denominator for numerical stability.\n            Default: 1e-5.\n\n    Attributes:\n        weight (nn.Parameter): Learnable scale parameter of shape (embed_dim,).\n        variance_epsilon (float): The epsilon value used in the normalization formula.\n\n    Shape:\n        - Input: (*, embed_dim)\n        - Output: (*, embed_dim) (same shape as input)\n\n    Examples:\n        >>> rmsnorm = RMSNorm(128, (0, 6), {})\n        >>> x = torch.randn(1, 100, 128)\n        >>> output = rmsnorm(x)\n        >>> print(output.shape)\n        torch.Size([1, 100, 128])\n\n    References:\n        - Paper: \"Root Mean Square Layer Normalization\" by Biao Zhang and Rico Sennrich\n          https://arxiv.org/abs/1910.07467\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, eps=1e-05, **kwargs):\n        \"\"\"If group_size is not None, we do GroupNorm with each group having group_size elements.\n        group_size=None is equivalent to group_size=hidden_size (i.e. there's only 1 group).\n        \"\"\"\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.weight = nn.Parameter(torch.ones(embed_dim, **self.factory_kwargs)\n            )\n        self.variance_epsilon = eps\n\n    def _forward(self, X, **Z):\n        input_dtype = X.dtype\n        X = X.to(torch.float32)\n        variance = X.pow(2).mean(-1, keepdim=True)\n        X = X * torch.rsqrt(variance + self.variance_epsilon)\n        return self.weight * X.to(input_dtype)\n\n\nimport torch.nn.functional as F\n\n\nclass GatedMLP(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, hidden_features=None, out_features=None,\n        activation=None, bias=False, multiple_of=128, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        out_features = out_features if out_features is not None else embed_dim\n        hidden_features = (hidden_features if hidden_features is not None else\n            int(8 * embed_dim / 3))\n        hidden_features = (hidden_features + multiple_of - 1\n            ) // multiple_of * multiple_of\n        self.fc1 = nn.Linear(embed_dim, 2 * hidden_features, bias=bias, **\n            self.factory_kwargs)\n        self.activation = activation if activation is not None else F.silu\n        self.fc2 = nn.Linear(hidden_features, out_features, bias=bias, **\n            self.factory_kwargs)\n\n    def _forward(self, X, **Z):\n        y = self.fc1(X)\n        y, gate = y.chunk(2, dim=-1)\n        y = y * self.activation(gate)\n        y = self.fc2(y)\n        return y\n\n\ngab_config = {'eps': 1e-05, 'rotary_emb_base': 10000.0, 'max_seq_len': 4096,\n    'hidden_features': None, 'out_features': None, 'activation': None,\n    'bias': False, 'multiple_of': 128, 'num_heads': 8, 'num_scales': 2,\n    'dropout': 0.1}\n\n\n\nautoconfig={}\nblock_config=gab_config\nblock_config.update(autoconfig)\n\n\nfrom .block_registry import BlockRegister\n\nBlockRegister(\n    name=\"default\",\n    config=block_config\n)(GAB)"
    },
    "760M": {
        "760M": "import torch\nimport torch.nn as nn\nfrom model_discovery.model.utils.modules import GABBase\n\n\nclass GAB(GABBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, device=None, dtype\n        =None, **kwargs):\n        factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc)\n        self.root = GPT2(embed_dim=embed_dim, block_loc=block_loc,\n            kwarg_all=kwargs, **factory_kwargs, **kwargs)\n\n    def _forward(self, X, **Z):\n        X, Z = self.root(X, **Z)\n        return X, Z\n\n\nimport torch.nn.functional as F\nfrom model_discovery.model.utils.modules import GAUBase, gau_test, UnitDecl\n\n\nclass GPT2(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.mha = HierarchicalAdaptiveAttention(embed_dim=self.embed_dim,\n            block_loc=self.block_loc, kwarg_all=self.kwarg_all, **self.\n            factory_kwargs, **self.kwarg_all)\n        self.mlp = GatedMLP(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm1 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm2 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        X1, Z = self.norm1(X, **Z)\n        X2, Z = self.mha(X1, **Z)\n        X = X + X2\n        X3, Z = self.norm2(X, **Z)\n        X4, Z = self.mlp(X3, **Z)\n        X = X + X4\n        return X, Z\n\n\nimport torch.nn.functional as F\nimport math\nfrom einops import rearrange\n\n\nclass HierarchicalAdaptiveAttention(GAUBase):\n    \"\"\"\n    Hierarchical Adaptive Multi-Head Attention (HA-MHA)\n\n    This module implements a hierarchical adaptive multi-head attention mechanism that\n    captures multi-scale dependencies in the input sequence. It organizes attention heads\n    into hierarchical groups, each responsible for capturing dependencies at different scales\n    (e.g., local, medium, global). An adaptive gating mechanism dynamically allocates attention\n    resources based on the input context, allowing the model to focus on the most relevant\n    information at each scale.\n\n    **Main Features:**\n    - **Hierarchical Structure**: Attention heads are grouped into multiple scales to capture\n      dependencies at different levels.\n    - **Multi-Scale Linear Attention**: Reduces computational complexity from O(N^2) to O(N)\n      within each hierarchical group using linear attention mechanisms.\n    - **Adaptive Gating Mechanism**: Dynamically scales the contribution of each hierarchical group\n      based on the input context using a gating function.\n    - **Dynamic Composition**: Composes attention outputs from all hierarchical groups adaptively.\n    - **Rotary Positional Embeddings**: Incorporates positional information using rotary embeddings.\n\n    Args:\n        embed_dim (int): Total embedding dimension.\n        block_loc (tuple): Location of the block within the network.\n        kwarg_all (dict): Additional keyword arguments.\n        device (torch.device, optional): The device to use.\n        dtype (torch.dtype, optional): The data type to use.\n        num_heads (int): Total number of attention heads.\n        num_scales (int): Number of hierarchical scales.\n        dropout (float): Dropout probability.\n        rotary_emb_base (float): Base for rotary positional embeddings.\n        **kwargs: Additional keyword arguments.\n\n    Attributes:\n        head_dim (int): Dimension of each attention head.\n        query_projs (nn.ModuleList): List of query projections for each scale.\n        key_projs (nn.ModuleList): List of key projections for each scale.\n        value_projs (nn.ModuleList): List of value projections for each scale.\n        gate_proj (nn.Linear): Linear layer for adaptive gating.\n        out_proj (nn.Linear): Output projection layer.\n        rotary_emb (RotaryPositionalEmbeddings): Positional embedding module.\n\n    Shape:\n        - Input: X of shape (batch_size, seq_len, embed_dim)\n        - Output: Y of shape (batch_size, seq_len, embed_dim)\n\n    Examples:\n        >>> attn = HierarchicalAdaptiveAttention(embed_dim=512, block_loc=(0, 1), kwarg_all={}, num_heads=8, num_scales=2)\n        >>> X = torch.randn(2, 10, 512)\n        >>> Y, Z = attn(X)\n        >>> Y.shape\n        torch.Size([2, 10, 512])\n\n    References:\n        - Paper: \"HieraNorm-AttnGPT: Hierarchical Adaptive Multi-Head Attention with Dynamic Layer Normalization\"\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, num_heads: int=8, num_scales: int=2,\n        dropout: float=0.1, rotary_emb_base: float=10000.0, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        assert embed_dim % (num_heads * num_scales\n            ) == 0, 'embed_dim must be divisible by num_heads * num_scales'\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.num_scales = num_scales\n        self.head_dim = embed_dim // (num_heads * num_scales)\n        self.dropout = dropout\n        self.query_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.key_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.value_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.gate_proj = nn.Linear(embed_dim, num_scales, bias=False, **\n            self.factory_kwargs)\n        self.out_proj = nn.Linear(num_heads * self.head_dim * num_scales,\n            embed_dim, **self.factory_kwargs)\n        self.dropout_layer = nn.Dropout(p=self.dropout)\n        kwarg_all['rotary_emb_dim'] = self.head_dim\n        self.rotary_emb = RotaryPositionalEmbeddings(embed_dim=self.\n            embed_dim, block_loc=self.block_loc, kwarg_all=self.kwarg_all,\n            **self.factory_kwargs, **self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        B, L, D = X.size()\n        assert D == self.embed_dim, f'Expected input embedding dimension: {self.embed_dim}, got: {D}'\n        gate_scores = torch.sigmoid(self.gate_proj(X))\n        attn_outputs = []\n        for scale in range(self.num_scales):\n            Q = self.query_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            K = self.key_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            V = self.value_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            Z['input_emb'] = Q\n            _, Z = self.rotary_emb(X, **Z)\n            Q = Z['output_emb']\n            Z['input_emb'] = K\n            _, Z = self.rotary_emb(X, **Z)\n            K = Z['output_emb']\n            scaling_factor = 1.0 / math.sqrt(self.head_dim)\n            Q = Q * scaling_factor\n            K = F.softmax(K, dim=-1)\n            V = V\n            KV = torch.einsum('bhld,bhld->bhld', K, V)\n            attn_output = torch.einsum('bhld,bhld->bhld', Q, KV)\n            attn_output = self.dropout_layer(attn_output)\n            attn_outputs.append(attn_output)\n        attn_output = torch.cat(attn_outputs, dim=-1)\n        attn_output = attn_output.transpose(1, 2).reshape(B, L, -1)\n        gate_scores = gate_scores.unsqueeze(-1)\n        gate_scores = gate_scores.expand(-1, -1, -1, self.num_heads * self.\n            head_dim)\n        attn_output = attn_output.view(B, L, self.num_scales, self.\n            num_heads * self.head_dim)\n        attn_output = attn_output * gate_scores\n        attn_output = attn_output.reshape(B, L, -1)\n        Y = self.out_proj(attn_output)\n        return Y, Z\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\nfrom typing import Optional\n\n\nclass RotaryPositionalEmbeddings(GAUBase):\n    \"\"\"\n    This class implements Rotary Positional Embeddings (RoPE)\n    proposed in https://arxiv.org/abs/2104.09864.\n\n    Reference implementation (used for correctness verfication)\n    can be found here:\n    https://github.com/meta-llama/llama/blob/main/llama/model.py#L80\n\n    In this implementation we cache the embeddings for each position upto\n    ``max_seq_len`` by computing this during init.\n\n    Args:\n        dim (int): Embedding dimension. This is usually set to the dim of each\n            head in the attention module computed as ````embed_dim`` // ``num_heads````\n        max_seq_len (int): Maximum expected sequence length for the\n            model, if exceeded the cached freqs will be recomputed\n        base (int): The base for the geometric progression used to compute\n            the rotation angles\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, rotary_emb_base: int=10000, rotary_emb_dim:\n        int=None, max_seq_len: int=4096, **kwargs) ->None:\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.dim = rotary_emb_dim\n        self.base = rotary_emb_base\n        self.max_seq_len = max_seq_len\n        self._rope_init()\n\n    def reset_parameters(self):\n        self._rope_init()\n\n    def _rope_init(self):\n        theta = 1.0 / self.base ** (torch.arange(0, self.dim, 2, **self.\n            factory_kwargs)[:self.dim // 2].float() / self.dim)\n        self.register_buffer('theta', theta, persistent=False)\n        self.build_rope_cache(self.max_seq_len)\n\n    def build_rope_cache(self, max_seq_len: int=4096) ->None:\n        seq_idx = torch.arange(max_seq_len, dtype=self.theta.dtype, device=\n            self.theta.device)\n        idx_theta = torch.einsum('i, j -> ij', seq_idx, self.theta).float()\n        cache = torch.stack([torch.cos(idx_theta), torch.sin(idx_theta)],\n            dim=-1)\n        self.register_buffer('cache', cache, persistent=False)\n\n    def _forward(self, X: Tensor, input_emb: Tensor, input_pos: Optional[\n        Tensor]=None) ->Tensor:\n        \"\"\"\n        Args:\n            x (Tensor): input tensor with shape\n                [b, s, n_h, h_d]\n            input_pos (Optional[Tensor]): Optional tensor which contains the position ids\n                of each token. During training, this is used to indicate the positions\n                of each token relative to its sample when packed, shape [b, s].\n                During inference, this indicates the position of the current token.\n                If none, assume the index of the token is its position id. Default is None.\n\n        Returns:\n            Tensor: output tensor with RoPE applied\n\n        Notation used for tensor shapes:\n            - b: batch size\n            - s: sequence length\n            - n_h: num heads\n            - h_d: head dim\n\n        TODO: The implementation below can be made more efficient\n        for inference.\n        \"\"\"\n        seq_len = input_emb.size(1)\n        rope_cache = self.cache[:seq_len] if input_pos is None else self.cache[\n            input_pos]\n        xshaped = input_emb.float().reshape(*input_emb.shape[:-1], -1, 2)\n        rope_cache = rope_cache.view(-1, xshaped.size(1), 1, xshaped.size(3), 2\n            )\n        x_out = torch.stack([xshaped[..., 0] * rope_cache[..., 0] - xshaped\n            [..., 1] * rope_cache[..., 1], xshaped[..., 1] * rope_cache[...,\n            0] + xshaped[..., 0] * rope_cache[..., 1]], -1)\n        x_out = x_out.flatten(3)\n        output_emb = x_out.type_as(input_emb)\n        return X, {'output_emb': output_emb}\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\n\n\nclass RMSNorm(GAUBase):\n    \"\"\"\n    Root Mean Square Layer Normalization (RMSNorm).\n\n    This layer applies a variant of layer normalization that uses only the root mean square\n    statistics, without centering. It's computationally more efficient than standard\n    layer normalization and has been shown to be effective in various NLP tasks.\n\n    Args:\n        embed_dim (int): The size of the input feature dimension.\n        block_loc (tuple): The location of this block in the model architecture.\n        kwarg_all (dict): Additional keyword arguments passed to the parent class.\n        device (torch.device, optional): The device on which to allocate the module's parameters.\n        dtype (torch.dtype, optional): The dtype of the module's parameters.\n        eps (float, optional): A small constant added to the denominator for numerical stability.\n            Default: 1e-5.\n\n    Attributes:\n        weight (nn.Parameter): Learnable scale parameter of shape (embed_dim,).\n        variance_epsilon (float): The epsilon value used in the normalization formula.\n\n    Shape:\n        - Input: (*, embed_dim)\n        - Output: (*, embed_dim) (same shape as input)\n\n    Examples:\n        >>> rmsnorm = RMSNorm(128, (0, 6), {})\n        >>> x = torch.randn(1, 100, 128)\n        >>> output = rmsnorm(x)\n        >>> print(output.shape)\n        torch.Size([1, 100, 128])\n\n    References:\n        - Paper: \"Root Mean Square Layer Normalization\" by Biao Zhang and Rico Sennrich\n          https://arxiv.org/abs/1910.07467\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, eps=1e-05, **kwargs):\n        \"\"\"If group_size is not None, we do GroupNorm with each group having group_size elements.\n        group_size=None is equivalent to group_size=hidden_size (i.e. there's only 1 group).\n        \"\"\"\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.weight = nn.Parameter(torch.ones(embed_dim, **self.factory_kwargs)\n            )\n        self.variance_epsilon = eps\n\n    def _forward(self, X, **Z):\n        input_dtype = X.dtype\n        X = X.to(torch.float32)\n        variance = X.pow(2).mean(-1, keepdim=True)\n        X = X * torch.rsqrt(variance + self.variance_epsilon)\n        return self.weight * X.to(input_dtype)\n\n\nimport torch.nn.functional as F\n\n\nclass GatedMLP(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, hidden_features=None, out_features=None,\n        activation=None, bias=False, multiple_of=128, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        out_features = out_features if out_features is not None else embed_dim\n        hidden_features = (hidden_features if hidden_features is not None else\n            int(8 * embed_dim / 3))\n        hidden_features = (hidden_features + multiple_of - 1\n            ) // multiple_of * multiple_of\n        self.fc1 = nn.Linear(embed_dim, 2 * hidden_features, bias=bias, **\n            self.factory_kwargs)\n        self.activation = activation if activation is not None else F.silu\n        self.fc2 = nn.Linear(hidden_features, out_features, bias=bias, **\n            self.factory_kwargs)\n\n    def _forward(self, X, **Z):\n        y = self.fc1(X)\n        y, gate = y.chunk(2, dim=-1)\n        y = y * self.activation(gate)\n        y = self.fc2(y)\n        return y\n\n\ngab_config = {'eps': 1e-05, 'rotary_emb_base': 10000.0, 'max_seq_len': 4096,\n    'hidden_features': None, 'out_features': None, 'activation': None,\n    'bias': False, 'multiple_of': 128, 'num_heads': 8, 'num_scales': 2,\n    'dropout': 0.1}\n\n\n\nautoconfig={}\nblock_config=gab_config\nblock_config.update(autoconfig)\n\n\nfrom .block_registry import BlockRegister\n\nBlockRegister(\n    name=\"default\",\n    config=block_config\n)(GAB)"
    },
    "70M": {
        "70M": "import torch\nimport torch.nn as nn\nfrom model_discovery.model.utils.modules import GABBase\n\n\nclass GAB(GABBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, device=None, dtype\n        =None, **kwargs):\n        factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc)\n        self.root = GPT2(embed_dim=embed_dim, block_loc=block_loc,\n            kwarg_all=kwargs, **factory_kwargs, **kwargs)\n\n    def _forward(self, X, **Z):\n        X, Z = self.root(X, **Z)\n        return X, Z\n\n\nimport torch.nn.functional as F\nfrom model_discovery.model.utils.modules import GAUBase, gau_test, UnitDecl\n\n\nclass GPT2(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.mha = HierarchicalAdaptiveAttention(embed_dim=self.embed_dim,\n            block_loc=self.block_loc, kwarg_all=self.kwarg_all, **self.\n            factory_kwargs, **self.kwarg_all)\n        self.mlp = GatedMLP(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm1 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm2 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        X1, Z = self.norm1(X, **Z)\n        X2, Z = self.mha(X1, **Z)\n        X = X + X2\n        X3, Z = self.norm2(X, **Z)\n        X4, Z = self.mlp(X3, **Z)\n        X = X + X4\n        return X, Z\n\n\nimport torch.nn.functional as F\nimport math\nfrom einops import rearrange\n\n\nclass HierarchicalAdaptiveAttention(GAUBase):\n    \"\"\"\n    Hierarchical Adaptive Multi-Head Attention (HA-MHA)\n\n    This module implements a hierarchical adaptive multi-head attention mechanism that\n    captures multi-scale dependencies in the input sequence. It organizes attention heads\n    into hierarchical groups, each responsible for capturing dependencies at different scales\n    (e.g., local, medium, global). An adaptive gating mechanism dynamically allocates attention\n    resources based on the input context, allowing the model to focus on the most relevant\n    information at each scale.\n\n    **Main Features:**\n    - **Hierarchical Structure**: Attention heads are grouped into multiple scales to capture\n      dependencies at different levels.\n    - **Multi-Scale Linear Attention**: Reduces computational complexity from O(N^2) to O(N)\n      within each hierarchical group using linear attention mechanisms.\n    - **Adaptive Gating Mechanism**: Dynamically scales the contribution of each hierarchical group\n      based on the input context using a gating function.\n    - **Dynamic Composition**: Composes attention outputs from all hierarchical groups adaptively.\n    - **Rotary Positional Embeddings**: Incorporates positional information using rotary embeddings.\n\n    Args:\n        embed_dim (int): Total embedding dimension.\n        block_loc (tuple): Location of the block within the network.\n        kwarg_all (dict): Additional keyword arguments.\n        device (torch.device, optional): The device to use.\n        dtype (torch.dtype, optional): The data type to use.\n        num_heads (int): Total number of attention heads.\n        num_scales (int): Number of hierarchical scales.\n        dropout (float): Dropout probability.\n        rotary_emb_base (float): Base for rotary positional embeddings.\n        **kwargs: Additional keyword arguments.\n\n    Attributes:\n        head_dim (int): Dimension of each attention head.\n        query_projs (nn.ModuleList): List of query projections for each scale.\n        key_projs (nn.ModuleList): List of key projections for each scale.\n        value_projs (nn.ModuleList): List of value projections for each scale.\n        gate_proj (nn.Linear): Linear layer for adaptive gating.\n        out_proj (nn.Linear): Output projection layer.\n        rotary_emb (RotaryPositionalEmbeddings): Positional embedding module.\n\n    Shape:\n        - Input: X of shape (batch_size, seq_len, embed_dim)\n        - Output: Y of shape (batch_size, seq_len, embed_dim)\n\n    Examples:\n        >>> attn = HierarchicalAdaptiveAttention(embed_dim=512, block_loc=(0, 1), kwarg_all={}, num_heads=8, num_scales=2)\n        >>> X = torch.randn(2, 10, 512)\n        >>> Y, Z = attn(X)\n        >>> Y.shape\n        torch.Size([2, 10, 512])\n\n    References:\n        - Paper: \"HieraNorm-AttnGPT: Hierarchical Adaptive Multi-Head Attention with Dynamic Layer Normalization\"\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, num_heads: int=8, num_scales: int=2,\n        dropout: float=0.1, rotary_emb_base: float=10000.0, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        assert embed_dim % (num_heads * num_scales\n            ) == 0, 'embed_dim must be divisible by num_heads * num_scales'\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.num_scales = num_scales\n        self.head_dim = embed_dim // (num_heads * num_scales)\n        self.dropout = dropout\n        self.query_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.key_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.value_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.gate_proj = nn.Linear(embed_dim, num_scales, bias=False, **\n            self.factory_kwargs)\n        self.out_proj = nn.Linear(num_heads * self.head_dim * num_scales,\n            embed_dim, **self.factory_kwargs)\n        self.dropout_layer = nn.Dropout(p=self.dropout)\n        kwarg_all['rotary_emb_dim'] = self.head_dim\n        self.rotary_emb = RotaryPositionalEmbeddings(embed_dim=self.\n            embed_dim, block_loc=self.block_loc, kwarg_all=self.kwarg_all,\n            **self.factory_kwargs, **self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        B, L, D = X.size()\n        assert D == self.embed_dim, f'Expected input embedding dimension: {self.embed_dim}, got: {D}'\n        gate_scores = torch.sigmoid(self.gate_proj(X))\n        attn_outputs = []\n        for scale in range(self.num_scales):\n            Q = self.query_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            K = self.key_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            V = self.value_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            Z['input_emb'] = Q\n            _, Z = self.rotary_emb(X, **Z)\n            Q = Z['output_emb']\n            Z['input_emb'] = K\n            _, Z = self.rotary_emb(X, **Z)\n            K = Z['output_emb']\n            scaling_factor = 1.0 / math.sqrt(self.head_dim)\n            Q = Q * scaling_factor\n            K = F.softmax(K, dim=-1)\n            V = V\n            KV = torch.einsum('bhld,bhld->bhld', K, V)\n            attn_output = torch.einsum('bhld,bhld->bhld', Q, KV)\n            attn_output = self.dropout_layer(attn_output)\n            attn_outputs.append(attn_output)\n        attn_output = torch.cat(attn_outputs, dim=-1)\n        attn_output = attn_output.transpose(1, 2).reshape(B, L, -1)\n        gate_scores = gate_scores.unsqueeze(-1)\n        gate_scores = gate_scores.expand(-1, -1, -1, self.num_heads * self.\n            head_dim)\n        attn_output = attn_output.view(B, L, self.num_scales, self.\n            num_heads * self.head_dim)\n        attn_output = attn_output * gate_scores\n        attn_output = attn_output.reshape(B, L, -1)\n        Y = self.out_proj(attn_output)\n        return Y, Z\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\nfrom typing import Optional\n\n\nclass RotaryPositionalEmbeddings(GAUBase):\n    \"\"\"\n    This class implements Rotary Positional Embeddings (RoPE)\n    proposed in https://arxiv.org/abs/2104.09864.\n\n    Reference implementation (used for correctness verfication)\n    can be found here:\n    https://github.com/meta-llama/llama/blob/main/llama/model.py#L80\n\n    In this implementation we cache the embeddings for each position upto\n    ``max_seq_len`` by computing this during init.\n\n    Args:\n        dim (int): Embedding dimension. This is usually set to the dim of each\n            head in the attention module computed as ````embed_dim`` // ``num_heads````\n        max_seq_len (int): Maximum expected sequence length for the\n            model, if exceeded the cached freqs will be recomputed\n        base (int): The base for the geometric progression used to compute\n            the rotation angles\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, rotary_emb_base: int=10000, rotary_emb_dim:\n        int=None, max_seq_len: int=4096, **kwargs) ->None:\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.dim = rotary_emb_dim\n        self.base = rotary_emb_base\n        self.max_seq_len = max_seq_len\n        self._rope_init()\n\n    def reset_parameters(self):\n        self._rope_init()\n\n    def _rope_init(self):\n        theta = 1.0 / self.base ** (torch.arange(0, self.dim, 2, **self.\n            factory_kwargs)[:self.dim // 2].float() / self.dim)\n        self.register_buffer('theta', theta, persistent=False)\n        self.build_rope_cache(self.max_seq_len)\n\n    def build_rope_cache(self, max_seq_len: int=4096) ->None:\n        seq_idx = torch.arange(max_seq_len, dtype=self.theta.dtype, device=\n            self.theta.device)\n        idx_theta = torch.einsum('i, j -> ij', seq_idx, self.theta).float()\n        cache = torch.stack([torch.cos(idx_theta), torch.sin(idx_theta)],\n            dim=-1)\n        self.register_buffer('cache', cache, persistent=False)\n\n    def _forward(self, X: Tensor, input_emb: Tensor, input_pos: Optional[\n        Tensor]=None) ->Tensor:\n        \"\"\"\n        Args:\n            x (Tensor): input tensor with shape\n                [b, s, n_h, h_d]\n            input_pos (Optional[Tensor]): Optional tensor which contains the position ids\n                of each token. During training, this is used to indicate the positions\n                of each token relative to its sample when packed, shape [b, s].\n                During inference, this indicates the position of the current token.\n                If none, assume the index of the token is its position id. Default is None.\n\n        Returns:\n            Tensor: output tensor with RoPE applied\n\n        Notation used for tensor shapes:\n            - b: batch size\n            - s: sequence length\n            - n_h: num heads\n            - h_d: head dim\n\n        TODO: The implementation below can be made more efficient\n        for inference.\n        \"\"\"\n        seq_len = input_emb.size(1)\n        rope_cache = self.cache[:seq_len] if input_pos is None else self.cache[\n            input_pos]\n        xshaped = input_emb.float().reshape(*input_emb.shape[:-1], -1, 2)\n        rope_cache = rope_cache.view(-1, xshaped.size(1), 1, xshaped.size(3), 2\n            )\n        x_out = torch.stack([xshaped[..., 0] * rope_cache[..., 0] - xshaped\n            [..., 1] * rope_cache[..., 1], xshaped[..., 1] * rope_cache[...,\n            0] + xshaped[..., 0] * rope_cache[..., 1]], -1)\n        x_out = x_out.flatten(3)\n        output_emb = x_out.type_as(input_emb)\n        return X, {'output_emb': output_emb}\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\n\n\nclass RMSNorm(GAUBase):\n    \"\"\"\n    Root Mean Square Layer Normalization (RMSNorm).\n\n    This layer applies a variant of layer normalization that uses only the root mean square\n    statistics, without centering. It's computationally more efficient than standard\n    layer normalization and has been shown to be effective in various NLP tasks.\n\n    Args:\n        embed_dim (int): The size of the input feature dimension.\n        block_loc (tuple): The location of this block in the model architecture.\n        kwarg_all (dict): Additional keyword arguments passed to the parent class.\n        device (torch.device, optional): The device on which to allocate the module's parameters.\n        dtype (torch.dtype, optional): The dtype of the module's parameters.\n        eps (float, optional): A small constant added to the denominator for numerical stability.\n            Default: 1e-5.\n\n    Attributes:\n        weight (nn.Parameter): Learnable scale parameter of shape (embed_dim,).\n        variance_epsilon (float): The epsilon value used in the normalization formula.\n\n    Shape:\n        - Input: (*, embed_dim)\n        - Output: (*, embed_dim) (same shape as input)\n\n    Examples:\n        >>> rmsnorm = RMSNorm(128, (0, 6), {})\n        >>> x = torch.randn(1, 100, 128)\n        >>> output = rmsnorm(x)\n        >>> print(output.shape)\n        torch.Size([1, 100, 128])\n\n    References:\n        - Paper: \"Root Mean Square Layer Normalization\" by Biao Zhang and Rico Sennrich\n          https://arxiv.org/abs/1910.07467\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, eps=1e-05, **kwargs):\n        \"\"\"If group_size is not None, we do GroupNorm with each group having group_size elements.\n        group_size=None is equivalent to group_size=hidden_size (i.e. there's only 1 group).\n        \"\"\"\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.weight = nn.Parameter(torch.ones(embed_dim, **self.factory_kwargs)\n            )\n        self.variance_epsilon = eps\n\n    def _forward(self, X, **Z):\n        input_dtype = X.dtype\n        X = X.to(torch.float32)\n        variance = X.pow(2).mean(-1, keepdim=True)\n        X = X * torch.rsqrt(variance + self.variance_epsilon)\n        return self.weight * X.to(input_dtype)\n\n\nimport torch.nn.functional as F\n\n\nclass GatedMLP(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, hidden_features=None, out_features=None,\n        activation=None, bias=False, multiple_of=128, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        out_features = out_features if out_features is not None else embed_dim\n        hidden_features = (hidden_features if hidden_features is not None else\n            int(8 * embed_dim / 3))\n        hidden_features = (hidden_features + multiple_of - 1\n            ) // multiple_of * multiple_of\n        self.fc1 = nn.Linear(embed_dim, 2 * hidden_features, bias=bias, **\n            self.factory_kwargs)\n        self.activation = activation if activation is not None else F.silu\n        self.fc2 = nn.Linear(hidden_features, out_features, bias=bias, **\n            self.factory_kwargs)\n\n    def _forward(self, X, **Z):\n        y = self.fc1(X)\n        y, gate = y.chunk(2, dim=-1)\n        y = y * self.activation(gate)\n        y = self.fc2(y)\n        return y\n\n\ngab_config = {'eps': 1e-05, 'rotary_emb_base': 10000.0, 'max_seq_len': 4096,\n    'hidden_features': None, 'out_features': None, 'activation': None,\n    'bias': False, 'multiple_of': 128, 'num_heads': 8, 'num_scales': 2,\n    'dropout': 0.1}\n\n\n\nautoconfig={}\nblock_config=gab_config\nblock_config.update(autoconfig)\n\n\nfrom .block_registry import BlockRegister\n\nBlockRegister(\n    name=\"default\",\n    config=block_config\n)(GAB)"
    },
    "1300M": {
        "1300M": "import torch\nimport torch.nn as nn\nfrom model_discovery.model.utils.modules import GABBase\n\n\nclass GAB(GABBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, device=None, dtype\n        =None, **kwargs):\n        factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc)\n        self.root = GPT2(embed_dim=embed_dim, block_loc=block_loc,\n            kwarg_all=kwargs, **factory_kwargs, **kwargs)\n\n    def _forward(self, X, **Z):\n        X, Z = self.root(X, **Z)\n        return X, Z\n\n\nimport torch.nn.functional as F\nfrom model_discovery.model.utils.modules import GAUBase, gau_test, UnitDecl\n\n\nclass GPT2(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.mha = HierarchicalAdaptiveAttention(embed_dim=self.embed_dim,\n            block_loc=self.block_loc, kwarg_all=self.kwarg_all, **self.\n            factory_kwargs, **self.kwarg_all)\n        self.mlp = GatedMLP(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm1 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm2 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        X1, Z = self.norm1(X, **Z)\n        X2, Z = self.mha(X1, **Z)\n        X = X + X2\n        X3, Z = self.norm2(X, **Z)\n        X4, Z = self.mlp(X3, **Z)\n        X = X + X4\n        return X, Z\n\n\nimport torch.nn.functional as F\nimport math\nfrom einops import rearrange\n\n\nclass HierarchicalAdaptiveAttention(GAUBase):\n    \"\"\"\n    Hierarchical Adaptive Multi-Head Attention (HA-MHA)\n\n    This module implements a hierarchical adaptive multi-head attention mechanism that\n    captures multi-scale dependencies in the input sequence. It organizes attention heads\n    into hierarchical groups, each responsible for capturing dependencies at different scales\n    (e.g., local, medium, global). An adaptive gating mechanism dynamically allocates attention\n    resources based on the input context, allowing the model to focus on the most relevant\n    information at each scale.\n\n    **Main Features:**\n    - **Hierarchical Structure**: Attention heads are grouped into multiple scales to capture\n      dependencies at different levels.\n    - **Multi-Scale Linear Attention**: Reduces computational complexity from O(N^2) to O(N)\n      within each hierarchical group using linear attention mechanisms.\n    - **Adaptive Gating Mechanism**: Dynamically scales the contribution of each hierarchical group\n      based on the input context using a gating function.\n    - **Dynamic Composition**: Composes attention outputs from all hierarchical groups adaptively.\n    - **Rotary Positional Embeddings**: Incorporates positional information using rotary embeddings.\n\n    Args:\n        embed_dim (int): Total embedding dimension.\n        block_loc (tuple): Location of the block within the network.\n        kwarg_all (dict): Additional keyword arguments.\n        device (torch.device, optional): The device to use.\n        dtype (torch.dtype, optional): The data type to use.\n        num_heads (int): Total number of attention heads.\n        num_scales (int): Number of hierarchical scales.\n        dropout (float): Dropout probability.\n        rotary_emb_base (float): Base for rotary positional embeddings.\n        **kwargs: Additional keyword arguments.\n\n    Attributes:\n        head_dim (int): Dimension of each attention head.\n        query_projs (nn.ModuleList): List of query projections for each scale.\n        key_projs (nn.ModuleList): List of key projections for each scale.\n        value_projs (nn.ModuleList): List of value projections for each scale.\n        gate_proj (nn.Linear): Linear layer for adaptive gating.\n        out_proj (nn.Linear): Output projection layer.\n        rotary_emb (RotaryPositionalEmbeddings): Positional embedding module.\n\n    Shape:\n        - Input: X of shape (batch_size, seq_len, embed_dim)\n        - Output: Y of shape (batch_size, seq_len, embed_dim)\n\n    Examples:\n        >>> attn = HierarchicalAdaptiveAttention(embed_dim=512, block_loc=(0, 1), kwarg_all={}, num_heads=8, num_scales=2)\n        >>> X = torch.randn(2, 10, 512)\n        >>> Y, Z = attn(X)\n        >>> Y.shape\n        torch.Size([2, 10, 512])\n\n    References:\n        - Paper: \"HieraNorm-AttnGPT: Hierarchical Adaptive Multi-Head Attention with Dynamic Layer Normalization\"\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, num_heads: int=8, num_scales: int=2,\n        dropout: float=0.1, rotary_emb_base: float=10000.0, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        assert embed_dim % (num_heads * num_scales\n            ) == 0, 'embed_dim must be divisible by num_heads * num_scales'\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.num_scales = num_scales\n        self.head_dim = embed_dim // (num_heads * num_scales)\n        self.dropout = dropout\n        self.query_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.key_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.value_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.gate_proj = nn.Linear(embed_dim, num_scales, bias=False, **\n            self.factory_kwargs)\n        self.out_proj = nn.Linear(num_heads * self.head_dim * num_scales,\n            embed_dim, **self.factory_kwargs)\n        self.dropout_layer = nn.Dropout(p=self.dropout)\n        kwarg_all['rotary_emb_dim'] = self.head_dim\n        self.rotary_emb = RotaryPositionalEmbeddings(embed_dim=self.\n            embed_dim, block_loc=self.block_loc, kwarg_all=self.kwarg_all,\n            **self.factory_kwargs, **self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        B, L, D = X.size()\n        assert D == self.embed_dim, f'Expected input embedding dimension: {self.embed_dim}, got: {D}'\n        gate_scores = torch.sigmoid(self.gate_proj(X))\n        attn_outputs = []\n        for scale in range(self.num_scales):\n            Q = self.query_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            K = self.key_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            V = self.value_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            Z['input_emb'] = Q\n            _, Z = self.rotary_emb(X, **Z)\n            Q = Z['output_emb']\n            Z['input_emb'] = K\n            _, Z = self.rotary_emb(X, **Z)\n            K = Z['output_emb']\n            scaling_factor = 1.0 / math.sqrt(self.head_dim)\n            Q = Q * scaling_factor\n            K = F.softmax(K, dim=-1)\n            V = V\n            KV = torch.einsum('bhld,bhld->bhld', K, V)\n            attn_output = torch.einsum('bhld,bhld->bhld', Q, KV)\n            attn_output = self.dropout_layer(attn_output)\n            attn_outputs.append(attn_output)\n        attn_output = torch.cat(attn_outputs, dim=-1)\n        attn_output = attn_output.transpose(1, 2).reshape(B, L, -1)\n        gate_scores = gate_scores.unsqueeze(-1)\n        gate_scores = gate_scores.expand(-1, -1, -1, self.num_heads * self.\n            head_dim)\n        attn_output = attn_output.view(B, L, self.num_scales, self.\n            num_heads * self.head_dim)\n        attn_output = attn_output * gate_scores\n        attn_output = attn_output.reshape(B, L, -1)\n        Y = self.out_proj(attn_output)\n        return Y, Z\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\nfrom typing import Optional\n\n\nclass RotaryPositionalEmbeddings(GAUBase):\n    \"\"\"\n    This class implements Rotary Positional Embeddings (RoPE)\n    proposed in https://arxiv.org/abs/2104.09864.\n\n    Reference implementation (used for correctness verfication)\n    can be found here:\n    https://github.com/meta-llama/llama/blob/main/llama/model.py#L80\n\n    In this implementation we cache the embeddings for each position upto\n    ``max_seq_len`` by computing this during init.\n\n    Args:\n        dim (int): Embedding dimension. This is usually set to the dim of each\n            head in the attention module computed as ````embed_dim`` // ``num_heads````\n        max_seq_len (int): Maximum expected sequence length for the\n            model, if exceeded the cached freqs will be recomputed\n        base (int): The base for the geometric progression used to compute\n            the rotation angles\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, rotary_emb_base: int=10000, rotary_emb_dim:\n        int=None, max_seq_len: int=4096, **kwargs) ->None:\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.dim = rotary_emb_dim\n        self.base = rotary_emb_base\n        self.max_seq_len = max_seq_len\n        self._rope_init()\n\n    def reset_parameters(self):\n        self._rope_init()\n\n    def _rope_init(self):\n        theta = 1.0 / self.base ** (torch.arange(0, self.dim, 2, **self.\n            factory_kwargs)[:self.dim // 2].float() / self.dim)\n        self.register_buffer('theta', theta, persistent=False)\n        self.build_rope_cache(self.max_seq_len)\n\n    def build_rope_cache(self, max_seq_len: int=4096) ->None:\n        seq_idx = torch.arange(max_seq_len, dtype=self.theta.dtype, device=\n            self.theta.device)\n        idx_theta = torch.einsum('i, j -> ij', seq_idx, self.theta).float()\n        cache = torch.stack([torch.cos(idx_theta), torch.sin(idx_theta)],\n            dim=-1)\n        self.register_buffer('cache', cache, persistent=False)\n\n    def _forward(self, X: Tensor, input_emb: Tensor, input_pos: Optional[\n        Tensor]=None) ->Tensor:\n        \"\"\"\n        Args:\n            x (Tensor): input tensor with shape\n                [b, s, n_h, h_d]\n            input_pos (Optional[Tensor]): Optional tensor which contains the position ids\n                of each token. During training, this is used to indicate the positions\n                of each token relative to its sample when packed, shape [b, s].\n                During inference, this indicates the position of the current token.\n                If none, assume the index of the token is its position id. Default is None.\n\n        Returns:\n            Tensor: output tensor with RoPE applied\n\n        Notation used for tensor shapes:\n            - b: batch size\n            - s: sequence length\n            - n_h: num heads\n            - h_d: head dim\n\n        TODO: The implementation below can be made more efficient\n        for inference.\n        \"\"\"\n        seq_len = input_emb.size(1)\n        rope_cache = self.cache[:seq_len] if input_pos is None else self.cache[\n            input_pos]\n        xshaped = input_emb.float().reshape(*input_emb.shape[:-1], -1, 2)\n        rope_cache = rope_cache.view(-1, xshaped.size(1), 1, xshaped.size(3), 2\n            )\n        x_out = torch.stack([xshaped[..., 0] * rope_cache[..., 0] - xshaped\n            [..., 1] * rope_cache[..., 1], xshaped[..., 1] * rope_cache[...,\n            0] + xshaped[..., 0] * rope_cache[..., 1]], -1)\n        x_out = x_out.flatten(3)\n        output_emb = x_out.type_as(input_emb)\n        return X, {'output_emb': output_emb}\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\n\n\nclass RMSNorm(GAUBase):\n    \"\"\"\n    Root Mean Square Layer Normalization (RMSNorm).\n\n    This layer applies a variant of layer normalization that uses only the root mean square\n    statistics, without centering. It's computationally more efficient than standard\n    layer normalization and has been shown to be effective in various NLP tasks.\n\n    Args:\n        embed_dim (int): The size of the input feature dimension.\n        block_loc (tuple): The location of this block in the model architecture.\n        kwarg_all (dict): Additional keyword arguments passed to the parent class.\n        device (torch.device, optional): The device on which to allocate the module's parameters.\n        dtype (torch.dtype, optional): The dtype of the module's parameters.\n        eps (float, optional): A small constant added to the denominator for numerical stability.\n            Default: 1e-5.\n\n    Attributes:\n        weight (nn.Parameter): Learnable scale parameter of shape (embed_dim,).\n        variance_epsilon (float): The epsilon value used in the normalization formula.\n\n    Shape:\n        - Input: (*, embed_dim)\n        - Output: (*, embed_dim) (same shape as input)\n\n    Examples:\n        >>> rmsnorm = RMSNorm(128, (0, 6), {})\n        >>> x = torch.randn(1, 100, 128)\n        >>> output = rmsnorm(x)\n        >>> print(output.shape)\n        torch.Size([1, 100, 128])\n\n    References:\n        - Paper: \"Root Mean Square Layer Normalization\" by Biao Zhang and Rico Sennrich\n          https://arxiv.org/abs/1910.07467\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, eps=1e-05, **kwargs):\n        \"\"\"If group_size is not None, we do GroupNorm with each group having group_size elements.\n        group_size=None is equivalent to group_size=hidden_size (i.e. there's only 1 group).\n        \"\"\"\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.weight = nn.Parameter(torch.ones(embed_dim, **self.factory_kwargs)\n            )\n        self.variance_epsilon = eps\n\n    def _forward(self, X, **Z):\n        input_dtype = X.dtype\n        X = X.to(torch.float32)\n        variance = X.pow(2).mean(-1, keepdim=True)\n        X = X * torch.rsqrt(variance + self.variance_epsilon)\n        return self.weight * X.to(input_dtype)\n\n\nimport torch.nn.functional as F\n\n\nclass GatedMLP(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, hidden_features=None, out_features=None,\n        activation=None, bias=False, multiple_of=128, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        out_features = out_features if out_features is not None else embed_dim\n        hidden_features = (hidden_features if hidden_features is not None else\n            int(8 * embed_dim / 3))\n        hidden_features = (hidden_features + multiple_of - 1\n            ) // multiple_of * multiple_of\n        self.fc1 = nn.Linear(embed_dim, 2 * hidden_features, bias=bias, **\n            self.factory_kwargs)\n        self.activation = activation if activation is not None else F.silu\n        self.fc2 = nn.Linear(hidden_features, out_features, bias=bias, **\n            self.factory_kwargs)\n\n    def _forward(self, X, **Z):\n        y = self.fc1(X)\n        y, gate = y.chunk(2, dim=-1)\n        y = y * self.activation(gate)\n        y = self.fc2(y)\n        return y\n\n\ngab_config = {'eps': 1e-05, 'rotary_emb_base': 10000.0, 'max_seq_len': 4096,\n    'hidden_features': None, 'out_features': None, 'activation': None,\n    'bias': False, 'multiple_of': 128, 'num_heads': 8, 'num_scales': 2,\n    'dropout': 0.1}\n\n\n\nautoconfig={}\nblock_config=gab_config\nblock_config.update(autoconfig)\n\n\nfrom .block_registry import BlockRegister\n\nBlockRegister(\n    name=\"default\",\n    config=block_config\n)(GAB)"
    },
    "125M": {
        "125M": "import torch\nimport torch.nn as nn\nfrom model_discovery.model.utils.modules import GABBase\n\n\nclass GAB(GABBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, device=None, dtype\n        =None, **kwargs):\n        factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc)\n        self.root = GPT2(embed_dim=embed_dim, block_loc=block_loc,\n            kwarg_all=kwargs, **factory_kwargs, **kwargs)\n\n    def _forward(self, X, **Z):\n        X, Z = self.root(X, **Z)\n        return X, Z\n\n\nimport torch.nn.functional as F\nfrom model_discovery.model.utils.modules import GAUBase, gau_test, UnitDecl\n\n\nclass GPT2(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.mha = HierarchicalAdaptiveAttention(embed_dim=self.embed_dim,\n            block_loc=self.block_loc, kwarg_all=self.kwarg_all, **self.\n            factory_kwargs, **self.kwarg_all)\n        self.mlp = GatedMLP(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm1 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm2 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        X1, Z = self.norm1(X, **Z)\n        X2, Z = self.mha(X1, **Z)\n        X = X + X2\n        X3, Z = self.norm2(X, **Z)\n        X4, Z = self.mlp(X3, **Z)\n        X = X + X4\n        return X, Z\n\n\nimport torch.nn.functional as F\nimport math\nfrom einops import rearrange\n\n\nclass HierarchicalAdaptiveAttention(GAUBase):\n    \"\"\"\n    Hierarchical Adaptive Multi-Head Attention (HA-MHA)\n\n    This module implements a hierarchical adaptive multi-head attention mechanism that\n    captures multi-scale dependencies in the input sequence. It organizes attention heads\n    into hierarchical groups, each responsible for capturing dependencies at different scales\n    (e.g., local, medium, global). An adaptive gating mechanism dynamically allocates attention\n    resources based on the input context, allowing the model to focus on the most relevant\n    information at each scale.\n\n    **Main Features:**\n    - **Hierarchical Structure**: Attention heads are grouped into multiple scales to capture\n      dependencies at different levels.\n    - **Multi-Scale Linear Attention**: Reduces computational complexity from O(N^2) to O(N)\n      within each hierarchical group using linear attention mechanisms.\n    - **Adaptive Gating Mechanism**: Dynamically scales the contribution of each hierarchical group\n      based on the input context using a gating function.\n    - **Dynamic Composition**: Composes attention outputs from all hierarchical groups adaptively.\n    - **Rotary Positional Embeddings**: Incorporates positional information using rotary embeddings.\n\n    Args:\n        embed_dim (int): Total embedding dimension.\n        block_loc (tuple): Location of the block within the network.\n        kwarg_all (dict): Additional keyword arguments.\n        device (torch.device, optional): The device to use.\n        dtype (torch.dtype, optional): The data type to use.\n        num_heads (int): Total number of attention heads.\n        num_scales (int): Number of hierarchical scales.\n        dropout (float): Dropout probability.\n        rotary_emb_base (float): Base for rotary positional embeddings.\n        **kwargs: Additional keyword arguments.\n\n    Attributes:\n        head_dim (int): Dimension of each attention head.\n        query_projs (nn.ModuleList): List of query projections for each scale.\n        key_projs (nn.ModuleList): List of key projections for each scale.\n        value_projs (nn.ModuleList): List of value projections for each scale.\n        gate_proj (nn.Linear): Linear layer for adaptive gating.\n        out_proj (nn.Linear): Output projection layer.\n        rotary_emb (RotaryPositionalEmbeddings): Positional embedding module.\n\n    Shape:\n        - Input: X of shape (batch_size, seq_len, embed_dim)\n        - Output: Y of shape (batch_size, seq_len, embed_dim)\n\n    Examples:\n        >>> attn = HierarchicalAdaptiveAttention(embed_dim=512, block_loc=(0, 1), kwarg_all={}, num_heads=8, num_scales=2)\n        >>> X = torch.randn(2, 10, 512)\n        >>> Y, Z = attn(X)\n        >>> Y.shape\n        torch.Size([2, 10, 512])\n\n    References:\n        - Paper: \"HieraNorm-AttnGPT: Hierarchical Adaptive Multi-Head Attention with Dynamic Layer Normalization\"\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, num_heads: int=8, num_scales: int=2,\n        dropout: float=0.1, rotary_emb_base: float=10000.0, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        assert embed_dim % (num_heads * num_scales\n            ) == 0, 'embed_dim must be divisible by num_heads * num_scales'\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.num_scales = num_scales\n        self.head_dim = embed_dim // (num_heads * num_scales)\n        self.dropout = dropout\n        self.query_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.key_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.value_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.gate_proj = nn.Linear(embed_dim, num_scales, bias=False, **\n            self.factory_kwargs)\n        self.out_proj = nn.Linear(num_heads * self.head_dim * num_scales,\n            embed_dim, **self.factory_kwargs)\n        self.dropout_layer = nn.Dropout(p=self.dropout)\n        kwarg_all['rotary_emb_dim'] = self.head_dim\n        self.rotary_emb = RotaryPositionalEmbeddings(embed_dim=self.\n            embed_dim, block_loc=self.block_loc, kwarg_all=self.kwarg_all,\n            **self.factory_kwargs, **self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        B, L, D = X.size()\n        assert D == self.embed_dim, f'Expected input embedding dimension: {self.embed_dim}, got: {D}'\n        gate_scores = torch.sigmoid(self.gate_proj(X))\n        attn_outputs = []\n        for scale in range(self.num_scales):\n            Q = self.query_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            K = self.key_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            V = self.value_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            Z['input_emb'] = Q\n            _, Z = self.rotary_emb(X, **Z)\n            Q = Z['output_emb']\n            Z['input_emb'] = K\n            _, Z = self.rotary_emb(X, **Z)\n            K = Z['output_emb']\n            scaling_factor = 1.0 / math.sqrt(self.head_dim)\n            Q = Q * scaling_factor\n            K = F.softmax(K, dim=-1)\n            V = V\n            KV = torch.einsum('bhld,bhld->bhld', K, V)\n            attn_output = torch.einsum('bhld,bhld->bhld', Q, KV)\n            attn_output = self.dropout_layer(attn_output)\n            attn_outputs.append(attn_output)\n        attn_output = torch.cat(attn_outputs, dim=-1)\n        attn_output = attn_output.transpose(1, 2).reshape(B, L, -1)\n        gate_scores = gate_scores.unsqueeze(-1)\n        gate_scores = gate_scores.expand(-1, -1, -1, self.num_heads * self.\n            head_dim)\n        attn_output = attn_output.view(B, L, self.num_scales, self.\n            num_heads * self.head_dim)\n        attn_output = attn_output * gate_scores\n        attn_output = attn_output.reshape(B, L, -1)\n        Y = self.out_proj(attn_output)\n        return Y, Z\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\nfrom typing import Optional\n\n\nclass RotaryPositionalEmbeddings(GAUBase):\n    \"\"\"\n    This class implements Rotary Positional Embeddings (RoPE)\n    proposed in https://arxiv.org/abs/2104.09864.\n\n    Reference implementation (used for correctness verfication)\n    can be found here:\n    https://github.com/meta-llama/llama/blob/main/llama/model.py#L80\n\n    In this implementation we cache the embeddings for each position upto\n    ``max_seq_len`` by computing this during init.\n\n    Args:\n        dim (int): Embedding dimension. This is usually set to the dim of each\n            head in the attention module computed as ````embed_dim`` // ``num_heads````\n        max_seq_len (int): Maximum expected sequence length for the\n            model, if exceeded the cached freqs will be recomputed\n        base (int): The base for the geometric progression used to compute\n            the rotation angles\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, rotary_emb_base: int=10000, rotary_emb_dim:\n        int=None, max_seq_len: int=4096, **kwargs) ->None:\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.dim = rotary_emb_dim\n        self.base = rotary_emb_base\n        self.max_seq_len = max_seq_len\n        self._rope_init()\n\n    def reset_parameters(self):\n        self._rope_init()\n\n    def _rope_init(self):\n        theta = 1.0 / self.base ** (torch.arange(0, self.dim, 2, **self.\n            factory_kwargs)[:self.dim // 2].float() / self.dim)\n        self.register_buffer('theta', theta, persistent=False)\n        self.build_rope_cache(self.max_seq_len)\n\n    def build_rope_cache(self, max_seq_len: int=4096) ->None:\n        seq_idx = torch.arange(max_seq_len, dtype=self.theta.dtype, device=\n            self.theta.device)\n        idx_theta = torch.einsum('i, j -> ij', seq_idx, self.theta).float()\n        cache = torch.stack([torch.cos(idx_theta), torch.sin(idx_theta)],\n            dim=-1)\n        self.register_buffer('cache', cache, persistent=False)\n\n    def _forward(self, X: Tensor, input_emb: Tensor, input_pos: Optional[\n        Tensor]=None) ->Tensor:\n        \"\"\"\n        Args:\n            x (Tensor): input tensor with shape\n                [b, s, n_h, h_d]\n            input_pos (Optional[Tensor]): Optional tensor which contains the position ids\n                of each token. During training, this is used to indicate the positions\n                of each token relative to its sample when packed, shape [b, s].\n                During inference, this indicates the position of the current token.\n                If none, assume the index of the token is its position id. Default is None.\n\n        Returns:\n            Tensor: output tensor with RoPE applied\n\n        Notation used for tensor shapes:\n            - b: batch size\n            - s: sequence length\n            - n_h: num heads\n            - h_d: head dim\n\n        TODO: The implementation below can be made more efficient\n        for inference.\n        \"\"\"\n        seq_len = input_emb.size(1)\n        rope_cache = self.cache[:seq_len] if input_pos is None else self.cache[\n            input_pos]\n        xshaped = input_emb.float().reshape(*input_emb.shape[:-1], -1, 2)\n        rope_cache = rope_cache.view(-1, xshaped.size(1), 1, xshaped.size(3), 2\n            )\n        x_out = torch.stack([xshaped[..., 0] * rope_cache[..., 0] - xshaped\n            [..., 1] * rope_cache[..., 1], xshaped[..., 1] * rope_cache[...,\n            0] + xshaped[..., 0] * rope_cache[..., 1]], -1)\n        x_out = x_out.flatten(3)\n        output_emb = x_out.type_as(input_emb)\n        return X, {'output_emb': output_emb}\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\n\n\nclass RMSNorm(GAUBase):\n    \"\"\"\n    Root Mean Square Layer Normalization (RMSNorm).\n\n    This layer applies a variant of layer normalization that uses only the root mean square\n    statistics, without centering. It's computationally more efficient than standard\n    layer normalization and has been shown to be effective in various NLP tasks.\n\n    Args:\n        embed_dim (int): The size of the input feature dimension.\n        block_loc (tuple): The location of this block in the model architecture.\n        kwarg_all (dict): Additional keyword arguments passed to the parent class.\n        device (torch.device, optional): The device on which to allocate the module's parameters.\n        dtype (torch.dtype, optional): The dtype of the module's parameters.\n        eps (float, optional): A small constant added to the denominator for numerical stability.\n            Default: 1e-5.\n\n    Attributes:\n        weight (nn.Parameter): Learnable scale parameter of shape (embed_dim,).\n        variance_epsilon (float): The epsilon value used in the normalization formula.\n\n    Shape:\n        - Input: (*, embed_dim)\n        - Output: (*, embed_dim) (same shape as input)\n\n    Examples:\n        >>> rmsnorm = RMSNorm(128, (0, 6), {})\n        >>> x = torch.randn(1, 100, 128)\n        >>> output = rmsnorm(x)\n        >>> print(output.shape)\n        torch.Size([1, 100, 128])\n\n    References:\n        - Paper: \"Root Mean Square Layer Normalization\" by Biao Zhang and Rico Sennrich\n          https://arxiv.org/abs/1910.07467\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, eps=1e-05, **kwargs):\n        \"\"\"If group_size is not None, we do GroupNorm with each group having group_size elements.\n        group_size=None is equivalent to group_size=hidden_size (i.e. there's only 1 group).\n        \"\"\"\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.weight = nn.Parameter(torch.ones(embed_dim, **self.factory_kwargs)\n            )\n        self.variance_epsilon = eps\n\n    def _forward(self, X, **Z):\n        input_dtype = X.dtype\n        X = X.to(torch.float32)\n        variance = X.pow(2).mean(-1, keepdim=True)\n        X = X * torch.rsqrt(variance + self.variance_epsilon)\n        return self.weight * X.to(input_dtype)\n\n\nimport torch.nn.functional as F\n\n\nclass GatedMLP(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, hidden_features=None, out_features=None,\n        activation=None, bias=False, multiple_of=128, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        out_features = out_features if out_features is not None else embed_dim\n        hidden_features = (hidden_features if hidden_features is not None else\n            int(8 * embed_dim / 3))\n        hidden_features = (hidden_features + multiple_of - 1\n            ) // multiple_of * multiple_of\n        self.fc1 = nn.Linear(embed_dim, 2 * hidden_features, bias=bias, **\n            self.factory_kwargs)\n        self.activation = activation if activation is not None else F.silu\n        self.fc2 = nn.Linear(hidden_features, out_features, bias=bias, **\n            self.factory_kwargs)\n\n    def _forward(self, X, **Z):\n        y = self.fc1(X)\n        y, gate = y.chunk(2, dim=-1)\n        y = y * self.activation(gate)\n        y = self.fc2(y)\n        return y\n\n\ngab_config = {'eps': 1e-05, 'rotary_emb_base': 10000.0, 'max_seq_len': 4096,\n    'hidden_features': None, 'out_features': None, 'activation': None,\n    'bias': False, 'multiple_of': 128, 'num_heads': 8, 'num_scales': 2,\n    'dropout': 0.1}\n\n\n\nautoconfig={}\nblock_config=gab_config\nblock_config.update(autoconfig)\n\n\nfrom .block_registry import BlockRegister\n\nBlockRegister(\n    name=\"default\",\n    config=block_config\n)(GAB)"
    },
    "14M": {
        "14M": "import torch\nimport torch.nn as nn\nfrom model_discovery.model.utils.modules import GABBase\n\n\nclass GAB(GABBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, device=None, dtype\n        =None, **kwargs):\n        factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc)\n        self.root = GPT2(embed_dim=embed_dim, block_loc=block_loc,\n            kwarg_all=kwargs, **factory_kwargs, **kwargs)\n\n    def _forward(self, X, **Z):\n        X, Z = self.root(X, **Z)\n        return X, Z\n\n\nimport torch.nn.functional as F\nfrom model_discovery.model.utils.modules import GAUBase, gau_test, UnitDecl\n\n\nclass GPT2(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.mha = HierarchicalAdaptiveAttention(embed_dim=self.embed_dim,\n            block_loc=self.block_loc, kwarg_all=self.kwarg_all, **self.\n            factory_kwargs, **self.kwarg_all)\n        self.mlp = GatedMLP(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm1 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm2 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        X1, Z = self.norm1(X, **Z)\n        X2, Z = self.mha(X1, **Z)\n        X = X + X2\n        X3, Z = self.norm2(X, **Z)\n        X4, Z = self.mlp(X3, **Z)\n        X = X + X4\n        return X, Z\n\n\nimport torch.nn.functional as F\nimport math\nfrom einops import rearrange\n\n\nclass HierarchicalAdaptiveAttention(GAUBase):\n    \"\"\"\n    Hierarchical Adaptive Multi-Head Attention (HA-MHA)\n\n    This module implements a hierarchical adaptive multi-head attention mechanism that\n    captures multi-scale dependencies in the input sequence. It organizes attention heads\n    into hierarchical groups, each responsible for capturing dependencies at different scales\n    (e.g., local, medium, global). An adaptive gating mechanism dynamically allocates attention\n    resources based on the input context, allowing the model to focus on the most relevant\n    information at each scale.\n\n    **Main Features:**\n    - **Hierarchical Structure**: Attention heads are grouped into multiple scales to capture\n      dependencies at different levels.\n    - **Multi-Scale Linear Attention**: Reduces computational complexity from O(N^2) to O(N)\n      within each hierarchical group using linear attention mechanisms.\n    - **Adaptive Gating Mechanism**: Dynamically scales the contribution of each hierarchical group\n      based on the input context using a gating function.\n    - **Dynamic Composition**: Composes attention outputs from all hierarchical groups adaptively.\n    - **Rotary Positional Embeddings**: Incorporates positional information using rotary embeddings.\n\n    Args:\n        embed_dim (int): Total embedding dimension.\n        block_loc (tuple): Location of the block within the network.\n        kwarg_all (dict): Additional keyword arguments.\n        device (torch.device, optional): The device to use.\n        dtype (torch.dtype, optional): The data type to use.\n        num_heads (int): Total number of attention heads.\n        num_scales (int): Number of hierarchical scales.\n        dropout (float): Dropout probability.\n        rotary_emb_base (float): Base for rotary positional embeddings.\n        **kwargs: Additional keyword arguments.\n\n    Attributes:\n        head_dim (int): Dimension of each attention head.\n        query_projs (nn.ModuleList): List of query projections for each scale.\n        key_projs (nn.ModuleList): List of key projections for each scale.\n        value_projs (nn.ModuleList): List of value projections for each scale.\n        gate_proj (nn.Linear): Linear layer for adaptive gating.\n        out_proj (nn.Linear): Output projection layer.\n        rotary_emb (RotaryPositionalEmbeddings): Positional embedding module.\n\n    Shape:\n        - Input: X of shape (batch_size, seq_len, embed_dim)\n        - Output: Y of shape (batch_size, seq_len, embed_dim)\n\n    Examples:\n        >>> attn = HierarchicalAdaptiveAttention(embed_dim=512, block_loc=(0, 1), kwarg_all={}, num_heads=8, num_scales=2)\n        >>> X = torch.randn(2, 10, 512)\n        >>> Y, Z = attn(X)\n        >>> Y.shape\n        torch.Size([2, 10, 512])\n\n    References:\n        - Paper: \"HieraNorm-AttnGPT: Hierarchical Adaptive Multi-Head Attention with Dynamic Layer Normalization\"\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, num_heads: int=8, num_scales: int=2,\n        dropout: float=0.1, rotary_emb_base: float=10000.0, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        assert embed_dim % (num_heads * num_scales\n            ) == 0, 'embed_dim must be divisible by num_heads * num_scales'\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.num_scales = num_scales\n        self.head_dim = embed_dim // (num_heads * num_scales)\n        self.dropout = dropout\n        self.query_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.key_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.value_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.gate_proj = nn.Linear(embed_dim, num_scales, bias=False, **\n            self.factory_kwargs)\n        self.out_proj = nn.Linear(num_heads * self.head_dim * num_scales,\n            embed_dim, **self.factory_kwargs)\n        self.dropout_layer = nn.Dropout(p=self.dropout)\n        kwarg_all['rotary_emb_dim'] = self.head_dim\n        self.rotary_emb = RotaryPositionalEmbeddings(embed_dim=self.\n            embed_dim, block_loc=self.block_loc, kwarg_all=self.kwarg_all,\n            **self.factory_kwargs, **self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        B, L, D = X.size()\n        assert D == self.embed_dim, f'Expected input embedding dimension: {self.embed_dim}, got: {D}'\n        gate_scores = torch.sigmoid(self.gate_proj(X))\n        attn_outputs = []\n        for scale in range(self.num_scales):\n            Q = self.query_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            K = self.key_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            V = self.value_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            Z['input_emb'] = Q\n            _, Z = self.rotary_emb(X, **Z)\n            Q = Z['output_emb']\n            Z['input_emb'] = K\n            _, Z = self.rotary_emb(X, **Z)\n            K = Z['output_emb']\n            scaling_factor = 1.0 / math.sqrt(self.head_dim)\n            Q = Q * scaling_factor\n            K = F.softmax(K, dim=-1)\n            V = V\n            KV = torch.einsum('bhld,bhld->bhld', K, V)\n            attn_output = torch.einsum('bhld,bhld->bhld', Q, KV)\n            attn_output = self.dropout_layer(attn_output)\n            attn_outputs.append(attn_output)\n        attn_output = torch.cat(attn_outputs, dim=-1)\n        attn_output = attn_output.transpose(1, 2).reshape(B, L, -1)\n        gate_scores = gate_scores.unsqueeze(-1)\n        gate_scores = gate_scores.expand(-1, -1, -1, self.num_heads * self.\n            head_dim)\n        attn_output = attn_output.view(B, L, self.num_scales, self.\n            num_heads * self.head_dim)\n        attn_output = attn_output * gate_scores\n        attn_output = attn_output.reshape(B, L, -1)\n        Y = self.out_proj(attn_output)\n        return Y, Z\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\nfrom typing import Optional\n\n\nclass RotaryPositionalEmbeddings(GAUBase):\n    \"\"\"\n    This class implements Rotary Positional Embeddings (RoPE)\n    proposed in https://arxiv.org/abs/2104.09864.\n\n    Reference implementation (used for correctness verfication)\n    can be found here:\n    https://github.com/meta-llama/llama/blob/main/llama/model.py#L80\n\n    In this implementation we cache the embeddings for each position upto\n    ``max_seq_len`` by computing this during init.\n\n    Args:\n        dim (int): Embedding dimension. This is usually set to the dim of each\n            head in the attention module computed as ````embed_dim`` // ``num_heads````\n        max_seq_len (int): Maximum expected sequence length for the\n            model, if exceeded the cached freqs will be recomputed\n        base (int): The base for the geometric progression used to compute\n            the rotation angles\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, rotary_emb_base: int=10000, rotary_emb_dim:\n        int=None, max_seq_len: int=4096, **kwargs) ->None:\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.dim = rotary_emb_dim\n        self.base = rotary_emb_base\n        self.max_seq_len = max_seq_len\n        self._rope_init()\n\n    def reset_parameters(self):\n        self._rope_init()\n\n    def _rope_init(self):\n        theta = 1.0 / self.base ** (torch.arange(0, self.dim, 2, **self.\n            factory_kwargs)[:self.dim // 2].float() / self.dim)\n        self.register_buffer('theta', theta, persistent=False)\n        self.build_rope_cache(self.max_seq_len)\n\n    def build_rope_cache(self, max_seq_len: int=4096) ->None:\n        seq_idx = torch.arange(max_seq_len, dtype=self.theta.dtype, device=\n            self.theta.device)\n        idx_theta = torch.einsum('i, j -> ij', seq_idx, self.theta).float()\n        cache = torch.stack([torch.cos(idx_theta), torch.sin(idx_theta)],\n            dim=-1)\n        self.register_buffer('cache', cache, persistent=False)\n\n    def _forward(self, X: Tensor, input_emb: Tensor, input_pos: Optional[\n        Tensor]=None) ->Tensor:\n        \"\"\"\n        Args:\n            x (Tensor): input tensor with shape\n                [b, s, n_h, h_d]\n            input_pos (Optional[Tensor]): Optional tensor which contains the position ids\n                of each token. During training, this is used to indicate the positions\n                of each token relative to its sample when packed, shape [b, s].\n                During inference, this indicates the position of the current token.\n                If none, assume the index of the token is its position id. Default is None.\n\n        Returns:\n            Tensor: output tensor with RoPE applied\n\n        Notation used for tensor shapes:\n            - b: batch size\n            - s: sequence length\n            - n_h: num heads\n            - h_d: head dim\n\n        TODO: The implementation below can be made more efficient\n        for inference.\n        \"\"\"\n        seq_len = input_emb.size(1)\n        rope_cache = self.cache[:seq_len] if input_pos is None else self.cache[\n            input_pos]\n        xshaped = input_emb.float().reshape(*input_emb.shape[:-1], -1, 2)\n        rope_cache = rope_cache.view(-1, xshaped.size(1), 1, xshaped.size(3), 2\n            )\n        x_out = torch.stack([xshaped[..., 0] * rope_cache[..., 0] - xshaped\n            [..., 1] * rope_cache[..., 1], xshaped[..., 1] * rope_cache[...,\n            0] + xshaped[..., 0] * rope_cache[..., 1]], -1)\n        x_out = x_out.flatten(3)\n        output_emb = x_out.type_as(input_emb)\n        return X, {'output_emb': output_emb}\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\n\n\nclass RMSNorm(GAUBase):\n    \"\"\"\n    Root Mean Square Layer Normalization (RMSNorm).\n\n    This layer applies a variant of layer normalization that uses only the root mean square\n    statistics, without centering. It's computationally more efficient than standard\n    layer normalization and has been shown to be effective in various NLP tasks.\n\n    Args:\n        embed_dim (int): The size of the input feature dimension.\n        block_loc (tuple): The location of this block in the model architecture.\n        kwarg_all (dict): Additional keyword arguments passed to the parent class.\n        device (torch.device, optional): The device on which to allocate the module's parameters.\n        dtype (torch.dtype, optional): The dtype of the module's parameters.\n        eps (float, optional): A small constant added to the denominator for numerical stability.\n            Default: 1e-5.\n\n    Attributes:\n        weight (nn.Parameter): Learnable scale parameter of shape (embed_dim,).\n        variance_epsilon (float): The epsilon value used in the normalization formula.\n\n    Shape:\n        - Input: (*, embed_dim)\n        - Output: (*, embed_dim) (same shape as input)\n\n    Examples:\n        >>> rmsnorm = RMSNorm(128, (0, 6), {})\n        >>> x = torch.randn(1, 100, 128)\n        >>> output = rmsnorm(x)\n        >>> print(output.shape)\n        torch.Size([1, 100, 128])\n\n    References:\n        - Paper: \"Root Mean Square Layer Normalization\" by Biao Zhang and Rico Sennrich\n          https://arxiv.org/abs/1910.07467\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, eps=1e-05, **kwargs):\n        \"\"\"If group_size is not None, we do GroupNorm with each group having group_size elements.\n        group_size=None is equivalent to group_size=hidden_size (i.e. there's only 1 group).\n        \"\"\"\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.weight = nn.Parameter(torch.ones(embed_dim, **self.factory_kwargs)\n            )\n        self.variance_epsilon = eps\n\n    def _forward(self, X, **Z):\n        input_dtype = X.dtype\n        X = X.to(torch.float32)\n        variance = X.pow(2).mean(-1, keepdim=True)\n        X = X * torch.rsqrt(variance + self.variance_epsilon)\n        return self.weight * X.to(input_dtype)\n\n\nimport torch.nn.functional as F\n\n\nclass GatedMLP(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, hidden_features=None, out_features=None,\n        activation=None, bias=False, multiple_of=128, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        out_features = out_features if out_features is not None else embed_dim\n        hidden_features = (hidden_features if hidden_features is not None else\n            int(8 * embed_dim / 3))\n        hidden_features = (hidden_features + multiple_of - 1\n            ) // multiple_of * multiple_of\n        self.fc1 = nn.Linear(embed_dim, 2 * hidden_features, bias=bias, **\n            self.factory_kwargs)\n        self.activation = activation if activation is not None else F.silu\n        self.fc2 = nn.Linear(hidden_features, out_features, bias=bias, **\n            self.factory_kwargs)\n\n    def _forward(self, X, **Z):\n        y = self.fc1(X)\n        y, gate = y.chunk(2, dim=-1)\n        y = y * self.activation(gate)\n        y = self.fc2(y)\n        return y\n\n\ngab_config = {'eps': 1e-05, 'rotary_emb_base': 10000.0, 'max_seq_len': 4096,\n    'hidden_features': None, 'out_features': None, 'activation': None,\n    'bias': False, 'multiple_of': 128, 'num_heads': 8, 'num_scales': 2,\n    'dropout': 0.1}\n\n\n\nautoconfig={}\nblock_config=gab_config\nblock_config.update(autoconfig)\n\n\nfrom .block_registry import BlockRegister\n\nBlockRegister(\n    name=\"default\",\n    config=block_config\n)(GAB)"
    },
    "350M": {
        "350M": "import torch\nimport torch.nn as nn\nfrom model_discovery.model.utils.modules import GABBase\n\n\nclass GAB(GABBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, device=None, dtype\n        =None, **kwargs):\n        factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc)\n        self.root = GPT2(embed_dim=embed_dim, block_loc=block_loc,\n            kwarg_all=kwargs, **factory_kwargs, **kwargs)\n\n    def _forward(self, X, **Z):\n        X, Z = self.root(X, **Z)\n        return X, Z\n\n\nimport torch.nn.functional as F\nfrom model_discovery.model.utils.modules import GAUBase, gau_test, UnitDecl\n\n\nclass GPT2(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.mha = HierarchicalAdaptiveAttention(embed_dim=self.embed_dim,\n            block_loc=self.block_loc, kwarg_all=self.kwarg_all, **self.\n            factory_kwargs, **self.kwarg_all)\n        self.mlp = GatedMLP(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm1 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n        self.norm2 = RMSNorm(embed_dim=self.embed_dim, block_loc=self.\n            block_loc, kwarg_all=self.kwarg_all, **self.factory_kwargs, **\n            self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        X1, Z = self.norm1(X, **Z)\n        X2, Z = self.mha(X1, **Z)\n        X = X + X2\n        X3, Z = self.norm2(X, **Z)\n        X4, Z = self.mlp(X3, **Z)\n        X = X + X4\n        return X, Z\n\n\nimport torch.nn.functional as F\nimport math\nfrom einops import rearrange\n\n\nclass HierarchicalAdaptiveAttention(GAUBase):\n    \"\"\"\n    Hierarchical Adaptive Multi-Head Attention (HA-MHA)\n\n    This module implements a hierarchical adaptive multi-head attention mechanism that\n    captures multi-scale dependencies in the input sequence. It organizes attention heads\n    into hierarchical groups, each responsible for capturing dependencies at different scales\n    (e.g., local, medium, global). An adaptive gating mechanism dynamically allocates attention\n    resources based on the input context, allowing the model to focus on the most relevant\n    information at each scale.\n\n    **Main Features:**\n    - **Hierarchical Structure**: Attention heads are grouped into multiple scales to capture\n      dependencies at different levels.\n    - **Multi-Scale Linear Attention**: Reduces computational complexity from O(N^2) to O(N)\n      within each hierarchical group using linear attention mechanisms.\n    - **Adaptive Gating Mechanism**: Dynamically scales the contribution of each hierarchical group\n      based on the input context using a gating function.\n    - **Dynamic Composition**: Composes attention outputs from all hierarchical groups adaptively.\n    - **Rotary Positional Embeddings**: Incorporates positional information using rotary embeddings.\n\n    Args:\n        embed_dim (int): Total embedding dimension.\n        block_loc (tuple): Location of the block within the network.\n        kwarg_all (dict): Additional keyword arguments.\n        device (torch.device, optional): The device to use.\n        dtype (torch.dtype, optional): The data type to use.\n        num_heads (int): Total number of attention heads.\n        num_scales (int): Number of hierarchical scales.\n        dropout (float): Dropout probability.\n        rotary_emb_base (float): Base for rotary positional embeddings.\n        **kwargs: Additional keyword arguments.\n\n    Attributes:\n        head_dim (int): Dimension of each attention head.\n        query_projs (nn.ModuleList): List of query projections for each scale.\n        key_projs (nn.ModuleList): List of key projections for each scale.\n        value_projs (nn.ModuleList): List of value projections for each scale.\n        gate_proj (nn.Linear): Linear layer for adaptive gating.\n        out_proj (nn.Linear): Output projection layer.\n        rotary_emb (RotaryPositionalEmbeddings): Positional embedding module.\n\n    Shape:\n        - Input: X of shape (batch_size, seq_len, embed_dim)\n        - Output: Y of shape (batch_size, seq_len, embed_dim)\n\n    Examples:\n        >>> attn = HierarchicalAdaptiveAttention(embed_dim=512, block_loc=(0, 1), kwarg_all={}, num_heads=8, num_scales=2)\n        >>> X = torch.randn(2, 10, 512)\n        >>> Y, Z = attn(X)\n        >>> Y.shape\n        torch.Size([2, 10, 512])\n\n    References:\n        - Paper: \"HieraNorm-AttnGPT: Hierarchical Adaptive Multi-Head Attention with Dynamic Layer Normalization\"\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, num_heads: int=8, num_scales: int=2,\n        dropout: float=0.1, rotary_emb_base: float=10000.0, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        assert embed_dim % (num_heads * num_scales\n            ) == 0, 'embed_dim must be divisible by num_heads * num_scales'\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.num_scales = num_scales\n        self.head_dim = embed_dim // (num_heads * num_scales)\n        self.dropout = dropout\n        self.query_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.key_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.value_projs = nn.ModuleList([nn.Linear(embed_dim, num_heads *\n            self.head_dim, bias=False, **self.factory_kwargs) for _ in\n            range(num_scales)])\n        self.gate_proj = nn.Linear(embed_dim, num_scales, bias=False, **\n            self.factory_kwargs)\n        self.out_proj = nn.Linear(num_heads * self.head_dim * num_scales,\n            embed_dim, **self.factory_kwargs)\n        self.dropout_layer = nn.Dropout(p=self.dropout)\n        kwarg_all['rotary_emb_dim'] = self.head_dim\n        self.rotary_emb = RotaryPositionalEmbeddings(embed_dim=self.\n            embed_dim, block_loc=self.block_loc, kwarg_all=self.kwarg_all,\n            **self.factory_kwargs, **self.kwarg_all)\n\n    def _forward(self, X, **Z):\n        B, L, D = X.size()\n        assert D == self.embed_dim, f'Expected input embedding dimension: {self.embed_dim}, got: {D}'\n        gate_scores = torch.sigmoid(self.gate_proj(X))\n        attn_outputs = []\n        for scale in range(self.num_scales):\n            Q = self.query_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            K = self.key_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            V = self.value_projs[scale](X).view(B, L, self.num_heads, self.\n                head_dim).transpose(1, 2)\n            Z['input_emb'] = Q\n            _, Z = self.rotary_emb(X, **Z)\n            Q = Z['output_emb']\n            Z['input_emb'] = K\n            _, Z = self.rotary_emb(X, **Z)\n            K = Z['output_emb']\n            scaling_factor = 1.0 / math.sqrt(self.head_dim)\n            Q = Q * scaling_factor\n            K = F.softmax(K, dim=-1)\n            V = V\n            KV = torch.einsum('bhld,bhld->bhld', K, V)\n            attn_output = torch.einsum('bhld,bhld->bhld', Q, KV)\n            attn_output = self.dropout_layer(attn_output)\n            attn_outputs.append(attn_output)\n        attn_output = torch.cat(attn_outputs, dim=-1)\n        attn_output = attn_output.transpose(1, 2).reshape(B, L, -1)\n        gate_scores = gate_scores.unsqueeze(-1)\n        gate_scores = gate_scores.expand(-1, -1, -1, self.num_heads * self.\n            head_dim)\n        attn_output = attn_output.view(B, L, self.num_scales, self.\n            num_heads * self.head_dim)\n        attn_output = attn_output * gate_scores\n        attn_output = attn_output.reshape(B, L, -1)\n        Y = self.out_proj(attn_output)\n        return Y, Z\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\nfrom typing import Optional\n\n\nclass RotaryPositionalEmbeddings(GAUBase):\n    \"\"\"\n    This class implements Rotary Positional Embeddings (RoPE)\n    proposed in https://arxiv.org/abs/2104.09864.\n\n    Reference implementation (used for correctness verfication)\n    can be found here:\n    https://github.com/meta-llama/llama/blob/main/llama/model.py#L80\n\n    In this implementation we cache the embeddings for each position upto\n    ``max_seq_len`` by computing this during init.\n\n    Args:\n        dim (int): Embedding dimension. This is usually set to the dim of each\n            head in the attention module computed as ````embed_dim`` // ``num_heads````\n        max_seq_len (int): Maximum expected sequence length for the\n            model, if exceeded the cached freqs will be recomputed\n        base (int): The base for the geometric progression used to compute\n            the rotation angles\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, rotary_emb_base: int=10000, rotary_emb_dim:\n        int=None, max_seq_len: int=4096, **kwargs) ->None:\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.dim = rotary_emb_dim\n        self.base = rotary_emb_base\n        self.max_seq_len = max_seq_len\n        self._rope_init()\n\n    def reset_parameters(self):\n        self._rope_init()\n\n    def _rope_init(self):\n        theta = 1.0 / self.base ** (torch.arange(0, self.dim, 2, **self.\n            factory_kwargs)[:self.dim // 2].float() / self.dim)\n        self.register_buffer('theta', theta, persistent=False)\n        self.build_rope_cache(self.max_seq_len)\n\n    def build_rope_cache(self, max_seq_len: int=4096) ->None:\n        seq_idx = torch.arange(max_seq_len, dtype=self.theta.dtype, device=\n            self.theta.device)\n        idx_theta = torch.einsum('i, j -> ij', seq_idx, self.theta).float()\n        cache = torch.stack([torch.cos(idx_theta), torch.sin(idx_theta)],\n            dim=-1)\n        self.register_buffer('cache', cache, persistent=False)\n\n    def _forward(self, X: Tensor, input_emb: Tensor, input_pos: Optional[\n        Tensor]=None) ->Tensor:\n        \"\"\"\n        Args:\n            x (Tensor): input tensor with shape\n                [b, s, n_h, h_d]\n            input_pos (Optional[Tensor]): Optional tensor which contains the position ids\n                of each token. During training, this is used to indicate the positions\n                of each token relative to its sample when packed, shape [b, s].\n                During inference, this indicates the position of the current token.\n                If none, assume the index of the token is its position id. Default is None.\n\n        Returns:\n            Tensor: output tensor with RoPE applied\n\n        Notation used for tensor shapes:\n            - b: batch size\n            - s: sequence length\n            - n_h: num heads\n            - h_d: head dim\n\n        TODO: The implementation below can be made more efficient\n        for inference.\n        \"\"\"\n        seq_len = input_emb.size(1)\n        rope_cache = self.cache[:seq_len] if input_pos is None else self.cache[\n            input_pos]\n        xshaped = input_emb.float().reshape(*input_emb.shape[:-1], -1, 2)\n        rope_cache = rope_cache.view(-1, xshaped.size(1), 1, xshaped.size(3), 2\n            )\n        x_out = torch.stack([xshaped[..., 0] * rope_cache[..., 0] - xshaped\n            [..., 1] * rope_cache[..., 1], xshaped[..., 1] * rope_cache[...,\n            0] + xshaped[..., 0] * rope_cache[..., 1]], -1)\n        x_out = x_out.flatten(3)\n        output_emb = x_out.type_as(input_emb)\n        return X, {'output_emb': output_emb}\n\n\nimport torch.nn.functional as F\nfrom torch import Tensor\n\n\nclass RMSNorm(GAUBase):\n    \"\"\"\n    Root Mean Square Layer Normalization (RMSNorm).\n\n    This layer applies a variant of layer normalization that uses only the root mean square\n    statistics, without centering. It's computationally more efficient than standard\n    layer normalization and has been shown to be effective in various NLP tasks.\n\n    Args:\n        embed_dim (int): The size of the input feature dimension.\n        block_loc (tuple): The location of this block in the model architecture.\n        kwarg_all (dict): Additional keyword arguments passed to the parent class.\n        device (torch.device, optional): The device on which to allocate the module's parameters.\n        dtype (torch.dtype, optional): The dtype of the module's parameters.\n        eps (float, optional): A small constant added to the denominator for numerical stability.\n            Default: 1e-5.\n\n    Attributes:\n        weight (nn.Parameter): Learnable scale parameter of shape (embed_dim,).\n        variance_epsilon (float): The epsilon value used in the normalization formula.\n\n    Shape:\n        - Input: (*, embed_dim)\n        - Output: (*, embed_dim) (same shape as input)\n\n    Examples:\n        >>> rmsnorm = RMSNorm(128, (0, 6), {})\n        >>> x = torch.randn(1, 100, 128)\n        >>> output = rmsnorm(x)\n        >>> print(output.shape)\n        torch.Size([1, 100, 128])\n\n    References:\n        - Paper: \"Root Mean Square Layer Normalization\" by Biao Zhang and Rico Sennrich\n          https://arxiv.org/abs/1910.07467\n    \"\"\"\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, eps=1e-05, **kwargs):\n        \"\"\"If group_size is not None, we do GroupNorm with each group having group_size elements.\n        group_size=None is equivalent to group_size=hidden_size (i.e. there's only 1 group).\n        \"\"\"\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        self.weight = nn.Parameter(torch.ones(embed_dim, **self.factory_kwargs)\n            )\n        self.variance_epsilon = eps\n\n    def _forward(self, X, **Z):\n        input_dtype = X.dtype\n        X = X.to(torch.float32)\n        variance = X.pow(2).mean(-1, keepdim=True)\n        X = X * torch.rsqrt(variance + self.variance_epsilon)\n        return self.weight * X.to(input_dtype)\n\n\nimport torch.nn.functional as F\n\n\nclass GatedMLP(GAUBase):\n\n    def __init__(self, embed_dim: int, block_loc: tuple, kwarg_all: dict,\n        device=None, dtype=None, hidden_features=None, out_features=None,\n        activation=None, bias=False, multiple_of=128, **kwargs):\n        self.factory_kwargs = {'device': device, 'dtype': dtype}\n        super().__init__(embed_dim, block_loc, kwarg_all)\n        out_features = out_features if out_features is not None else embed_dim\n        hidden_features = (hidden_features if hidden_features is not None else\n            int(8 * embed_dim / 3))\n        hidden_features = (hidden_features + multiple_of - 1\n            ) // multiple_of * multiple_of\n        self.fc1 = nn.Linear(embed_dim, 2 * hidden_features, bias=bias, **\n            self.factory_kwargs)\n        self.activation = activation if activation is not None else F.silu\n        self.fc2 = nn.Linear(hidden_features, out_features, bias=bias, **\n            self.factory_kwargs)\n\n    def _forward(self, X, **Z):\n        y = self.fc1(X)\n        y, gate = y.chunk(2, dim=-1)\n        y = y * self.activation(gate)\n        y = self.fc2(y)\n        return y\n\n\ngab_config = {'eps': 1e-05, 'rotary_emb_base': 10000.0, 'max_seq_len': 4096,\n    'hidden_features': None, 'out_features': None, 'activation': None,\n    'bias': False, 'multiple_of': 128, 'num_heads': 8, 'num_scales': 2,\n    'dropout': 0.1}\n\n\n\nautoconfig={}\nblock_config=gab_config\nblock_config.update(autoconfig)\n\n\nfrom .block_registry import BlockRegister\n\nBlockRegister(\n    name=\"default\",\n    config=block_config\n)(GAB)"
    }
}